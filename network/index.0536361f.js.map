{"mappings":"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","sources":["src/lib/easings.ts","src/network/ConnectionDirection.ts","src/network/effects/Pulse.ts","src/network/colors.ts","src/network/ConnectionSet.ts","src/network/networkNodes/Consumer.ts","src/lib/scene/SceneSystem.ts","src/network/TravellerFinder.ts","src/network/PathFinder.ts","src/network/networkNodes/Intersection.ts","src/network/Traveller.ts","src/pals/makePal.ts","src/lib/geom/Path.ts","src/network/Junction.ts","src/network/Road.ts","src/network/networkNodes/Producer.ts","src/network/network-main.ts"],"sourcesContent":["import { approxEq } from './utils';\n\n/** n should be between 0 and 1 */\nexport type Easing = (n: number) => number;\n\n// based on https://github.com/servo/servo/blob/0d0cfd030347ab0711b3c0607a9ee07ffe7124cf/components/style/bezier.rs\nclass UnitBezier {\n  private static readonly NEWTON_METHOD_ITERATIONS = 8;\n  private static readonly DEFAULT_EPSILON = 1e-6;\n  private readonly ax: number;\n  private readonly bx: number;\n  private readonly cx: number;\n  private readonly ay: number;\n  private readonly by: number;\n  private readonly cy: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    const cx = 3 * x1;\n    const bx = 3 * (x2 - x1) - cx;\n\n    const cy = 3 * y1;\n    const by = 3 * (y2 - y1) - cy;\n\n    this.ax = 1.0 - cx - bx;\n    this.bx = bx;\n    this.cx = cx;\n    this.ay = 1.0 - cy - by;\n    this.by = by;\n    this.cy = cy;\n  }\n\n  private sampleCurveX(t: number): number {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }\n\n  private sampleCurveY(t: number): number {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }\n\n  private sampleCurveDerivativeX(t: number): number {\n    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n  }\n\n  private solveCurveX(x: number, epsilon: number): number {\n    // Fast path: Use Newton's method.\n    let t = x;\n    for (let i = 0; i < UnitBezier.NEWTON_METHOD_ITERATIONS; i++) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      let dx = this.sampleCurveDerivativeX(t);\n      if (approxEq(dx, 0.0, 1e-6)) {\n        break;\n      }\n      t -= (x2 - x) / dx;\n    }\n\n    // Slow path: Use bisection.\n    let lo = 0;\n    let hi = 1;\n    t = x;\n\n    if (t < lo) {\n      return lo;\n    }\n    if (t > hi) {\n      return hi;\n    }\n\n    while (lo < hi) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      if (x > x2) {\n        lo = t;\n      } else {\n        hi = t;\n      }\n      t = (hi - lo) / 2.0 + lo;\n    }\n\n    return t;\n  }\n\n  solve(x: number, epsilon: number = UnitBezier.DEFAULT_EPSILON): number {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n  }\n}\n\nexport const cubicBezier = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): Easing => {\n  const bezier = new UnitBezier(x1, y1, x2, y2);\n  return (x) => bezier.solve(x);\n};\n\n/**\n * P(t) = (1-t)^3*P0 + 3*t*(1-t)^2*P1 + 3*t^2*(1-t)*P2 + t^3*P3\n * x = 3*t*(1-t)^2*p1x + 3*t^2*(1-t)*p2x + t^3\n * y(t) = 3*t*(1-t)^2*p1y + 3*t^2*(1-t)*p2y + t^3\n *\n *\n * y = 3*u1*(1-x)^2*x + 3*u2*(1-x)*x^2 + x^3\n */\n\n// https://gist.github.com/rezoner/713615dabedb59a15470\n// http://gsgd.co.uk/sandbox/jquery/easing/\nexport const reverse =\n  (easing: (n: number) => number) =>\n  (n: number): number =>\n    easing(1 - n);\n\nexport const linear = (n: number): number => n;\n\nexport const inQuad = (t: number): number => t * t;\n\nexport const outQuad = (t: number): number => t * (2 - t);\n\nexport const inOutQuad = (t: number): number =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\nexport const inCubic = (t: number): number => t * t * t;\n\nexport const outCubic = (t: number): number => --t * t * t + 1;\n\nexport const inOutCubic = (t: number): number =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nexport const inQuart = (t: number): number => t * t * t * t;\n\nexport const outQuart = (t: number): number => 1 - --t * t * t * t;\n\nexport const inOutQuart = (t: number): number =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\nexport const inQuint = (t: number): number => t * t * t * t * t;\n\nexport const outQuint = (t: number): number => 1 + --t * t * t * t * t;\n\nexport const inOutQuint = (t: number): number =>\n  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nexport const inSine = (t: number): number =>\n  -1 * Math.cos((t / 1) * (Math.PI * 0.5)) + 1;\n\nexport const outSine = (t: number): number =>\n  Math.sin((t / 1) * (Math.PI * 0.5));\n\nexport const inOutSine = (t: number): number =>\n  (-1 / 2) * (Math.cos(Math.PI * t) - 1);\n\nexport const inExpo = (t: number): number =>\n  t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n\nexport const outExpo = (t: number): number =>\n  t == 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n\nexport const inOutExpo = (t: number): number => {\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if ((t /= 1 / 2) < 1) return (1 / 2) * Math.pow(2, 10 * (t - 1));\n  return (1 / 2) * (-Math.pow(2, -10 * --t) + 2);\n};\n\nexport const inCirc = (t: number): number => -1 * (Math.sqrt(1 - t * t) - 1);\n\nexport const outCirc = (t: number): number => Math.sqrt(1 - (t = t - 1) * t);\n\nexport const inOutCirc = (t: number): number => {\n  if ((t /= 1 / 2) < 1) return (-1 / 2) * (Math.sqrt(1 - t * t) - 1);\n  return (1 / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1);\n};\n\nexport const inElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return -(\n    a *\n    Math.pow(2, 10 * (t -= 1)) *\n    Math.sin(((t - s) * (2 * Math.PI)) / p)\n  );\n};\n\nexport const outElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return a * Math.pow(2, -10 * t) * Math.sin(((t - s) * (2 * Math.PI)) / p) + 1;\n};\n\nexport const inOutElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if ((t /= 1 / 2) == 2) return 1;\n  if (!p) p = 0.3 * 1.5;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  if (t < 1)\n    return (\n      -0.5 *\n      (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p))\n    );\n  return (\n    a *\n      Math.pow(2, -10 * (t -= 1)) *\n      Math.sin(((t - s) * (2 * Math.PI)) / p) *\n      0.5 +\n    1\n  );\n};\n\nexport const inBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    return 1 * t * t * ((s + 1) * t - s);\n  };\n\nexport const outBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    t = t - 1;\n    return 1 * (t * t * ((s + 1) * t + s) + 1);\n  };\n\nexport const inOutBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    if ((t /= 1 / 2) < 1)\n      return (1 / 2) * (t * t * (((s *= 1.525) + 1) * t - s));\n    return (1 / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  };\n\nexport const inBounce = (t: number): number => {\n  return 1 - outBounce(1 - t);\n};\n\nexport const outBounce = (t: number): number => {\n  if ((t /= 1) < 1 / 2.75) {\n    return 7.5625 * t * t;\n  } else if (t < 2 / 2.75) {\n    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n  } else if (t < 2.5 / 2.75) {\n    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n  } else {\n    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n  }\n};\n\nexport const inOutBounce = (t: number): number => {\n  if (t < 1 / 2) return inBounce(t * 2) * 0.5;\n  return outBounce(t * 2 - 1) * 0.5 + 0.5;\n};\n","enum ConnectionDirection {\n  IN = 'in',\n  OUT = 'out',\n}\n\nexport default ConnectionDirection;\n","import Color from 'color';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport Circle from '../../lib/geom/Circle';\nimport { linear, Easing } from '../../lib/easings';\nimport { lerp } from '../../lib/utils';\n\ntype PulseOptions = {\n  x: number;\n  y: number;\n  startRadius: number;\n  endRadius: number;\n  duration: number;\n  color: Color;\n  easeRadius?: Easing;\n  easeOpacity?: Easing;\n  removeOnComplete?: boolean;\n};\n\nexport default class Pulse extends SceneObject {\n  _circle: Circle;\n  _startRadius: number;\n  _endRadius: number;\n  _duration: number;\n  _color: Color;\n  _progress: number;\n  _easeRadius: Easing;\n  _easeOpacity: Easing;\n  _removeOnComplete: boolean;\n\n  constructor({\n    x,\n    y,\n    startRadius,\n    endRadius,\n    duration,\n    color,\n    easeRadius = linear,\n    easeOpacity = linear,\n    removeOnComplete = false,\n  }: PulseOptions) {\n    super();\n    this._circle = Circle.create(x, y, startRadius);\n    this._startRadius = startRadius;\n    this._endRadius = endRadius;\n    this._duration = duration;\n    this._color = color;\n    this._progress = 0;\n    this._easeRadius = easeRadius;\n    this._easeOpacity = easeOpacity;\n    this._removeOnComplete = removeOnComplete;\n  }\n\n  update(deltaTime: number) {\n    const deltaProgress = deltaTime / this._duration;\n    this._progress = Math.min(1, this._progress + deltaProgress);\n    this._circle = this._circle.withRadius(\n      lerp(\n        this._startRadius,\n        this._endRadius,\n        this._easeRadius(this._progress),\n      ),\n    );\n\n    if (this._progress === 1 && this._removeOnComplete) {\n      this.getScene().removeChild(this);\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    const opacity = this._easeOpacity(this._progress);\n    ctx.fillStyle = this._color.fade(opacity).toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n  }\n}\n","import Color from 'color';\n\n// https://coolors.co/f8ffe5-06d6a0-1b9aaa-ef476f-ffc43d\nexport const LIGHT_BG = new Color('#F8FFE5');\nexport const TEAL = new Color('#06D6A0');\nexport const BLUE = new Color('#1B9AAA');\nexport const RED = new Color('#EF476F');\nexport const YELLOW = new Color('#FFC43D');\n","import { sample } from '../lib/utils';\nimport Road from './Road';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class ConnectionSet {\n  incoming: Road[] = [];\n  outgoing: Road[] = [];\n\n  add(target: Road, direction: ConnectionDirection) {\n    switch (direction) {\n      case ConnectionDirection.IN:\n        this.addIncoming(target);\n        break;\n      case ConnectionDirection.OUT:\n        this.addOutgoing(target);\n        break;\n      default:\n        throw new Error(`unknow connection direction ${direction}`);\n    }\n  }\n\n  addIncoming(target: Road) {\n    this.incoming.push(target);\n  }\n\n  addOutgoing(target: Road) {\n    this.outgoing.push(target);\n  }\n\n  sampleIncoming(): Road {\n    return sample(this.incoming);\n  }\n\n  sampleOutgoing(): Road {\n    return sample(this.outgoing);\n  }\n}\n","// @flow\nimport { assert } from '../../lib/assert';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { inBack, reverse, linear } from '../../lib/easings';\nimport { constrain, mapRange } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { RED } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 1000;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst PULSE_RADIUS = 25;\n\nconst CLOCK_FADE_DURATION = 150;\nconst PULSE_DURATION = 500;\n\nconst MAIN_COLOR = RED.lighten(0.2).desaturate(0.5);\nconst CLOCK_COLOR = RED.darken(0.2);\nconst PULSE_COLOR = RED.lighten(0.2).fade(0.4);\n\nexport default class Consumer extends SceneObject implements NetworkNode {\n  isDestination = true;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number = 0;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = Circle.create(x, y, RADIUS);\n    this._visualConnectionCircle = Circle.create(\n      x,\n      y,\n      VISUAL_CONNECTION_RADIUS,\n    );\n    this._cooldown = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return this._timer >= this._cooldown;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return [this];\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  consumeTraveller() {\n    assert(this.canConsumeTraveller, 'must be ready to consumer traveller');\n    this._resetTimer();\n    this._pulse();\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius * progress,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        endRadius: RADIUS,\n        startRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: inBack(4),\n        easeOpacity: reverse(linear),\n        removeOnComplete: true,\n      }),\n    );\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport Scene from './Scene';\n\nconst DEFAULT_NAME = '$$AbstractSceneSystem$$';\n\nexport default abstract class SceneSystem {\n  static systemName = DEFAULT_NAME;\n  private scene: Scene | null = null;\n\n  constructor() {\n    assert(\n      this.constructor !== SceneSystem,\n      'SceneSystem is an abstract class that must be extended',\n    );\n    assert(\n      (this.constructor as any).systemName !== DEFAULT_NAME,\n      'classes extending SceneSystem must override SceneSystem.systemName',\n    );\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene is required');\n    return this.scene;\n  }\n\n  afterAddToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeRemoveFromScene(scene: Scene) {\n    this.scene = null;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  beforeDraw(ctx: CanvasRenderingContext2D, time: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterDraw(ctx: CanvasRenderingContext2D, time: number) {}\n}\n","// @flow\nimport Scene from '../lib/scene/Scene';\nimport SceneSystem from '../lib/scene/SceneSystem';\nimport QuadTree from '../lib/QuadTree';\nimport Circle from '../lib/geom/Circle';\nimport AABB from '../lib/geom/AABB';\nimport Traveller from './Traveller';\n\nexport default class TravellerFinder extends SceneSystem {\n  static systemName = 'TravellerFinder';\n\n  _quadTree!: QuadTree<Traveller>;\n\n  removeTraveller(traveller: Traveller) {\n    this._quadTree.remove(traveller);\n  }\n\n  afterAddToScene(scene: Scene) {\n    super.afterAddToScene(scene);\n    this._quadTree = new QuadTree(\n      AABB.fromLeftTopRightBottom(0, 0, scene.width, scene.height),\n      traveller => traveller.position,\n    );\n  }\n\n  beforeUpdate() {\n    const scene = this.getScene();\n    this._quadTree.clear();\n    scene.children.forEach(child => {\n      if (child instanceof Traveller) {\n        this._quadTree.insert(child);\n      }\n    });\n    // this._quadTree.debugDraw('red');\n  }\n\n  findTravellersInCircle(circle: Circle) {\n    return this._quadTree.findItemsInCircle(circle);\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Road from './Road';\nimport { NetworkNode } from './networkNodes/NetworkNode';\n\nconst PathFinder = {\n  getNextRoad(initialNode: NetworkNode, destinationNode: NetworkNode): Road {\n    const remainingNodes = new Set(initialNode.getAllReachableNodes());\n    remainingNodes.add(initialNode);\n    assert(\n      remainingNodes.has(destinationNode),\n      'destination must be reachable',\n    );\n    const bestCosts = new Map();\n    const prevRoads = new Map();\n\n    bestCosts.set(initialNode, 0);\n\n    while (remainingNodes.size) {\n      const { node, cost } = PathFinder._nodeWithShortestDistance(\n        remainingNodes,\n        bestCosts,\n      );\n      remainingNodes.delete(node);\n\n      if (node === destinationNode) {\n        return PathFinder._nextRoadFromRoute(\n          prevRoads,\n          initialNode,\n          destinationNode,\n        );\n      }\n\n      PathFinder._updateNeighbours(node, bestCosts, cost, prevRoads);\n    }\n\n    throw new Error('unreachable i hope');\n  },\n\n  _nodeWithShortestDistance(\n    nodes: Set<NetworkNode>,\n    costs: Map<NetworkNode, number>,\n  ): { node: NetworkNode; cost: number } {\n    let bestCost = Infinity;\n    let bestNode = null;\n\n    nodes.forEach(node => {\n      const cost = costs.get(node);\n      if (cost != null && cost <= bestCost) {\n        bestCost = cost;\n        bestNode = node;\n      }\n    });\n\n    assert(bestNode, 'node must be found');\n    return { node: bestNode, cost: bestCost };\n  },\n  _updateNeighbours(\n    node: NetworkNode,\n    bestCosts: Map<NetworkNode, number>,\n    cost: number,\n    prevRoads: Map<NetworkNode, Road>,\n  ) {\n    node.outgoingConnections.forEach(road => {\n      const nextNode = road.to;\n      const nextNodeCost = bestCosts.get(nextNode);\n      const altNextNodeCost = cost + road.expectedTimeFromStartToEnd;\n      if (nextNodeCost == null || altNextNodeCost <= nextNodeCost) {\n        bestCosts.set(nextNode, altNextNodeCost);\n        prevRoads.set(nextNode, road);\n      }\n    });\n  },\n  _nextRoadFromRoute(\n    prevRoads: Map<NetworkNode, Road>,\n    start: NetworkNode,\n    finish: NetworkNode,\n  ): Road {\n    let node = finish;\n    while (prevRoads.has(node)) {\n      const road = prevRoads.get(node);\n      assert(road, 'road must exist');\n      node = road.from;\n      if (node === start) return road;\n    }\n\n    throw new Error('prev road must be found');\n  },\n};\n\nexport default PathFinder;\n","// @flow\nimport { assert } from '../../lib/assert';\nimport Vector2 from '../../lib/geom/Vector2';\nimport { uniq, flatten } from '../../lib/utils';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport PathFinder from '../PathFinder';\nimport Road from '../Road';\nimport Traveller from '../Traveller';\nimport { NetworkNode } from './NetworkNode';\n\nexport default class Intersection implements NetworkNode {\n  isDestination = false;\n  position: Vector2;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number) {\n    this.position = new Vector2(x, y);\n  }\n\n  get incomingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.outgoing;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return true;\n  }\n\n  consumeTraveller(traveller: Traveller) {\n    const destination = traveller.destination;\n    assert(destination, 'traveller must have destination');\n\n    const nextRoad = PathFinder.getNextRoad(this, destination);\n    assert(\n      this.outgoingConnections.includes(nextRoad),\n      'nextRoad must be from this intersection',\n    );\n\n    traveller.removeFromCurrentRoad();\n    nextRoad.addTravellerAtStart(traveller);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(): Vector2 {\n    return this.position;\n  }\n\n  getClosestOutgoingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.outgoingConnections.forEach(road => {\n      const traveller = road.getTravellerAfterPosition(-1);\n      if (traveller && traveller.positionOnCurrentRoad < shortestDistance) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.positionOnCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getClosestIncomingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.incomingConnections.forEach(road => {\n      const traveller = road.getTravellerBeforePosition(road.length);\n      if (\n        traveller &&\n        traveller.distanceToEndOfCurrentRoad < shortestDistance\n      ) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.distanceToEndOfCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n}\n","import { assert } from '../lib/assert';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { outBack, inBack } from '../lib/easings';\nimport { sample, constrain, mapRange, random } from '../lib/utils';\nimport TravellerFinder from './TravellerFinder';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Intersection from './networkNodes/Intersection';\nimport Road from './Road';\nimport Entity from '../lib/scene/Entity';\nimport { makeAbsolutePal } from '../pals/makePal';\nimport { PalAbsoluteController } from '../pals/PalController';\n\n// const TRAVELLER_COLOR = BLUE.fade(0.4);\n// const TRAVELLER_RADIUS = 14;\nconst MIN_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MAX_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MIN_TRAVELLER_SAFE_RADIUS = 30;\nconst MAX_TRAVELLER_SAFE_RADIUS = 30;\nconst NEARBY_RADIUS = 200;\n\nconst INITIAL_SPEED = 5;\nconst MAX_SPEED = 80;\nconst ACCELERATION = 200;\nconst DECELERATION = -200;\nconst ROAD_END_OVERSHOOT = 0;\n\nconst PATIENCE = 1500;\nconst FORCE_ACCELERATE_DURATION = 100;\n\nconst ENTER_DURATION = 400;\nconst EXIT_DURATION = 400;\n\nconst enterEase = outBack(3);\nconst exitEase = inBack(3);\n\nenum StopReason {\n  STOPPED_FOR_DESTINATION = 'STOPPED_FOR_DESTINATION',\n  STOPPED_FOR_TRAFFIC_IN_FRONT = 'STOPPED_FOR_TRAFFIC_IN_FRONT',\n  STOPPED_FOR_TRAFFIC_NEARBY = 'STOPPED_FOR_TRAFFIC_NEARBY',\n}\n\nexport default class Traveller extends SceneObject {\n  static MAX_SPEED = MAX_SPEED;\n  static StopReason = StopReason;\n\n  comfortableRadius = random(\n    MIN_TRAVELLER_COMFORTABLE_RADIUS,\n    MAX_TRAVELLER_COMFORTABLE_RADIUS,\n  );\n  safeRadius = random(MIN_TRAVELLER_SAFE_RADIUS, MAX_TRAVELLER_SAFE_RADIUS);\n  _currentRoad: Road | null = null;\n  _destination: NetworkNode | null = null;\n  _positionOnCurrentRoad: number = 0;\n  _speed: number = INITIAL_SPEED;\n  _age: number = 0;\n  _exitStartedAt: number | null = null;\n  _stoppedTime: number = 0;\n  _forceAccelerateTimer: number = 0;\n  _stopReason: StopReason | null = null;\n  _stoppedFor: Traveller[] = [];\n  _pal: Entity | null = null;\n\n  get currentRoad(): Road | null {\n    return this._currentRoad;\n  }\n\n  get position(): Vector2 {\n    assert(this._currentRoad, 'currentRoad must be defined');\n    return this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad);\n  }\n\n  // get predictedPositionInDirectionOfTravel(): Vector2 {\n  //   assert(this._currentRoad, 'currentRoad must be defined');\n  //   return this._getPredictedPointForPosition(\n  //     this._currentRoad,\n  //     this._positionOnCurrentRoad + 1,\n  //   );\n  // }\n\n  get predictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition);\n  }\n\n  get predictedStopArea(): Circle {\n    const center = this.predictedStopPoint;\n    return Circle.create(center.x, center.y, this.safeRadius);\n  }\n\n  get potentialNextPredictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition + 1);\n  }\n\n  get positionOnCurrentRoad(): number {\n    return this._positionOnCurrentRoad;\n  }\n\n  get distanceToEndOfCurrentRoad(): number {\n    assert(this._currentRoad, 'traveller is not on a road');\n    return this._currentRoad.length - this._positionOnCurrentRoad;\n  }\n\n  get destination(): NetworkNode | null {\n    return this._destination;\n  }\n\n  get speed(): number {\n    return this._speed;\n  }\n\n  get isStopped(): boolean {\n    return this.speed === 0;\n  }\n\n  get stoppedTime(): number {\n    return this._stoppedTime;\n  }\n\n  get stopReason(): StopReason | null {\n    return this._stopReason;\n  }\n\n  isStoppedFor(other: Traveller): boolean {\n    return this._stoppedFor.includes(other);\n  }\n\n  onAddedToRoad(road: Road) {\n    this._currentRoad = road;\n    this._positionOnCurrentRoad = 0;\n    if (!this._destination) {\n      this._pickDestination();\n    }\n  }\n\n  onRemovedFromRoad() {\n    this.getScene().getSystem(TravellerFinder).removeTraveller(this);\n    this._currentRoad = null;\n  }\n\n  onRemovedFromScene() {\n    this.removeFromCurrentRoad();\n  }\n\n  removeFromCurrentRoad() {\n    if (this._currentRoad) this._currentRoad.removeTraveller(this);\n  }\n\n  update(dtMilliseconds: number) {\n    this._age += dtMilliseconds;\n    this._stopReason = null;\n    this._stoppedFor = [];\n\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._move(dtMilliseconds, currentRoad);\n\n    const pal = this._getPal();\n    pal\n      .getComponent(PalAbsoluteController)\n      .setPosition(\n        this.position,\n        currentRoad.getAngleAtPosition(this._positionOnCurrentRoad),\n        dtMilliseconds / 1000,\n      );\n    pal.update(dtMilliseconds);\n\n    this._getEnterTransitionScale();\n    // if (window.debugDraw) this._debugDraw();\n\n    this._checkAtEndOfRoad(currentRoad);\n    this._checkExit();\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number) {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._getPal().draw(ctx, elapsedTime);\n\n    // const position = this.position;\n    // const scale =\n    //   this._getEnterTransitionScale() * this._getExitTransitionScale();\n\n    // ctx.beginPath();\n    // ctx.fillStyle = TRAVELLER_COLOR.toString();\n    // ShapeHelpers.circle(ctx, position.x, position.y, TRAVELLER_RADIUS * scale);\n    // ctx.fill();\n  }\n\n  getSortOrder(): number {\n    return this.position.y;\n  }\n\n  get _isExiting(): boolean {\n    return this._exitStartedAt !== null;\n  }\n\n  _getPal(): Entity {\n    if (!this._pal) {\n      this._pal = makeAbsolutePal(this.position);\n    }\n\n    return this._pal;\n  }\n\n  // _debugDraw() {\n  //   const currentRoad = this._currentRoad;\n  //   if (!currentRoad) return;\n\n  //   const predictedStopPoint = this.predictedStopPoint;\n  //   Circle.create(\n  //     this.position.x,\n  //     this.position.y,\n  //     this.comfortableRadius\n  //   ).debugDraw(\"rgba(0, 255, 0, 0.4)\");\n  //   Circle.create(this.position.x, this.position.y, this.safeRadius).debugDraw(\n  //     this._forceAccelerateTimer ? \"cyan\" : \"red\"\n  //   );\n  //   predictedStopPoint.debugDraw(\"lime\");\n  //   this.predictedStopArea.debugDraw(\"rgba(255, 0, 255, 0.5)\");\n\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.fillText(\n  //     `${this.id} ${Math.round(this._stoppedTime)}`,\n  //     this.position.x,\n  //     this.position.y\n  //   );\n  // }\n\n  _getEnterTransitionScale() {\n    return enterEase(\n      constrain(0, 1, mapRange(0, ENTER_DURATION, 0, 1, this._age)),\n    );\n  }\n\n  _getExitTransitionScale() {\n    if (this._exitStartedAt === null) return 1;\n    return (\n      1 -\n      exitEase(\n        constrain(\n          0,\n          1,\n          mapRange(\n            this._exitStartedAt,\n            this._exitStartedAt + EXIT_DURATION,\n            0,\n            1,\n            this._age,\n          ),\n        ),\n      )\n    );\n  }\n\n  _getPredictedStopPositionIfDecelerating(): number {\n    const timeToStop = -this._speed / DECELERATION;\n    return (\n      this._positionOnCurrentRoad +\n      this._speed * timeToStop +\n      0.5 * DECELERATION * timeToStop * timeToStop\n    );\n  }\n\n  _getPredictedPointForPosition(currentRoad: Road, position: number): Vector2 {\n    if (position <= currentRoad.length) {\n      return currentRoad.getPointAtPosition(position);\n    }\n\n    const overshoot = position - currentRoad.length;\n    const overshootAngle = currentRoad.getAngleAtPosition(currentRoad.length);\n    return Vector2.fromPolar(overshootAngle, overshoot).add(currentRoad.end);\n  }\n\n  _pickDestination() {\n    if (!this._currentRoad) return;\n    const potentialDestinations = this._currentRoad\n      .getAllReachableNodes()\n      .filter((node) => node.isDestination);\n    const destination = sample(potentialDestinations);\n    this._destination = destination;\n  }\n\n  _move(dtMilliseconds: number, currentRoad: Road) {\n    const dtSeconds = dtMilliseconds / 1000;\n\n    this._forceAccelerateTimer = constrain(\n      0,\n      FORCE_ACCELERATE_DURATION,\n      this._forceAccelerateTimer - dtMilliseconds,\n    );\n\n    if (\n      this._forceAccelerateTimer <= 0 &&\n      this._shouldDecelerate(currentRoad)\n    ) {\n      this._accelerate(DECELERATION, dtSeconds, currentRoad);\n    } else {\n      this._accelerate(ACCELERATION, dtSeconds, currentRoad);\n    }\n\n    if (this._speed === 0) {\n      this._stoppedTime += dtMilliseconds;\n    } else {\n      this._stoppedTime = 0;\n    }\n  }\n\n  _shouldDecelerate(currentRoad: Road): boolean {\n    const predictedStopPosition =\n      this._getPredictedStopPositionIfDecelerating();\n    if (\n      currentRoad.to === this._destination &&\n      currentRoad.length + ROAD_END_OVERSHOOT < predictedStopPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_DESTINATION;\n      return true;\n    }\n\n    const nextTravellerOnRoad = currentRoad.getTravellerAfterPosition(\n      this._positionOnCurrentRoad,\n    );\n\n    const safeStopAheadPosition =\n      predictedStopPosition + this.comfortableRadius;\n\n    if (\n      nextTravellerOnRoad &&\n      nextTravellerOnRoad.positionOnCurrentRoad < safeStopAheadPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n      this._stoppedFor.push(nextTravellerOnRoad);\n      return true;\n    }\n\n    if (currentRoad.to instanceof Intersection) {\n      const intersection = currentRoad.to;\n      const outgoingTraveller = intersection.getClosestOutgoingTraveller();\n      if (outgoingTraveller) {\n        const outgoingTravellerPosition =\n          currentRoad.length + outgoingTraveller.positionOnCurrentRoad;\n\n        if (outgoingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(outgoingTraveller);\n          return true;\n        }\n      }\n\n      const incomingTraveller = intersection.getClosestIncomingTraveller();\n      if (incomingTraveller && incomingTraveller !== this) {\n        const incomingTravellerPosition =\n          currentRoad.length - incomingTraveller.distanceToEndOfCurrentRoad;\n        if (incomingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(incomingTraveller);\n          return true;\n        }\n      }\n    }\n\n    if (this._shouldDecelerateForNearbyTravellers(currentRoad)) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_NEARBY;\n      return true;\n    }\n\n    // const currentPoint = this.position;\n    // const currentSafeCircle = Circle.create(\n    //   currentPoint.x,\n    //   currentPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     currentSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    // const predictedStopPoint = this._getPredictedStopPointIfDecelerating(\n    //   currentRoad,\n    // );\n    // const predictedSafeCircle = Circle.create(\n    //   predictedStopPoint.x,\n    //   predictedStopPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     predictedSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    return false;\n  }\n\n  _shouldDecelerateForNearbyTravellers(currentRoad: Road): boolean {\n    const travellerFinder = this.getScene().getSystem(TravellerFinder);\n    const stopArea = this.predictedStopArea;\n    const stopPoint = stopArea.center;\n    const nextStopPoint = this.potentialNextPredictedStopPoint;\n    const searchArea = stopArea.withRadius(NEARBY_RADIUS);\n    const nearbyTravellers = travellerFinder.findTravellersInCircle(searchArea);\n\n    for (const other of nearbyTravellers) {\n      // cannot crash into self\n      if (other === this) continue;\n\n      // if we both started breaking now, we would be a safe distance so we're fine\n      const otherStopArea = other.predictedStopArea;\n      const otherStopPoint = otherStopArea.center;\n      if (!stopArea.intersectsCircle(otherStopArea)) continue;\n\n      // currently we think other will stop at the center of otherStopArea.\n      // otherNextStopPoint is one pixel further forward based other's current\n      // heading\n      const otherNextStopPoint = other.potentialNextPredictedStopPoint;\n\n      // if we're moving away from each other, everything is fine:\n      const currentStopDistance = stopPoint.distanceTo(otherStopArea.center);\n      const nextStopDistance = nextStopPoint.distanceTo(otherNextStopPoint);\n      if (nextStopDistance > currentStopDistance) continue;\n\n      // who is moving in a direction that's headed more towards the other's\n      // stop position? if they're moving towards me but i'm moving more\n      // orthagonally relative to them, they should slow down\n      const approachAmount = stopPoint.distanceTo(otherNextStopPoint);\n      const otherApproachAmount = otherStopPoint.distanceTo(nextStopPoint);\n      if (approachAmount < otherApproachAmount) {\n        continue;\n      }\n\n      // so we know we're moving towards them faster than they're moving\n      // towards us, but how much? If it's barely any and we're not already too\n      // close to them, we could just keep going\n      if (\n        approachAmount - otherApproachAmount <\n        0.15\n        // approachAmount > this.safeRadius * 0.8\n      ) {\n        continue;\n      }\n\n      // if there's a clash... just randomly tie-break\n      if (approachAmount === otherApproachAmount) {\n        return Math.random() < 0.5;\n      }\n\n      // if we've been waiting around for fuckin ever just slam that fuckin\n      // pedal to the floor like ugh (in reality just nudge forward a little)\n      // (unless the other one is stopped to cus otherwise we'll just crash)\n      if (this._stoppedTime > PATIENCE && !other.isStopped) {\n        this._forceAcceleration();\n        return false;\n      }\n\n      // attempt to break deadlocks. i guess this is the equivalent of 'other'\n      // waving at the current traveller to continue\n      if (other.isStoppedFor(this)) continue;\n\n      this._stoppedFor.push(other);\n    }\n\n    if (this._stoppedFor.length) return true;\n\n    return false;\n  }\n\n  // _shouldDecelerateForTravellersInCircle(currentRoad: Road, circle: Circle) {\n  //   const travellerFinder = this.getScene().getSystem(TravellerFinder);\n  //   const overlappingTravellers = travellerFinder.findTravellersInCircle(\n  //     circle,\n  //   );\n\n  //   const currentPosition = this.position;\n  //   const nextPosition = this.predictedPositionInDirectionOfTravel;\n\n  //   const clashingTravellers = overlappingTravellers.filter(other => {\n  //     if (other === this) return false;\n  //     if (other.currentRoad === currentRoad) return false;\n\n  // const currentDistance = currentPosition.distanceTo(other.position);\n  // const nextDistance = nextPosition.distanceTo(other.position);\n\n  // const isGettingCloser = nextDistance < currentDistance;\n  // if (!isGettingCloser) return false;\n\n  // const otherNextPosition = other.predictedPositionInDirectionOfTravel;\n  // const otherNextDistance = currentPosition.distanceTo(otherNextPosition);\n  // const thisMoveDelta = nextDistance - currentDistance;\n  // const otherMoveDelta = otherNextDistance - currentDistance;\n  // if (thisMoveDelta < otherMoveDelta) return true;\n\n  // if (this.isStopped && !other.isStopped) return true;\n\n  // if (this.isStopped && other.isStopped) {\n  //   if (this.stoppedTime === other.stoppedTime && this.id < other.id)\n  //     return false;\n  //   if (this.stoppedTime < other.stoppedTime) return false;\n  // }\n\n  //     return true;\n  //   });\n\n  //   return clashingTravellers.length > 0;\n  // }\n\n  _forceAcceleration() {\n    this._forceAccelerateTimer = FORCE_ACCELERATE_DURATION;\n  }\n\n  _accelerate(acceleration: number, dtSeconds: number, currentRoad: Road) {\n    const lastSpeed = this._speed;\n    this._speed = constrain(\n      0,\n      MAX_SPEED,\n      this._speed + acceleration * dtSeconds,\n    );\n    const avgSpeed = (lastSpeed + this._speed) / 2;\n    this._positionOnCurrentRoad = constrain(\n      0,\n      currentRoad.length,\n      this._positionOnCurrentRoad + avgSpeed * dtSeconds,\n    );\n  }\n\n  _checkAtEndOfRoad(currentRoad: Road) {\n    if (this._positionOnCurrentRoad === currentRoad.length) {\n      if (this._isExiting) return;\n      this._onReachEndOfCurrentRoad(currentRoad);\n    }\n  }\n\n  _checkExit() {\n    if (this._isExiting) {\n      assert(this._exitStartedAt);\n      if (this._age >= this._exitStartedAt + EXIT_DURATION) {\n        this._onExit();\n      }\n    }\n  }\n\n  _onReachEndOfCurrentRoad(currentRoad: Road) {\n    const nextNode = currentRoad.to;\n    const destination = this._destination;\n    if (nextNode.canConsumeTraveller) {\n      nextNode.consumeTraveller(this);\n      if (nextNode === destination) {\n        this._onReachDestination();\n      }\n    }\n  }\n\n  _onReachDestination() {\n    this._exit();\n  }\n\n  _onExit() {\n    this.getScene().removeChild(this);\n  }\n\n  _exit() {\n    this._exitStartedAt = this._age;\n  }\n}\n","import Entity from '../lib/scene/Entity';\nimport { PalTargetController, PalAbsoluteController } from './PalController';\nimport Vector2 from '../lib/geom/Vector2';\nimport { generateRandomPalConfig } from './PalConfig';\nimport PalGeom from './PalGeom';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport PalRenderer from './PalRenderer';\n\nexport function makeTargetPal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalTargetController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n\nexport function makeAbsolutePal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalAbsoluteController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n","// @flow\nimport { assert } from '../assert';\nimport { constrain, compact } from '../utils';\nimport Circle from './Circle';\nimport Vector2 from './Vector2';\nimport StraightPathSegment from './StraightPathSegment';\nimport CirclePathSegment from './CirclePathSegment';\nimport Line2 from './Line2';\n\nexport interface PathSegment {\n  getStart(): Vector2;\n  getEnd(): Vector2;\n  getLength(): number;\n  getPointAtPosition(position: number): Vector2;\n  getAngleAtPosition(position: number): number;\n}\n\nexport default class Path implements PathSegment {\n  static straightThroughPoints(...points: ReadonlyArray<Vector2>): Path {\n    let [lastPoint, ...remainingPoints] = points;\n    const path = new Path();\n\n    for (const point of remainingPoints) {\n      path.addSegment(new StraightPathSegment(lastPoint, point));\n      lastPoint = point;\n    }\n\n    return path;\n  }\n\n  static segmentAcrossCircle(\n    containingCircle: Circle,\n    entryAngle: number,\n    exitAngle: number,\n  ): CirclePathSegment | StraightPathSegment {\n    entryAngle = entryAngle + Math.PI;\n    const entryPoint = containingCircle.pointOnCircumference(entryAngle);\n    const exitPoint = containingCircle.pointOnCircumference(exitAngle);\n\n    const entryLineNormal = new Line2(\n      containingCircle.center,\n      entryPoint,\n    ).perpendicularLineThroughPoint(entryPoint);\n    const exitLineNormal = new Line2(\n      containingCircle.center,\n      exitPoint,\n    ).perpendicularLineThroughPoint(exitPoint);\n\n    if (entryLineNormal.isParallelTo(exitLineNormal)) {\n      return new StraightPathSegment(entryPoint, exitPoint);\n    }\n\n    const roadCircleCenter =\n      entryLineNormal.pointAtIntersectionWith(exitLineNormal);\n    const roadCircleRadius = entryPoint.distanceTo(roadCircleCenter);\n\n    // containingCircle.center.debugDraw('lime');\n    // roadCircleCenter.debugDraw('blue');\n    // entryPoint.debugDraw('magenta');\n    // exitPoint.debugDraw('red');\n\n    return new CirclePathSegment(\n      roadCircleCenter,\n      roadCircleRadius,\n      entryPoint.sub(roadCircleCenter).angle,\n      exitPoint.sub(roadCircleCenter).angle,\n    );\n  }\n\n  segments: PathSegment[] = [];\n\n  constructor(...segments: PathSegment[]) {\n    this.addSegments(...segments);\n  }\n\n  getStart(): Vector2 {\n    return this.segments[0].getStart();\n  }\n\n  getEnd(): Vector2 {\n    return this.segments[this.segments.length - 1].getEnd();\n  }\n\n  getLength(): number {\n    return this.segments.reduce(\n      (length, segment) => length + segment.getLength(),\n      0,\n    );\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getPointAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  getAngleAtPosition(position: number): number {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getAngleAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  addSegment(segment: PathSegment): this {\n    const lastSegment = this.segments[this.segments.length - 1];\n    if (lastSegment) {\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        `segments must neatly join together - ${lastSegment\n          .getEnd()\n          .toString()} !== ${segment.getStart().toString()}`,\n      );\n    }\n    this.segments.push(segment);\n    return this;\n  }\n\n  addSegments(...segments: PathSegment[]): this {\n    segments.forEach((segment) => this.addSegment(segment));\n    return this;\n  }\n\n  autoRound(radius: number): this {\n    const newSegments = this.segments.map((segment, i): PathSegment | null => {\n      const lastSegment = i === 0 ? null : this.segments[i - 1];\n      if (!lastSegment) {\n        if (segment instanceof StraightPathSegment) return null;\n        return segment;\n      }\n\n      if (!(segment instanceof StraightPathSegment)) return segment;\n      if (!(lastSegment instanceof StraightPathSegment)) return null;\n\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        'segments must join',\n      );\n\n      const entryAngle = lastSegment.angle;\n      const exitAngle = segment.angle;\n      const usableRadius = Math.min(\n        radius,\n        lastSegment.getLength() / 2,\n        segment.getLength() / 2,\n      );\n\n      const containingCircle = Circle.create(\n        segment.getStart().x,\n        segment.getStart().y,\n        usableRadius,\n      );\n\n      return Path.segmentAcrossCircle(containingCircle, entryAngle, exitAngle);\n    });\n\n    const compacted = compact(newSegments);\n\n    const start = this.getStart();\n    const end = this.getEnd();\n    let lastPoint = start;\n    this.segments = [];\n\n    compacted.forEach((segment) => {\n      if (segment.getStart().equals(lastPoint)) {\n        this.addSegment(segment);\n      } else {\n        this.addSegment(new StraightPathSegment(lastPoint, segment.getStart()));\n        this.addSegment(segment);\n      }\n\n      lastPoint = segment.getEnd();\n    });\n\n    if (!lastPoint.equals(end)) {\n      this.addSegment(new StraightPathSegment(lastPoint, end));\n    }\n\n    return this;\n  }\n}\n","// @flow\nimport { compact } from '../lib/utils';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Scene from '../lib/scene/Scene';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\nimport Path from '../lib/geom/Path';\nimport Road from './Road';\nimport Intersection from './networkNodes/Intersection';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class Junction extends SceneObject {\n  _circle: Circle;\n  _intersectionsByAngle: { [angleString: string]: Intersection } = {};\n  _incomingIntersections: Set<Intersection> = new Set();\n  _outgoingIntersections: Set<Intersection> = new Set();\n  _roads: Road[] = [];\n\n  constructor(x: number, y: number, radius: number) {\n    super();\n    this._circle = Circle.create(x, y, radius);\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    this._roads.forEach((road) => scene.addChild(road));\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._circle.pointOnCircumference(radians);\n  }\n\n  connectToRoadAtAngle(\n    road: Road,\n    angle: number,\n    direction: ConnectionDirection,\n  ): Intersection {\n    const intersection = this._intersectionAtAngle(angle);\n    intersection.connectTo(road, direction);\n\n    const isIncoming =\n      direction === ConnectionDirection.IN ||\n      this._incomingIntersections.has(intersection);\n\n    const isOutgoing =\n      direction === ConnectionDirection.OUT ||\n      this._outgoingIntersections.has(intersection);\n\n    if (isIncoming) this._incomingIntersections.add(intersection);\n    if (isOutgoing) this._outgoingIntersections.add(intersection);\n\n    this._intersections.forEach((other) => {\n      if (other === intersection) return;\n\n      if (isIncoming && this._outgoingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(intersection.position).angle,\n            other.position.sub(this._circle.center).angle,\n          ),\n        );\n\n        this._addRoad(new Road(intersection, other, { path }));\n      }\n\n      if (isOutgoing && this._incomingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(other.position).angle,\n            intersection.position.sub(this._circle.center).angle,\n          ),\n        );\n        this._addRoad(new Road(other, intersection, { path }));\n      }\n    });\n\n    return intersection;\n  }\n\n  _intersectionAtAngle(angle: number): Intersection {\n    const angleStr = angle.toString();\n    if (this._intersectionsByAngle[angleStr]) {\n      return this._intersectionsByAngle[angleStr];\n    }\n\n    const intersection = this._createIntersectionAtAngle(angle);\n    this._intersectionsByAngle[angleStr] = intersection;\n    return intersection;\n  }\n\n  _createIntersectionAtAngle(angle: number): Intersection {\n    const position = this.getVisualConnectionPointAtAngle(angle);\n    return new Intersection(position.x, position.y);\n  }\n\n  get _intersections(): Intersection[] {\n    return compact(\n      Object.keys(this._intersectionsByAngle).map(\n        (angle) => this._intersectionsByAngle[angle],\n      ),\n    );\n  }\n\n  _addRoad(road: Road) {\n    this._roads.push(road);\n    if (this.hasScene()) {\n      this.getScene().addChild(road);\n    }\n  }\n}\n","// @flow\nimport SceneObject from '../lib/scene/SceneObject';\nimport Path from '../lib/geom/Path';\nimport StraightPathSegment from '../lib/geom/StraightPathSegment';\nimport Vector2 from '../lib/geom/Vector2';\nimport * as ShapeHelpers from '../lib/canvasShapeHelpers';\nimport { YELLOW } from './colors';\nimport ConnectionDirection from './ConnectionDirection';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Junction from './Junction';\nimport Traveller from './Traveller';\n\n// const ROAD_OUTER_COLOR = BLUE;\n// const ROAD_INNER_COLOR = LIGHT_BG;\nconst ROAD_DASH_COLOR = YELLOW.darken(0.2);\n// const ROAD_OUTER_WIDTH = 12;\n// const ROAD_INNER_WIDTH = 13;\nconst ROAD_DASH_WIDTH = 3;\nconst ROAD_IDEAL_DASH = [5, 10];\nconst ROAD_IDEAL_DASH_LENGTH = ROAD_IDEAL_DASH.reduce((a, b) => a + b, 0);\nconst ROAD_DASH_SPEED = 0.05;\n\nexport type RoadOptions = {\n  autoRound?: number;\n  points?: Array<Vector2>;\n  path?: Path;\n};\n\nexport default class Road extends SceneObject {\n  isNode = false;\n  from: NetworkNode;\n  to: NetworkNode;\n  _path: Path;\n  _currentTravellers: Traveller[] = [];\n\n  constructor(\n    from: NetworkNode | Junction,\n    to: NetworkNode | Junction,\n    { points, autoRound, path }: RoadOptions = {},\n  ) {\n    super();\n\n    const angleFrom = points\n      ? from.position.angleTo(points[0])\n      : from.position.angleTo(to.position);\n\n    const angleTo = points\n      ? to.position.angleTo(points[points.length - 1])\n      : to.position.angleTo(from.position);\n\n    if (path) {\n      this._path = path;\n    } else if (points) {\n      this._path = Path.straightThroughPoints(\n        from.getVisualConnectionPointAtAngle(angleFrom),\n        ...points,\n        to.getVisualConnectionPointAtAngle(angleTo),\n      );\n    } else {\n      this._path = new Path().addSegment(\n        new StraightPathSegment(\n          from.getVisualConnectionPointAtAngle(angleFrom),\n          to.getVisualConnectionPointAtAngle(angleTo),\n        ),\n      );\n    }\n\n    if (autoRound != null) {\n      this._path.autoRound(autoRound);\n    }\n\n    if (from instanceof Junction) {\n      this.from = from.connectToRoadAtAngle(\n        this,\n        angleFrom,\n        ConnectionDirection.OUT,\n      );\n    } else {\n      this.from = from;\n      from.connectTo(this, ConnectionDirection.OUT);\n    }\n\n    if (to instanceof Junction) {\n      this.to = to.connectToRoadAtAngle(this, angleTo, ConnectionDirection.IN);\n    } else {\n      this.to = to;\n      to.connectTo(this, ConnectionDirection.IN);\n    }\n  }\n\n  get length(): number {\n    return this._path.getLength();\n  }\n\n  get start(): Vector2 {\n    return this._path.getStart();\n  }\n\n  get end(): Vector2 {\n    return this._path.getEnd();\n  }\n\n  get expectedTimeFromStartToEnd(): number {\n    if (this._currentTravellers.length) {\n      const avgSpeed =\n        this._currentTravellers.reduce(\n          (sum, traveller) => sum + traveller.speed,\n          0,\n        ) / this._currentTravellers.length;\n      return this.length / avgSpeed;\n    }\n\n    return this.length / (Traveller.MAX_SPEED * 0.7);\n  }\n\n  canAddTravellerAtStart(): boolean {\n    const nextTraveller = this.getTravellerAfterPosition(0);\n    if (!nextTraveller) return true;\n    return (\n      nextTraveller.positionOnCurrentRoad > nextTraveller.comfortableRadius\n    );\n  }\n\n  addTravellerAtStart(traveller: Traveller) {\n    this._currentTravellers.push(traveller);\n    traveller.onAddedToRoad(this);\n  }\n\n  removeTraveller(traveller: Traveller): boolean {\n    const index = this._currentTravellers.indexOf(traveller);\n    if (index === -1) return false;\n    this.removeTravellerAtIndex(index);\n    return true;\n  }\n\n  removeTravellerAtIndex(index: number): Traveller {\n    const traveller = this._currentTravellers[index];\n    this._currentTravellers.splice(index, 1);\n    traveller.onRemovedFromRoad();\n    return traveller;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    const nodes = [] as Array<NetworkNode>;\n    if (visited.has(this.to)) return nodes;\n    return [...this.to.getAllReachableNodes(visited), this.to];\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    return this._path.getPointAtPosition(position);\n  }\n\n  getAngleAtPosition(position: number): number {\n    return this._path.getAngleAtPosition(position);\n  }\n\n  getTravellerAfterPosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = traveller.positionOnCurrentRoad - position;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getTravellerBeforePosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = position - traveller.positionOnCurrentRoad;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, time: number) {\n    ctx.beginPath();\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ShapeHelpers.path(ctx, this._path);\n\n    // ctx.strokeStyle = ROAD_OUTER_COLOR.toString();\n    // ctx.lineWidth = ROAD_OUTER_WIDTH;\n    // ctx.stroke();\n\n    // ctx.strokeStyle = ROAD_INNER_COLOR.toString();\n    // ctx.lineWidth = ROAD_INNER_WIDTH;\n    // ctx.stroke();\n\n    const dashScale = this._getLineDashScale();\n    const dashLength = ROAD_IDEAL_DASH_LENGTH * dashScale;\n    ctx.setLineDash(ROAD_IDEAL_DASH.map(length => length * dashScale));\n    ctx.strokeStyle = ROAD_DASH_COLOR.toString();\n    ctx.lineDashOffset = (-time * ROAD_DASH_SPEED * dashScale) % dashLength;\n    ctx.lineWidth = ROAD_DASH_WIDTH;\n    // ctx.strokeStyle = 'black';\n    // ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  _getLineDashScale(): number {\n    const wholeDashCount = Math.floor(this.length / ROAD_IDEAL_DASH_LENGTH);\n    const wholeDashLength = wholeDashCount * ROAD_IDEAL_DASH_LENGTH;\n\n    const roundDownLength = this.length - wholeDashLength;\n    const roundUpLength =\n      wholeDashLength + ROAD_IDEAL_DASH_LENGTH - this.length;\n\n    const dashScale =\n      roundDownLength < roundUpLength\n        ? this.length / wholeDashLength\n        : this.length / (wholeDashLength + ROAD_IDEAL_DASH_LENGTH);\n\n    return dashScale;\n  }\n}\n","// @flow\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { outSine } from '../../lib/easings';\nimport { mapRange, constrain, flatten, uniq } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { TEAL } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Traveller from '../Traveller';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 500;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst CLOCK_RADIUS = RADIUS * 0.7;\nconst PULSE_RADIUS = 35;\n\nconst PULSE_DURATION = 500;\nconst CLOCK_FADE_DURATION = 150;\n\nconst MAIN_COLOR = TEAL.lighten(0.1);\nconst CLOCK_COLOR = TEAL.darken(0.1);\nconst PULSE_COLOR = TEAL.lighten(0.2).fade(0.1);\n\nexport default class Producer extends SceneObject implements NetworkNode {\n  isDestination = false;\n  canConsumeTraveller = false;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = Circle.create(x, y, RADIUS);\n    this._visualConnectionCircle = Circle.create(\n      x,\n      y,\n      VISUAL_CONNECTION_RADIUS,\n    );\n    this._cooldown = cooldown;\n    this._timer = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()) {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map((road) =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  consumeTraveller() {\n    throw new Error('producer cannot consume traveller');\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n    if (this._timer >= this._cooldown) {\n      this._onTimerEnd();\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ctx.arc(\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n      -Math.PI / 2,\n      progress * 2 * Math.PI - Math.PI / 2,\n      false,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = MAIN_COLOR.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      CLOCK_RADIUS,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _onTimerEnd() {\n    const didEmitTraveller = this._attemptEmitTraveller();\n    if (didEmitTraveller) {\n      this._pulse();\n      this._resetTimer();\n    }\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        startRadius: RADIUS,\n        endRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: outSine,\n        removeOnComplete: true,\n      }),\n    );\n  }\n\n  _attemptEmitTraveller(): boolean {\n    const road = this._connectionSet.sampleOutgoing();\n    if (!(road instanceof Road)) return false;\n\n    if (road.canAddTravellerAtStart()) {\n      const traveller = new Traveller();\n      road.addTravellerAtStart(traveller);\n      this.getScene().addChild(traveller);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Scene from '../lib/scene/Scene';\nimport Consumer from './networkNodes/Consumer';\nimport Producer from './networkNodes/Producer';\nimport Road from './Road';\nimport Junction from './Junction';\n// import DebugOverlay from \"./systems/DebugOverlay\";\nimport TravellerFinder from './TravellerFinder';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst ROUND = 50;\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nconst root = document.getElementById('root');\nassert(root, '#root must be present');\nscene.appendTo(root);\n\n// scene.addSystem(new DebugOverlay());\nscene.addSystem(new TravellerFinder());\n\nscenario3();\n\nscene.start();\n\nfunction scenario1() {\n  const producer1 = new Producer(100, 100, 500);\n  // const producer2 = new Consumer(100, 300, 2500);\n  const consumer1 = new Consumer(400, 200, 1500);\n  const consumer2 = new Consumer(250, 200, 1500);\n  scene.addChild(producer1);\n  // scene.addChild(producer2);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n\n  const junction1 = new Junction(250, 100, ROUND);\n  scene.addChild(junction1);\n  scene.addChild(new Road(producer1, junction1));\n  scene.addChild(\n    new Road(junction1, consumer1, {\n      points: [new Vector2(400, 100)],\n      autoRound: ROUND,\n    }),\n  );\n  scene.addChild(new Road(junction1, consumer2));\n\n  // const path2 = new Path();\n  // path2.addSegments(\n  //   new StraightPathSegment(new Vector2(130, 300), new Vector2(380, 300)),\n  //   new CirclePathSegment(new Vector2(380, 280), 20, Math.PI * 0.5, 0),\n  //   new StraightPathSegment(new Vector2(400, 280), new Vector2(400, 230)),\n  // );\n  // const road2 = new Road(producer2, consumer1, path2);\n  // scene.addChild(road2);\n}\n\nfunction scenario2() {\n  const producer = new Producer(100, 300, 500);\n  const junction = new Junction(300, 300, ROUND);\n  const consumer1 = new Consumer(300, 100, 5000);\n  const consumer2 = new Consumer(500, 300, 5000);\n  const consumer3 = new Consumer(300, 500, 5000);\n\n  scene.addChild(new Road(producer, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  scene.addChild(producer);\n  scene.addChild(junction);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n}\n\nfunction scenario3() {\n  const northConsumer = new Consumer(300, 550, 1500);\n  const middleConsumer = new Consumer(100, 450, 1500);\n  const southConsumer = new Consumer(100, 250, 1500);\n  const eastProducer = new Producer(600, 150, 500);\n  const westProducer = new Producer(100, 100, 500);\n  // const westProducer = new Producer(250, 250, 100);\n\n  scene.addChild(northConsumer);\n  scene.addChild(middleConsumer);\n  scene.addChild(southConsumer);\n  scene.addChild(eastProducer);\n  scene.addChild(westProducer);\n\n  const mainJunction = new Junction(300, 150, ROUND);\n  const eastProducerSplit = new Junction(500, 370, ROUND);\n  const southConsumerJoin = new Junction(330, 400, ROUND);\n  scene.addChild(mainJunction);\n  scene.addChild(eastProducerSplit);\n  scene.addChild(southConsumerJoin);\n  scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(eastProducer, eastProducerSplit));\n  scene.addChild(new Road(eastProducerSplit, southConsumerJoin));\n  // scene.addChild(\n  //   new Road(eastProducerSplit, mainJunction, {\n  //     points: [[600, 280], [700, 50], [450, 180], [450, 100], [300, 20]],\n  //     // points: [[400, 100]],\n  //     autoRound: 50,\n  //   }),\n  // );\n  scene.addChild(\n    new Road(eastProducerSplit, mainJunction, {\n      points: [new Vector2(400, 300), new Vector2(500, 50)],\n      autoRound: ROUND,\n    }),\n  );\n\n  // scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(mainJunction, southConsumerJoin));\n  scene.addChild(new Road(southConsumerJoin, northConsumer));\n  scene.addChild(new Road(mainJunction, middleConsumer));\n  scene.addChild(new Road(mainJunction, southConsumer));\n}\n\nfunction scenario4() {\n  const producer1 = new Producer(100, 100, 1000);\n  const producer2 = new Producer(300, 200, 1000);\n  const producer3 = new Producer(100, 300, 1000);\n  // const producer4 = new Producer(400, 100, 1000);\n  const consumer1 = new Consumer(300, 100, 1000);\n  const consumer2 = new Consumer(100, 200, 1000);\n  const consumer3 = new Consumer(300, 300, 1000);\n  // const consumer4 = new Consumer(430, 300, 1000);\n  scene.addChild(producer1);\n  scene.addChild(producer2);\n  scene.addChild(producer3);\n  // scene.addChild(producer4);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n  // scene.addChild(consumer4);\n\n  const junction = new Junction(200, 200, 30);\n  scene.addChild(junction);\n\n  scene.addChild(new Road(producer1, junction));\n  scene.addChild(new Road(producer2, junction));\n  scene.addChild(new Road(producer3, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  // scene.addChild(\n  //   new Road(producer4, consumer4, {\n  //     points: [[400, 250], [415, 250], [415, 150], [430, 150]],\n  //     autoRound: 30,\n  //   }),\n  // );\n}\n\nfunction scenario6() {\n  const producer = new Producer(300, 50, 1500).addTo(scene);\n  const consumer = new Consumer(500, 50, 100).addTo(scene);\n  new Road(producer, consumer, {\n    points: [\n      new Vector2(350, 150),\n      new Vector2(150, 350),\n      new Vector2(400, 500),\n      new Vector2(650, 350),\n      new Vector2(450, 150),\n    ],\n    autoRound: 400,\n  }).addTo(scene);\n}\n"],"names":["$37d63ae0c3ce19a6$var$UnitBezier","x1","y1","x2","y2","cx","bx","cy","by","this","ax","ay","key","t","x","epsilon","i","NEWTON_METHOD_ITERATIONS","sampleCurveX","$8qLe2","approxEq","dx","sampleCurveDerivativeX","lo","hi","x21","param","DEFAULT_EPSILON","sampleCurveY","solveCurveX","ConnectionDirection","$37d63ae0c3ce19a6$export$45db2fc2f15997e7","n","$37d63ae0c3ce19a6$export$cef097a6f35c9b6a","Math","sin","PI","$37d63ae0c3ce19a6$export$e38aa6d936f277b2","s","$9ea787a7a9ba434c$export$2e2bcd8739ae039","SceneObject","y","startRadius","endRadius","duration","color","_easeRadius","easeRadius","_easeOpacity","easeOpacity","_removeOnComplete","removeOnComplete","call","_circle","$eJCSX","default","create","_startRadius","_endRadius","_duration","_color","_progress","deltaTime","deltaProgress","min","withRadius","lerp","getScene","removeChild","ctx","beginPath","opacity","fillStyle","fade","toString","$6IKqx","circle","center","radius","fill","$dXT6b","$d9323e005b938a8f$export$d0446fe88325854e","$parcel$interopDefault","$9AT65","$d9323e005b938a8f$export$aa201224bb439d47","$d9323e005b938a8f$export$aab610c505c06a8f","$ce41d102a41122d3$var$ConnectionDirection","$ce41d102a41122d3$export$2e2bcd8739ae039","$014487839abcbcbb$export$2e2bcd8739ae039","incoming","outgoing","target","direction","IN","addIncoming","OUT","addOutgoing","Error","concat","push","sample","$68300a675eb0d504$var$MAIN_COLOR","lighten","desaturate","$68300a675eb0d504$var$CLOCK_COLOR","darken","$68300a675eb0d504$var$PULSE_COLOR","$68300a675eb0d504$export$2e2bcd8739ae039","cooldown","isDestination","_timer","_connectionSet","_visualConnectionCircle","_cooldown","radians","pointOnCircumference","Set","add","node","$8OvEy","assert","canConsumeTraveller","_resetTimer","_pulse","delta","constrain","progress","colorMixAmount","mapRange","bgColor","mix","moveTo","easing","addChildBefore","$e9fa0217768ee50a$var$DEFAULT_NAME","$e9fa0217768ee50a$export$2e2bcd8739ae039","scene","constructor","systemName","time","$b82541a56e38f541$export$2e2bcd8739ae039","SceneSystem","apply","arguments","traveller","_quadTree","remove","prototype","$2cCmU","$71uov","fromLeftTopRightBottom","width","height","position","clear","children","forEach","child","$6bf17d2e2f71bf75$export$2e2bcd8739ae039","_this","insert","findItemsInCircle","$4fe36a3cb4d10b6c$var$PathFinder","getNextRoad","initialNode","destinationNode","remainingNodes","getAllReachableNodes","has","bestCosts","Map","prevRoads","set","size","ref","_nodeWithShortestDistance","cost","delete","_nextRoadFromRoute","_updateNeighbours","nodes","costs","bestCost","Infinity","bestNode","get","outgoingConnections","road","nextNode","to","nextNodeCost","altNextNodeCost","expectedTimeFromStartToEnd","start","finish","from","$4fe36a3cb4d10b6c$export$2e2bcd8739ae039","$146304cebc86f814$export$2e2bcd8739ae039","$39Hjj","destination","nextRoad","includes","removeFromCurrentRoad","addTravellerAtStart","visited","uniq","flatten","map","bestTraveller","shortestDistance","getTravellerAfterPosition","positionOnCurrentRoad","incomingConnections","getTravellerBeforePosition","length","distanceToEndOfCurrentRoad","StopReason","$6bf17d2e2f71bf75$var$DECELERATION","$6bf17d2e2f71bf75$var$enterEase","$6bf17d2e2f71bf75$var$exitEase","$6bf17d2e2f71bf75$var$StopReason","comfortableRadius","random","safeRadius","_currentRoad","_destination","_positionOnCurrentRoad","_speed","_age","_exitStartedAt","_stoppedTime","_forceAccelerateTimer","_stopReason","_stoppedFor","_pal","getPointAtPosition","currentRoad","stopPosition","_getPredictedStopPositionIfDecelerating","_getPredictedPointForPosition","predictedStopPoint","speed","other","_pickDestination","getSystem","removeTraveller","dtMilliseconds","_move","pal","_getPal","getComponent","$1js6q","PalAbsoluteController","setPosition","getAngleAtPosition","update","_getEnterTransitionScale","_checkAtEndOfRoad","_checkExit","elapsedTime","draw","$bADSp","addComponent","config","$cvm1i","generateRandomPalConfig","$7oj37","setAnimationController","$leuCG","$hdQD0","$da7c88ef361297ae$export$b7cfb0b946e2f4d5","timeToStop","overshoot","overshootAngle","fromPolar","end","potentialDestinations","filter","dtSeconds","_shouldDecelerate","_accelerate","predictedStopPosition","STOPPED_FOR_DESTINATION","nextTravellerOnRoad","safeStopAheadPosition","STOPPED_FOR_TRAFFIC_IN_FRONT","intersection","outgoingTraveller","getClosestOutgoingTraveller","incomingTraveller","getClosestIncomingTraveller","_shouldDecelerateForNearbyTravellers","STOPPED_FOR_TRAFFIC_NEARBY","travellerFinder","stopArea","predictedStopArea","stopPoint","nextStopPoint","potentialNextPredictedStopPoint","searchArea","nearbyTravellers","findTravellersInCircle","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","otherStopArea","otherStopPoint","intersectsCircle","otherNextStopPoint","currentStopDistance","distanceTo","approachAmount","otherApproachAmount","isStopped","_forceAcceleration","isStoppedFor","err","return","acceleration","lastSpeed","avgSpeed","_isExiting","_onReachEndOfCurrentRoad","_onExit","consumeTraveller","_onReachDestination","_exit","MAX_SPEED","$e1f78be531e9cb91$export$2e2bcd8739ae039","_len","segments","Array","_key","addSegments","$8TSCy","toConsumableArray","getStart","getEnd","reduce","segment","getLength","constrained","soFar","lastSegment","equals","addSegment","newSegments","$6SQqk","entryAngle","angle","exitAngle","usableRadius","containingCircle","segmentAcrossCircle","compacted","compact","lastPoint","_this1","points","_points","toArray","remainingPoints","slice","path","point","entryPoint","exitPoint","entryLineNormal","$eYUEV","perpendicularLineThroughPoint","exitLineNormal","isParallelTo","roadCircleCenter","pointAtIntersectionWith","roadCircleRadius","$7Tktm","sub","$9193cc27414d964c$export$2e2bcd8739ae039","_intersectionsByAngle","_incomingIntersections","_outgoingIntersections","_roads","addChild","_intersectionAtAngle","connectTo","isIncoming","isOutgoing","_intersections","_addRoad","$b656cfa00f913cfd$export$2e2bcd8739ae039","path1","angleStr","_createIntersectionAtAngle","getVisualConnectionPointAtAngle","Object","keys","hasScene","$b656cfa00f913cfd$var$ROAD_DASH_COLOR","$b656cfa00f913cfd$var$ROAD_IDEAL_DASH","$b656cfa00f913cfd$var$ROAD_IDEAL_DASH_LENGTH","a","b","_Path","autoRound","isNode","_currentTravellers","angleFrom","angleTo","_path","straightThroughPoints","connectToRoadAtAngle","assertThisInitialized","sum","nextTraveller","onAddedToRoad","index","indexOf","removeTravellerAtIndex","splice","onRemovedFromRoad","bestDistance","distance","lineCap","lineJoin","dashScale","_getLineDashScale","dashLength","setLineDash","strokeStyle","lineDashOffset","lineWidth","stroke","wholeDashLength","floor","$78c1eec4f05c28aa$var$MAIN_COLOR","$78c1eec4f05c28aa$var$CLOCK_COLOR","$78c1eec4f05c28aa$var$PULSE_COLOR","$78c1eec4f05c28aa$export$2e2bcd8739ae039","_onTimerEnd","arc","$78c1eec4f05c28aa$var$RADIUS","_attemptEmitTraveller","sampleOutgoing","canAddTravellerAtStart","$46b0dccb79779987$var$ROUND","$46b0dccb79779987$var$scene","$dLeLC","window","devicePixelRatio","$46b0dccb79779987$var$root","document","getElementById","appendTo","addSystem","northConsumer","middleConsumer","southConsumer","eastProducer","westProducer","mainJunction","eastProducerSplit","southConsumerJoin","$46b0dccb79779987$var$scenario3"],"version":3,"file":"index.0536361f.js.map"}