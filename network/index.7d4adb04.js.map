{"mappings":"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","sources":["src/lib/QuadTree.ts"],"sourcesContent":["import AABB from './geom/AABB';\nimport Circle from './geom/Circle';\nimport Vector2 from './geom/Vector2';\n\ntype Subdivisions<T> = [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>];\n\nexport default class QuadTree<T> {\n  static NODE_CAPACITY = 4;\n\n  boundary: AABB;\n  _items: (T | void)[] = [];\n  _nextItemIndex: number = 0;\n  _subdivisions: null | Subdivisions<T> = null;\n  _getPosition: (item: T) => Vector2;\n\n  constructor(boundary: AABB, getPosition: (item: T) => Vector2) {\n    this.boundary = boundary;\n    this._getPosition = getPosition;\n  }\n\n  // debugDraw(color: string) {\n  //   this.boundary.debugDraw(color);\n  //   if (this._subdivisions) {\n  //     this._subdivisions.forEach(subdivision => subdivision.debugDraw(color));\n  //   }\n  // }\n\n  insert(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    if (this._nextItemIndex < QuadTree.NODE_CAPACITY) {\n      this._items[this._nextItemIndex] = item;\n      this._nextItemIndex++;\n      return true;\n    }\n\n    const subdivisions = this._getSubdivisions();\n\n    if (subdivisions[0].insert(item)) return true;\n    if (subdivisions[1].insert(item)) return true;\n    if (subdivisions[2].insert(item)) return true;\n    if (subdivisions[3].insert(item)) return true;\n\n    throw new Error('Couldnt insert item');\n  }\n\n  remove(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    const index = this._items.indexOf(item);\n    if (index !== -1) {\n      this._items.splice(index, 1);\n      this._nextItemIndex--;\n      return true;\n    }\n\n    const subdivisions = this._subdivisions;\n    if (subdivisions) {\n      if (subdivisions[0].remove(item)) return true;\n      if (subdivisions[1].remove(item)) return true;\n      if (subdivisions[2].remove(item)) return true;\n      if (subdivisions[3].remove(item)) return true;\n    }\n\n    return false;\n  }\n\n  clear() {\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      this._items[i] = undefined;\n      this._nextItemIndex = 0;\n    }\n\n    if (this._subdivisions) {\n      this._subdivisions.forEach(subdivision => subdivision.clear());\n    }\n  }\n\n  findItemsInRect(rect: AABB): T[] {\n    const foundItems = [] as Array<T>;\n\n    if (!this.boundary.intersects(rect)) return foundItems;\n\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      const item = this._items[i];\n      if (item == null) continue;\n      const point = this._getPosition(item);\n      if (rect.contains(point)) foundItems.push(item);\n    }\n\n    const subdivisions = this._subdivisions;\n    if (!subdivisions) return foundItems;\n\n    if (subdivisions[0].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[0].findItemsInRect(rect));\n    }\n    if (subdivisions[1].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[1].findItemsInRect(rect));\n    }\n    if (subdivisions[2].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[2].findItemsInRect(rect));\n    }\n    if (subdivisions[3].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[3].findItemsInRect(rect));\n    }\n\n    return foundItems;\n  }\n\n  findItemsInCircle(circle: Circle): T[] {\n    return this.findItemsInRect(circle.getBoundingBox()).filter(item =>\n      circle.containsPoint(this._getPosition(item)),\n    );\n  }\n\n  _getSubdivisions(): Subdivisions<T> {\n    if (this._subdivisions) return this._subdivisions;\n\n    const center = this.boundary.getCenter();\n    const subdivisions: Subdivisions<T> = [\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          this.boundary.top,\n          center.x,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          this.boundary.top,\n          this.boundary.right,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          center.y,\n          center.x,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          center.y,\n          this.boundary.right,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n    ];\n\n    this._subdivisions = subdivisions;\n    return subdivisions;\n  }\n}\n"],"names":["_foundItems","_foundItems1","_foundItems2","_foundItems3","$e0f685956c805bb1$export$9099ad97b570f7c","boundary","getPosition","_items","_nextItemIndex","_subdivisions","_getPosition","key","item","point","this","contains","NODE_CAPACITY","subdivisions","_getSubdivisions","insert","Error","index","indexOf","splice","remove","i","undefined","forEach","subdivision","clear","rect","foundItems","intersects","push","apply","$eUMMJ","toConsumableArray","findItemsInRect","circle","getBoundingBox","filter","containsPoint","center","getCenter","$7B1qO","default","fromLeftTopRightBottom","left","top","x","y","right","bottom"],"version":3,"file":"index.7d4adb04.js.map"}