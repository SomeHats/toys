{"mappings":"yRAsQgBA,EAAIC,EAAaC,UACxBC,OAAOC,UAAUC,eAAeC,KAAKL,EAAKC,oVCvQnD,IAAIK,EAAAC,mJAEJ,IAAIC,EAAO,GAoBXD,WAlBkBE,OAChB,IAAIC,EAAOR,OAAOQ,KAAKD,GAEdE,EAAI,EAAGA,EAAID,EAAKE,OAAQD,IAC/BH,EAAQE,EAAKC,IAAMF,EAAMC,EAAKC,KAelCL,WAXiBO,GACf,IAAIC,EAAWN,EAAQK,GAEvB,GAAgB,MAAZC,EACF,MAAM,IAAIC,MAAK,oCAAuCF,UAGjDC,MCnBTE,EAAA,SAAAC,SAA8CC,KAAKC,MAAK,gGCKpC,oBAATC,YAETC,OAAOD,UAAYE,SAASC,KAAKC,QAAO,IAAKC,aAG1C1B,EAAIqB,UAAUjB,UAAS,cAC1BuB,QAAQC,IAAG,yBACXzB,OAAO0B,eAAeR,UAAUjB,UAAS,WAAY,CACnD0B,aACIC,KAAQC,YAASD,KACZC,UACW,aADFD,KACPE,UACDC,QAAQC,UACR,IAAID,SAAO,CAAEC,EAASC,UACfC,iBAAgB,SAAWF,EAAO,CAAIG,MAAM,SAC5CD,iBAAgB,SAAWD,EAAM,CAAIE,MAAM,aAG9CN,gDCvBlBO,EAAAC,QAAcC,OAAA,QAAsCxB,EAAA,SAAAkB,QAA4C,UAAYO,MAAI,IAAOzB,EAAa,cD4BpIA,EAAA,SAAuByB,MAAMC,IAG3B,MAAMC,EAAM,sNAQRC,OACJF,EACGG,MAAMF,EAAQrB,SAASwB,eAAc,SACrCL,MAAMM,GAAWrB,QAAQC,IAAG,UAAYoB,KACxCC,OAAOC,GAAQvB,QAAQC,IAAG,QAAUsB","sources":["src/lib/utils.ts","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-bec5c2af3755727b.js","src/slomojs/main.tsx","node_modules/@parcel/runtime-js/lib/runtime-061326f6e352bf43.js"],"sourcesContent":["export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"k6vaV\\\":\\\"index.274f7fb9.js\\\",\\\"d438m\\\":\\\"Cargo.f6c76a7c.js\\\"}\"));","import 'regenerator-runtime/runtime';\nimport { has } from '../lib/utils';\n// import * as slomo from './Cargo.toml';\n\n// Chrome does not seem to expose the Animation constructor globally\nif (typeof Animation === 'undefined') {\n  // @ts-expect-error\n  window.Animation = document.body.animate({}).constructor;\n}\n\nif (!has(Animation.prototype, 'finished')) {\n  console.log('add finished polyfill');\n  Object.defineProperty(Animation.prototype, 'finished', {\n    get() {\n      if (!this._finished) {\n        this._finished =\n          this.playState === 'finished'\n            ? Promise.resolve()\n            : new Promise((resolve, reject) => {\n                this.addEventListener('finish', resolve, { once: true });\n                this.addEventListener('cancel', reject, { once: true });\n              });\n      }\n      return this._finished;\n    },\n  });\n}\n\nimport('./Cargo.toml').then((slomo) => {\n  // slomo.tester(document.getElementById('root')!);\n\n  const source = `\n    let str = \"hello, world\";\n    log(str);\n    let x = 1 + 2000 + 3 + \"hiii\", a = 1, b = 2, c;\n    let y = \"hello\" + x;\n    log(y, x, a, b + b + a, log);\n    __debugScope();\n    log(__debugScope);\n    `.trim();\n  slomo\n    .start(source, document.getElementById('root')!)\n    .then((result) => console.log('success', result))\n    .catch((err) => console.log('error', err));\n});\n","module.exports = (__parcel__import__(\"./\" + \"../\" + require('./helpers/bundle-manifest').resolve(\"d438m\"))).then(() => parcelRequire('ot8r2'));"],"names":["$f2b3fa9969eed8fe$export$2ae9c6247c57563e","obj","key","Object","prototype","hasOwnProperty","call","$b0ade3e8a89020bb$export$40339995e8a21591","$b0ade3e8a89020bb$export$357eb1b4f03c1402","$b0ade3e8a89020bb$var$mapping","pairs","keys","i","length","id","resolved","Error","parcelRequire","register","JSON","parse","Animation","window","document","body","animate","constructor","console","log","defineProperty","get","this","_finished","playState","Promise","resolve","reject","addEventListener","once","module","exports","import","then","slomo","source","trim","start","getElementById","result","catch","err"],"version":3,"file":"index.274f7fb9.js.map"}