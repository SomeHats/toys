{"mappings":"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","sources":["src/lib/geom/Circle.ts","src/lib/geom/Vector2.ts","src/lib/utils.ts","src/lib/geom/AABB.ts","src/lib/geom/Line2.ts","src/lib/assert.ts"],"sourcesContent":["// @flow\nimport Vector2 from './Vector2';\nimport AABB from './AABB';\nimport Line2 from './Line2';\n\nexport default class Circle {\n  static create(x: number, y: number, radius: number): Circle {\n    return new Circle(new Vector2(x, y), radius);\n  }\n  constructor(readonly center: Vector2, readonly radius: number) {}\n\n  get circumference(): number {\n    return 2 * Math.PI * this.radius;\n  }\n\n  getBoundingBox(): AABB {\n    return new AABB(\n      new Vector2(this.center.x, this.center.y),\n      new Vector2(this.radius * 2, this.radius * 2),\n    );\n  }\n\n  // debugDraw(color: string) {\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.strokeStyle = color;\n  //   ctx.lineWidth = 1;\n  //   ctx.beginPath();\n  //   ctx.arc(this.center.x, this.center.y, this.radius, 0, Math.PI * 2, false);\n  //   ctx.stroke();\n  // }\n\n  pointOnCircumference(radians: number): Vector2 {\n    return new Vector2(\n      this.center.x + Math.cos(radians) * this.radius,\n      this.center.y + Math.sin(radians) * this.radius,\n    );\n  }\n\n  containsPoint(point: Vector2): boolean {\n    return point.distanceTo(this.center) < this.radius;\n  }\n\n  intersectsCircle(other: Circle): boolean {\n    return this.center.distanceTo(other.center) < this.radius + other.radius;\n  }\n\n  withRadius(radius: number): Circle {\n    return Circle.create(this.center.x, this.center.y, radius);\n  }\n\n  outerTangentsWith(other: Circle): [Line2, Line2] | undefined {\n    const distance = this.center.distanceTo(other.center);\n    if (distance <= Math.abs(this.radius - other.radius)) {\n      // The circles are coinciding. There are no valid tangents.\n      return undefined;\n    }\n\n    const angle = this.center.angleTo(other.center);\n    const normalAngle = Math.acos((this.radius - other.radius) / distance);\n\n    return [\n      new Line2(\n        this.pointOnCircumference(angle - normalAngle),\n        other.pointOnCircumference(angle - normalAngle),\n      ),\n      new Line2(\n        this.pointOnCircumference(angle + normalAngle),\n        other.pointOnCircumference(angle + normalAngle),\n      ),\n    ];\n  }\n}\n","import { normalizeAngle, lerp } from '../utils';\n\nexport default class Vector2 {\n  static readonly ZERO = new Vector2(0, 0);\n\n  static fromPolar(angle: number, radius: number) {\n    return new Vector2(radius * Math.cos(angle), radius * Math.sin(angle));\n  }\n\n  static average(points: ReadonlyArray<Vector2>): Vector2 {\n    const sum = points.reduce((memo, p) => memo.add(p), Vector2.ZERO);\n    return sum.div(points.length);\n  }\n\n  static fromVectorLike({ x, y }: { x: number; y: number }): Vector2 {\n    return new Vector2(x, y);\n  }\n\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  toString(): string {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n\n  get magnitudeSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  get magnitude(): number {\n    return Math.sqrt(this.magnitudeSquared);\n  }\n\n  get angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  isInPolygon(polygon: ReadonlyArray<Vector2>): boolean {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const { x, y } = this;\n\n    let isInside = false;\n    for (\n      let currentIdx = 0, previousIdx = polygon.length - 1;\n      currentIdx < polygon.length;\n      previousIdx = currentIdx++\n    ) {\n      const { x: currentX, y: currentY } = polygon[currentIdx];\n      const { x: previousX, y: previousY } = polygon[previousIdx];\n      const doesIntersect =\n        currentY > y != previousY > y &&\n        x <\n          ((previousX - currentX) * (y - currentY)) / (previousY - currentY) +\n            currentX;\n\n      if (doesIntersect) {\n        isInside = !isInside;\n      }\n    }\n\n    return isInside;\n  }\n\n  equals(other: Vector2) {\n    return this === other || (this.x === other.x && this.y === other.y);\n  }\n\n  distanceTo({ x, y }: Vector2): number {\n    const dx = x - this.x;\n    const dy = y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angleTo(other: Vector2): number {\n    return other.sub(this).angle;\n  }\n\n  angleBetween(other: Vector2): number {\n    return normalizeAngle(\n      Math.atan2(other.y, other.x) - Math.atan2(this.y, this.x),\n    );\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  div(scale: number): Vector2 {\n    return new Vector2(this.x / scale, this.y / scale);\n  }\n\n  scale(scale: number): Vector2 {\n    return new Vector2(this.x * scale, this.y * scale);\n  }\n\n  negate(): Vector2 {\n    return this.scale(-1);\n  }\n\n  add({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x + x, this.y + y);\n  }\n\n  sub({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x - x, this.y - y);\n  }\n\n  floor(): Vector2 {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  ceil(): Vector2 {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n\n  round(): Vector2 {\n    return new Vector2(Math.round(this.x), Math.round(this.y));\n  }\n\n  withMagnitude(newMagnitude: number): Vector2 {\n    return Vector2.fromPolar(this.angle, newMagnitude);\n  }\n\n  normalize(): Vector2 {\n    return this.withMagnitude(1);\n  }\n\n  withAngle(newAngle: number): Vector2 {\n    return Vector2.fromPolar(newAngle, this.magnitude);\n  }\n\n  rotate(byAngle: number): Vector2 {\n    return this.withAngle(this.angle + byAngle);\n  }\n\n  lerp(other: Vector2, n: number): Vector2 {\n    return new Vector2(lerp(this.x, other.x, n), lerp(this.y, other.y, n));\n  }\n}\n","export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function isWithin(a: number, b: number, n: number): boolean {\n  return a > b ? b <= n && n <= a : a <= n && n <= b;\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n\nexport function last<T>(arr: ReadonlyArray<T>): T | undefined {\n  if (!arr.length) {\n    return undefined;\n  }\n  return arr[arr.length - 1];\n}\n\nexport function* indexed<T>(\n  iterable: Iterable<T>,\n): Generator<[number, T], void> {\n  let i = 0;\n  for (const item of iterable) {\n    yield [i, item];\n    i++;\n  }\n}\n\nexport function noop() {}\n","import Vector2 from './Vector2';\n\nexport default class AABB {\n  static fromLeftTopRightBottom(\n    left: number,\n    top: number,\n    right: number,\n    bottom: number,\n  ): AABB {\n    return new AABB(\n      new Vector2(left, top),\n      new Vector2(right - left, bottom - top),\n    );\n  }\n\n  constructor(public readonly origin: Vector2, public readonly size: Vector2) {\n    Object.freeze(this);\n  }\n\n  contains({ x, y }: Vector2): boolean {\n    return (\n      this.left <= x && x <= this.right && this.top <= y && y <= this.bottom\n    );\n  }\n\n  intersects(other: AABB): boolean {\n    return !(\n      this.right < other.left ||\n      this.left > other.right ||\n      this.bottom < other.top ||\n      this.top > other.bottom\n    );\n  }\n\n  getCenter(): Vector2 {\n    return this.origin.add(this.size.scale(0.5));\n  }\n\n  get left(): number {\n    return this.origin.x;\n  }\n\n  get right(): number {\n    return this.origin.x + this.size.x;\n  }\n\n  get top(): number {\n    return this.origin.y;\n  }\n\n  get bottom(): number {\n    return this.origin.y + this.size.y;\n  }\n\n  get width(): number {\n    return this.size.x;\n  }\n\n  get height(): number {\n    return this.size.y;\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport { isWithin } from '../utils';\nimport Vector2 from './Vector2';\n\nconst isSlopeVertical = (slope: number) =>\n  slope === Infinity || slope === -Infinity;\n\nexport default class Line2 {\n  static fromSlopeAndDisplacement(slope: number, displacement: number) {\n    assert(\n      !isSlopeVertical(slope),\n      'cannot create vertical line from displacement',\n    );\n\n    const start = new Vector2(0, displacement);\n    const end = new Vector2(1, slope + displacement);\n    return new Line2(start, end);\n  }\n\n  static fromSlopeAndPoint(slope: number, point: Vector2): Line2 {\n    if (isSlopeVertical(slope)) {\n      return new Line2(point, new Vector2(point.x, point.y + 1));\n    }\n\n    const displacement = point.y - point.x * slope;\n    return Line2.fromSlopeAndDisplacement(slope, displacement);\n  }\n\n  readonly start: Vector2;\n  readonly end: Vector2;\n\n  constructor(a: Vector2, b: Vector2) {\n    this.start = a;\n    this.end = b;\n  }\n\n  getDelta(): Vector2 {\n    return this.end.sub(this.start);\n  }\n\n  get slope(): number {\n    return (this.end.y - this.start.y) / (this.end.x - this.start.x);\n  }\n\n  get angle(): number {\n    return this.start.angleTo(this.end);\n  }\n\n  get length(): number {\n    return this.start.distanceTo(this.end);\n  }\n\n  get displacement(): number {\n    return this.start.y - this.start.x * this.slope;\n  }\n\n  get isVertical(): boolean {\n    return isSlopeVertical(this.slope);\n  }\n\n  get verticalX(): number {\n    assert(this.isVertical, 'verticalX is not defined on non vertical lines');\n    return this.start.x;\n  }\n\n  get perpendicularSlope(): number {\n    if (this.isVertical) return 0;\n    return -1 / this.slope;\n  }\n\n  isParallelTo(other: Line2): boolean {\n    return (this.isVertical && other.isVertical) || this.slope === other.slope;\n  }\n\n  perpendicularLineThroughPoint(point: Vector2): Line2 {\n    return Line2.fromSlopeAndPoint(this.perpendicularSlope, point);\n  }\n\n  pointAtIntersectionWith(other: Line2): Vector2 {\n    assert(!this.isParallelTo(other), 'parallel lines do not intersect');\n\n    let x;\n    if (this.isVertical) {\n      x = this.verticalX;\n    } else if (other.isVertical) {\n      x = other.verticalX;\n    } else {\n      x = (this.displacement - other.displacement) / (other.slope - this.slope);\n    }\n\n    const y = this.isVertical\n      ? other.slope * x + other.displacement\n      : this.slope * x + this.displacement;\n\n    return new Vector2(x, y);\n  }\n\n  pointAtIntersectionConstrained(other: Line2): Vector2 | undefined {\n    if (this.isParallelTo(other)) return undefined;\n    const point = this.pointAtIntersectionWith(other);\n    if (this.isPointWithinBounds(point) && other.isPointWithinBounds(point)) {\n      return point;\n    }\n    return undefined;\n  }\n\n  midpoint(): Vector2 {\n    return new Vector2(\n      (this.start.x + this.end.x) / 2,\n      (this.start.y + this.end.y) / 2,\n    );\n  }\n\n  isPointWithinBounds({ x, y }: Vector2): boolean {\n    return (\n      isWithin(this.start.x, this.end.x, x) &&\n      isWithin(this.start.y, this.end.y, y)\n    );\n  }\n}\n","export function fail(message: string): never {\n  throw new Error(message);\n}\n\nexport function assert(value: unknown, message?: string): asserts value {\n  if (!value) {\n    fail(message || 'Assertion Error');\n  }\n}\n"],"names":["$4f87fcbb88c6d8cd$export$2e2bcd8739ae039","x","y","radius","$6i1fg","default","circumference","Math","PI","this","getBoundingBox","$9x7hn","center","pointOnCircumference","radians","cos","sin","containsPoint","point","distanceTo","intersectsCircle","other","withRadius","radius1","create","outerTangentsWith","other1","distance","abs","angle","angleTo","normalAngle","acos","$6Cnop","radius2","$db8edb9c8035529a$export$2e2bcd8739ae039","points","reduce","memo","p","add","ZERO","div","length","toString","magnitudeSquared","magnitude","sqrt","atan2","isInPolygon","polygon","isInside","currentIdx","previousIdx","currentX","currentY","previousX","previousY","equals","x1","y1","dx","dy","sub","angleBetween","other2","$96RKe","normalizeAngle","dot","other3","scale","scale1","negate","x2","y2","x3","y3","floor","ceil","round","withMagnitude","newMagnitude","fromPolar","normalize","withAngle","newAngle","rotate","byAngle","lerp","other4","n","x4","y4","$15a201ffde8bbde4$export$b5bc26e198ce73d0","fn","result","i","push","$15a201ffde8bbde4$export$3a89f8d6f6bf6c9f","a","b","$15a201ffde8bbde4$export$4444e85a8e8eb4d3","$15a201ffde8bbde4$export$cda7a9d4399bf2e3","$15a201ffde8bbde4$export$c4e2ecac49351ef2","min","max","$15a201ffde8bbde4$export$f65a7599bbc6b121","a1","b1","a2","b2","$15a201ffde8bbde4$export$4385e60b38654f68","random","$15a201ffde8bbde4$export$3c5f89dae98e900b","$15a201ffde8bbde4$export$cb053c0bd718c500","base","amount","$15a201ffde8bbde4$export$81f57db650c22c0c","$15a201ffde8bbde4$export$4812e460280c6ef2","arr","$15a201ffde8bbde4$export$bffa455ba8c619a6","concat","$15a201ffde8bbde4$export$f70730c3d1fc524e","Array","from","Set","$15a201ffde8bbde4$export$bc86dfbf7795668c","a1Items","item","has","$15a201ffde8bbde4$export$3f063810d7bf01bd","items","getKey","groups","Map","key","existing","get","set","$15a201ffde8bbde4$export$b035e44d7bb4278f","slice","sort","$15a201ffde8bbde4$export$b29f828819edca8d","condition","pass","fail","$15a201ffde8bbde4$export$8af121ae7401c4","array","idx","indexOf","splice","$15a201ffde8bbde4$export$2cef06c20297c17d","Promise","resolve","window","requestAnimationFrame","time","$15a201ffde8bbde4$export$a57f5080a3bcc90a","cb","shouldCancel","cancel","$15a201ffde8bbde4$export$5150077fc2e7c662","entries","value","$15a201ffde8bbde4$export$ed97f33186d4b816","object","Object","keys","$15a201ffde8bbde4$export$3e9f948b41964866","$15a201ffde8bbde4$export$8e16b83750b44988","filter","$15a201ffde8bbde4$export$e3df76cf4464bc81","size","$15a201ffde8bbde4$export$9013bf5175691fac","$15a201ffde8bbde4$export$7d15b64cf5a3a4c4","$15a201ffde8bbde4$export$448332262467e042","newArr","j","$15a201ffde8bbde4$export$218c8c3169c024d2","prefix","$15a201ffde8bbde4$export$93d719890ad66653","fallback","localStorage","getItem","JSON","parse","error","console","log","$15a201ffde8bbde4$export$5aa524d86254b4f","stringified","stringify","setItem","$15a201ffde8bbde4$export$61fc7d43ac8f84b0","ms","timeoutHandle","args","undefined","clearTimeout","setTimeout","$15a201ffde8bbde4$export$112b608d3d6f9c56","Error","$15a201ffde8bbde4$export$a4f4bb6b1453fff5","obj","prototype","hasOwnProperty","call","$15a201ffde8bbde4$export$3988ae62b71be9a3","$15a201ffde8bbde4$export$6f9d191e539f6e18","epsilon","$15a201ffde8bbde4$export$e372b34e4bfc2a00","setupResolve","setupReject","reject","$15a201ffde8bbde4$export$8793edee2d425525","$615946a1704d0ee5$export$2e2bcd8739ae039","left","top","right","bottom","contains","intersects","getCenter","origin","width","height","freeze","$b70e849589839c73$var$isSlopeVertical","slope","Infinity","$b70e849589839c73$export$2e2bcd8739ae039","displacement","$87DYR","assert","start","end","slope1","fromSlopeAndDisplacement","getDelta","isVertical","verticalX","perpendicularSlope","isParallelTo","perpendicularLineThroughPoint","point1","fromSlopeAndPoint","pointAtIntersectionWith","pointAtIntersectionConstrained","isPointWithinBounds","midpoint","isWithin","$90518cd969dab22c$export$2b62a06a9fee979c","message","$90518cd969dab22c$export$a7a9523472993e97"],"version":3,"file":"index.2dfda5e4.js.map"}