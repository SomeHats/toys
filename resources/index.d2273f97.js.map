{"mappings":"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","sources":["src/lib/utils.ts","src/lib/geom/Vector2.ts","src/lib/DebugDraw.ts","src/resources/canvas.ts","src/lib/geom/AABB.ts","src/lib/QuadTree.ts","src/resources/resources-main.ts","src/lib/createTriangleGrid.ts"],"sourcesContent":["export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n","import { normalizeAngle, lerp } from '../utils';\n\nexport default class Vector2 {\n  static readonly ZERO = new Vector2(0, 0);\n\n  static fromPolar(angle: number, radius: number) {\n    return new Vector2(radius * Math.cos(angle), radius * Math.sin(angle));\n  }\n\n  static average(points: ReadonlyArray<Vector2>): Vector2 {\n    const sum = points.reduce((memo, p) => memo.add(p), Vector2.ZERO);\n    return sum.div(points.length);\n  }\n\n  static fromVectorLike({ x, y }: { x: number; y: number }): Vector2 {\n    return new Vector2(x, y);\n  }\n\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  toString(): string {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n\n  get magnitudeSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  get magnitude(): number {\n    return Math.sqrt(this.magnitudeSquared);\n  }\n\n  get angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  isInPolygon(polygon: ReadonlyArray<Vector2>): boolean {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const { x, y } = this;\n\n    let isInside = false;\n    for (\n      let currentIdx = 0, previousIdx = polygon.length - 1;\n      currentIdx < polygon.length;\n      previousIdx = currentIdx++\n    ) {\n      const { x: currentX, y: currentY } = polygon[currentIdx];\n      const { x: previousX, y: previousY } = polygon[previousIdx];\n      const doesIntersect =\n        currentY > y != previousY > y &&\n        x <\n          ((previousX - currentX) * (y - currentY)) / (previousY - currentY) +\n            currentX;\n\n      if (doesIntersect) {\n        isInside = !isInside;\n      }\n    }\n\n    return isInside;\n  }\n\n  equals(other: Vector2) {\n    return this === other || (this.x === other.x && this.y === other.y);\n  }\n\n  distanceTo({ x, y }: Vector2): number {\n    const dx = x - this.x;\n    const dy = y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angleTo(other: Vector2): number {\n    return other.sub(this).angle;\n  }\n\n  angleBetween(other: Vector2): number {\n    return normalizeAngle(\n      Math.atan2(other.y, other.x) - Math.atan2(this.y, this.x),\n    );\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  div(scale: number): Vector2 {\n    return new Vector2(this.x / scale, this.y / scale);\n  }\n\n  scale(scale: number): Vector2 {\n    return new Vector2(this.x * scale, this.y * scale);\n  }\n\n  negate(): Vector2 {\n    return this.scale(-1);\n  }\n\n  add({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x + x, this.y + y);\n  }\n\n  sub({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x - x, this.y - y);\n  }\n\n  floor(): Vector2 {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  ceil(): Vector2 {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n\n  round(): Vector2 {\n    return new Vector2(Math.round(this.x), Math.round(this.y));\n  }\n\n  withMagnitude(newMagnitude: number): Vector2 {\n    return Vector2.fromPolar(this.angle, newMagnitude);\n  }\n\n  normalize(): Vector2 {\n    return this.withMagnitude(1);\n  }\n\n  withAngle(newAngle: number): Vector2 {\n    return Vector2.fromPolar(newAngle, this.magnitude);\n  }\n\n  rotate(byAngle: number): Vector2 {\n    return this.withAngle(this.angle + byAngle);\n  }\n\n  lerp(other: Vector2, n: number): Vector2 {\n    return new Vector2(lerp(this.x, other.x, n), lerp(this.y, other.y, n));\n  }\n}\n","import AABB from './geom/AABB';\nimport Vector2 from './geom/Vector2';\n\nconst DEFAULT_DEBUG_COLOR = 'magenta';\nconst LABEL_OFFSET = new Vector2(5, 0);\nconst DEBUG_POINT_SIZE = 3;\nconst HAIRLINE = 0.5;\nconst DEBUG_ARROW_ANGLE = Math.PI * 0.75;\nconst DEBUG_ARROW_SIZE = 5;\n\nexport type StrokeOptions = {\n  strokeWidth?: number;\n  stroke?: string;\n  strokeCap?: 'butt' | 'round' | 'square';\n  strokeDash?: number[];\n  strokeDashOffset?: number;\n  strokeJoin?: 'bevel' | 'round' | 'miter';\n};\n\nexport type FillOptions = {\n  fill?: string;\n};\n\nexport type DebugOptions = {\n  color?: string;\n  label?: string;\n};\n\nexport type StrokeAndFillOptions = StrokeOptions & FillOptions;\n\nexport class DebugDraw {\n  constructor(private readonly ctx: CanvasRenderingContext2D) {}\n\n  public clear(fill?: string) {\n    if (!fill) {\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      return;\n    }\n\n    this.applyFillOptions({ fill });\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n\n  public beginPath() {\n    this.ctx.beginPath();\n  }\n\n  public moveTo({ x, y }: Vector2) {\n    this.ctx.moveTo(x, y);\n  }\n\n  public lineTo({ x, y }: Vector2) {\n    this.ctx.lineTo(x, y);\n  }\n\n  public arc(\n    { x, y }: Vector2,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean,\n  ) {\n    this.ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  public arcTo(p1: Vector2, p2: Vector2, radius: number) {\n    this.ctx.arcTo(p1.x, p1.y, p2.x, p2.y, radius);\n  }\n\n  public applyStrokeOptions({\n    strokeWidth = 1,\n    stroke = undefined,\n    strokeCap = 'butt',\n    strokeDash = [],\n    strokeDashOffset = 0,\n    strokeJoin = 'round',\n  }: StrokeOptions) {\n    if (stroke) {\n      this.ctx.lineWidth = strokeWidth;\n      this.ctx.strokeStyle = stroke;\n      this.ctx.lineCap = strokeCap;\n      this.ctx.setLineDash(strokeDash);\n      this.ctx.lineDashOffset = strokeDashOffset;\n      this.ctx.lineJoin = strokeJoin;\n    }\n  }\n\n  public stroke(options: StrokeOptions) {\n    if (options.stroke) {\n      this.applyStrokeOptions(options);\n      this.ctx.stroke();\n    }\n  }\n\n  public applyFillOptions({ fill = undefined }: FillOptions) {\n    if (fill) {\n      this.ctx.fillStyle = fill;\n    }\n  }\n\n  public fill(options: FillOptions) {\n    if (options.fill) {\n      this.applyFillOptions(options);\n      this.ctx.fill();\n    }\n  }\n\n  public applyStrokeAndFillOptions(options: StrokeAndFillOptions) {\n    this.applyFillOptions(options);\n    this.applyStrokeOptions(options);\n  }\n\n  public strokeAndFill(options: StrokeAndFillOptions) {\n    this.fill(options);\n    this.stroke(options);\n  }\n\n  public getDebugStrokeOptions(\n    color: string = DEFAULT_DEBUG_COLOR,\n  ): StrokeOptions {\n    return { stroke: color, strokeWidth: HAIRLINE };\n  }\n\n  public debugStroke(color: string = DEFAULT_DEBUG_COLOR) {\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n\n  public fillText(text: string, position: Vector2, options: FillOptions = {}) {\n    this.applyFillOptions(options);\n    this.ctx.fillText(text, position.x, position.y);\n  }\n\n  public circle(\n    center: Vector2,\n    radius: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.arc(center, radius, 0, 2 * Math.PI);\n    this.strokeAndFill(options);\n  }\n\n  public ellipse(\n    center: Vector2,\n    radiusX: number,\n    radiusY: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.ctx.ellipse(center.x, center.y, radiusX, radiusY, 0, 0, Math.PI * 2);\n    this.strokeAndFill(options);\n  }\n\n  public debugLabel(\n    label: string | undefined,\n    position: Vector2,\n    color: string,\n  ) {\n    if (label) {\n      this.applyFillOptions({ fill: color });\n      this.fillText(label, position.add(LABEL_OFFSET));\n    }\n  }\n\n  public debugPointX(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.beginPath();\n    this.ctx.moveTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.ctx.moveTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugPointO(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.circle(position, DEBUG_POINT_SIZE, {\n      strokeWidth: HAIRLINE,\n      stroke: color,\n    });\n  }\n\n  public debugArrow(\n    start: Vector2,\n    end: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, Vector2.average([start, end]), color);\n\n    this.ctx.beginPath();\n    this.moveTo(start);\n    this.lineTo(end);\n\n    const vector = end.sub(start);\n    const arrowLeftPoint = vector\n      .rotate(-DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n    const arrowRightPoint = vector\n      .rotate(+DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n\n    this.moveTo(arrowLeftPoint);\n    this.lineTo(end);\n    this.lineTo(arrowRightPoint);\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugVectorAtPoint(\n    vector: Vector2,\n    base: Vector2,\n    options?: DebugOptions,\n  ) {\n    this.debugArrow(base, base.add(vector), options);\n  }\n\n  public polygon(\n    polygon: ReadonlyArray<Vector2>,\n    options: StrokeAndFillOptions = {},\n  ) {\n    this.beginPath();\n    this.moveTo(polygon[polygon.length - 1]);\n    for (const point of polygon) {\n      this.lineTo(point);\n    }\n    this.strokeAndFill(options);\n  }\n\n  public polyLine(points: ReadonlyArray<Vector2>, options: StrokeOptions = {}) {\n    this.beginPath();\n    this.moveTo(points[0]);\n    for (let i = 1; i < points.length; i++) {\n      this.lineTo(points[i]);\n    }\n    this.stroke(options);\n  }\n\n  public debugPolygon(\n    polygon: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polygon[0], color);\n    this.polygon(polygon, this.getDebugStrokeOptions(color));\n  }\n\n  public debugPolyLine(\n    polyLine: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polyLine[0], color);\n    this.polyLine(polyLine, this.getDebugStrokeOptions(color));\n  }\n\n  public aabb(\n    aabb: AABB,\n    opts: StrokeAndFillOptions & { debug?: DebugOptions },\n  ) {\n    if (opts.debug) {\n      this.debugLabel(\n        opts.debug.label,\n        aabb.origin,\n        opts.debug.color || DEFAULT_DEBUG_COLOR,\n      );\n    }\n    this.ctx.beginPath();\n    this.ctx.rect(aabb.left, aabb.top, aabb.width, aabb.height);\n    this.strokeAndFill(opts);\n  }\n}\n","import { DebugDraw } from '../lib/DebugDraw';\n\nexport const canvasEl = document.createElement('canvas');\nexport const ctx = canvasEl.getContext('2d')!;\nexport const width = document.body.clientWidth;\nexport const height = document.body.clientHeight;\nexport const scale = window.devicePixelRatio;\n\ncanvasEl.width = width * scale;\ncanvasEl.height = height * scale;\ncanvasEl.style.width = `${width}px`;\ncanvasEl.style.height = `${height}px`;\nctx.scale(scale, scale);\nexport const canvas = new DebugDraw(ctx);\ndocument.body.appendChild(canvasEl);\n","import Vector2 from './Vector2';\n\nexport default class AABB {\n  static fromLeftTopRightBottom(\n    left: number,\n    top: number,\n    right: number,\n    bottom: number,\n  ): AABB {\n    return new AABB(\n      new Vector2(left, top),\n      new Vector2(right - left, bottom - top),\n    );\n  }\n\n  constructor(public readonly origin: Vector2, public readonly size: Vector2) {\n    Object.freeze(this);\n  }\n\n  contains({ x, y }: Vector2): boolean {\n    return (\n      this.left <= x && x <= this.right && this.top <= y && y <= this.bottom\n    );\n  }\n\n  intersects(other: AABB): boolean {\n    return !(\n      this.right < other.left ||\n      this.left > other.right ||\n      this.bottom < other.top ||\n      this.top > other.bottom\n    );\n  }\n\n  getCenter(): Vector2 {\n    return this.origin.add(this.size.scale(0.5));\n  }\n\n  get left(): number {\n    return this.origin.x;\n  }\n\n  get right(): number {\n    return this.origin.x + this.size.x;\n  }\n\n  get top(): number {\n    return this.origin.y;\n  }\n\n  get bottom(): number {\n    return this.origin.y + this.size.y;\n  }\n\n  get width(): number {\n    return this.size.x;\n  }\n\n  get height(): number {\n    return this.size.y;\n  }\n}\n","import AABB from './geom/AABB';\nimport Circle from './geom/Circle';\nimport Vector2 from './geom/Vector2';\n\ntype Subdivisions<T> = [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>];\n\nexport default class QuadTree<T> {\n  static NODE_CAPACITY = 4;\n\n  boundary: AABB;\n  _items: (T | void)[] = [];\n  _nextItemIndex: number = 0;\n  _subdivisions: null | Subdivisions<T> = null;\n  _getPosition: (item: T) => Vector2;\n\n  constructor(boundary: AABB, getPosition: (item: T) => Vector2) {\n    this.boundary = boundary;\n    this._getPosition = getPosition;\n  }\n\n  // debugDraw(color: string) {\n  //   this.boundary.debugDraw(color);\n  //   if (this._subdivisions) {\n  //     this._subdivisions.forEach(subdivision => subdivision.debugDraw(color));\n  //   }\n  // }\n\n  insert(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    if (this._nextItemIndex < QuadTree.NODE_CAPACITY) {\n      this._items[this._nextItemIndex] = item;\n      this._nextItemIndex++;\n      return true;\n    }\n\n    const subdivisions = this._getSubdivisions();\n\n    if (subdivisions[0].insert(item)) return true;\n    if (subdivisions[1].insert(item)) return true;\n    if (subdivisions[2].insert(item)) return true;\n    if (subdivisions[3].insert(item)) return true;\n\n    throw new Error('Couldnt insert item');\n  }\n\n  remove(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    const index = this._items.indexOf(item);\n    if (index !== -1) {\n      this._items.splice(index, 1);\n      this._nextItemIndex--;\n      return true;\n    }\n\n    const subdivisions = this._subdivisions;\n    if (subdivisions) {\n      if (subdivisions[0].remove(item)) return true;\n      if (subdivisions[1].remove(item)) return true;\n      if (subdivisions[2].remove(item)) return true;\n      if (subdivisions[3].remove(item)) return true;\n    }\n\n    return false;\n  }\n\n  clear() {\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      this._items[i] = undefined;\n      this._nextItemIndex = 0;\n    }\n\n    if (this._subdivisions) {\n      this._subdivisions.forEach(subdivision => subdivision.clear());\n    }\n  }\n\n  findItemsInRect(rect: AABB): T[] {\n    const foundItems = [] as Array<T>;\n\n    if (!this.boundary.intersects(rect)) return foundItems;\n\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      const item = this._items[i];\n      if (item == null) continue;\n      const point = this._getPosition(item);\n      if (rect.contains(point)) foundItems.push(item);\n    }\n\n    const subdivisions = this._subdivisions;\n    if (!subdivisions) return foundItems;\n\n    if (subdivisions[0].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[0].findItemsInRect(rect));\n    }\n    if (subdivisions[1].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[1].findItemsInRect(rect));\n    }\n    if (subdivisions[2].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[2].findItemsInRect(rect));\n    }\n    if (subdivisions[3].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[3].findItemsInRect(rect));\n    }\n\n    return foundItems;\n  }\n\n  findItemsInCircle(circle: Circle): T[] {\n    return this.findItemsInRect(circle.getBoundingBox()).filter(item =>\n      circle.containsPoint(this._getPosition(item)),\n    );\n  }\n\n  _getSubdivisions(): Subdivisions<T> {\n    if (this._subdivisions) return this._subdivisions;\n\n    const center = this.boundary.getCenter();\n    const subdivisions: Subdivisions<T> = [\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          this.boundary.top,\n          center.x,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          this.boundary.top,\n          this.boundary.right,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          center.y,\n          center.x,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          center.y,\n          this.boundary.right,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n    ];\n\n    this._subdivisions = subdivisions;\n    return subdivisions;\n  }\n}\n","import { canvas, width, height } from './canvas';\nimport createTriangleGrid, { Triangle } from '../lib/createTriangleGrid';\nimport QuadTree from '../lib/QuadTree';\nimport AABB from '../lib/geom/AABB';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\n\nconst TILE_SIZE = 30;\n\nconst triangles = createTriangleGrid(TILE_SIZE, width, height);\nconst triangleQuadTree = new QuadTree<Triangle>(\n  new AABB(\n    new Vector2(-TILE_SIZE, -TILE_SIZE),\n    new Vector2(width + TILE_SIZE, height + TILE_SIZE),\n  ),\n  triangle => triangle.center,\n);\nfor (const triangle of triangles.values()) {\n  triangleQuadTree.insert(triangle);\n}\n\nconst items = triangleQuadTree.findItemsInRect(\n  new AABB(new Vector2(100, 100), new Vector2(200, 200)),\n  // new Circle(width * 0.75, height * 0.35, TILE_SIZE * 8),\n);\n\nconsole.log(items);\n\nfor (const wood of items) {\n  // canvas.polygon(wood.points, {} });\n  canvas.debugPolygon(wood.points);\n}\n\n// for (const triangle of triangles.values()) {\n//   console.log(triangle);\n// }\n","import Vector2 from '../lib/geom/Vector2';\nimport { getId, compact, intersection } from '../lib/utils';\nimport Intersection from '../network/networkNodes/Intersection';\n\ntype TriangleGeom = [Vector2, Vector2, Vector2];\ntype IntermediateTriangle = {\n  id: string;\n  points: TriangleGeom;\n};\n\nexport type TriangleNeighbour = {\n  triangle: Triangle;\n  sharedPoints: [Vector2, Vector2];\n};\nexport type Triangle = {\n  id: string;\n  center: Vector2;\n  points: TriangleGeom;\n  neighbours: TriangleNeighbour[];\n  ix: number;\n  iy: number;\n};\n\nexport default function createTriangleGrid(\n  tileSize: number,\n  width: number,\n  height: number,\n): Map<string, Triangle> {\n  const tileHeight = (tileSize * Math.sqrt(3)) / 2;\n  const points: Vector2[][] = [];\n  const trianglePoints: IntermediateTriangle[][] = [];\n  for (let iy = 0; iy * tileHeight < height + tileHeight; iy++) {\n    const pointRow: Vector2[] = [];\n    points.push(pointRow);\n    const triangleRow: IntermediateTriangle[] = [];\n    trianglePoints.push(triangleRow);\n    for (let ix = 0; ix * tileSize < width + tileSize; ix++) {\n      const xOffset = iy % 2 === 0 ? -tileSize / 2 : 0;\n      const point = new Vector2(ix * tileSize + xOffset, iy * tileHeight);\n      pointRow.push(point);\n\n      if (iy !== 0 && ix !== 0) {\n        if (iy % 2 === 0) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix - 1]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix - 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        } else if (points[iy - 1][ix + 1]) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix + 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        }\n      }\n    }\n  }\n\n  const trianglesById = new Map<string, Triangle>();\n  for (let iy = 0; iy < trianglePoints.length; iy++) {\n    for (let ix = 0; ix < trianglePoints[iy].length; ix++) {\n      const triangle = trianglePoints[iy][ix];\n      const center = Vector2.average(triangle.points);\n\n      const neighbours = compact(\n        ix % 2 === 0\n          ? iy % 2 === 0\n            ? [\n                // 2,2\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix - 1],\n              ]\n            : [\n                // 2,3\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix + 1],\n              ]\n          : iy % 2 === 0\n          ? [\n              // 3,2\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix - 1],\n            ]\n          : [\n              //3,3\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix + 1],\n            ],\n      );\n\n      const fullTriangle = triangle as Triangle;\n      fullTriangle.center = center;\n      fullTriangle.neighbours = neighbours.map(neighbourTriangle => ({\n        triangle: neighbourTriangle,\n        sharedPoints: intersection(triangle.points, neighbourTriangle.points),\n      })) as TriangleNeighbour[];\n      fullTriangle.ix = ix;\n      fullTriangle.iy = iy;\n\n      trianglesById.set(fullTriangle.id, fullTriangle);\n    }\n  }\n\n  return trianglesById;\n}\n"],"names":["$f2b3fa9969eed8fe$export$45ca8e7f50ccf2e0","a","b","n","$f2b3fa9969eed8fe$export$863a417fd46116e4","a1","a2","a1Items","Set","result","item","has","add","Array","from","$f2b3fa9969eed8fe$export$b52d3027a78bd277","prefix","Math","random","toString","slice","$b33d7521dbc247e4$export$9099ad97b570f7c","angle","radius","cos","sin","points","reduce","memo","p","ZERO","div","length","x","y","this","magnitudeSquared","magnitude","sqrt","atan2","isInPolygon","polygon","isInside","currentIdx","previousIdx","currentX","currentY","previousX","previousY","equals","other","distanceTo","dx","dy","angleTo","sub","angleBetween","min","max","size","$f2b3fa9969eed8fe$export$412d6621f9b9540a","PI","dot","scale","negate","floor","ceil","round","withMagnitude","newMagnitude","fromPolar","normalize","withAngle","newAngle","rotate","byAngle","lerp","$4e69c769edcf1c3b$var$LABEL_OFFSET","$4e69c769edcf1c3b$var$DEBUG_ARROW_ANGLE","$455d79505ef594cd$export$4d41f66daf6338dc","document","createElement","$455d79505ef594cd$export$a4ecf2d011151542","getContext","$455d79505ef594cd$export$b7952bcb5d125510","body","clientWidth","$455d79505ef594cd$export$5e9f82a2cb459528","clientHeight","$455d79505ef594cd$export$8f869025bba9609b","window","devicePixelRatio","width","height","style","$455d79505ef594cd$export$dd37cca076be4c97","clear","fill","applyFillOptions","ctx","fillRect","canvas","clearRect","beginPath","moveTo","lineTo","arc","startAngle","endAngle","anticlockwise","arcTo","p1","p2","applyStrokeOptions","strokeWidth","stroke","strokeCap","strokeDash","strokeDashOffset","strokeJoin","lineWidth","strokeStyle","lineCap","setLineDash","lineDashOffset","lineJoin","options","fillStyle","applyStrokeAndFillOptions","strokeAndFill","getDebugStrokeOptions","color","debugStroke","fillText","text","position","circle","center","ellipse","radiusX","radiusY","debugLabel","label","debugPointX","debugPointO","debugArrow","start","end","average","vector","arrowLeftPoint","arrowRightPoint","debugVectorAtPoint","base","point","polyLine","i","debugPolygon","debugPolyLine","aabb","opts","debug","origin","rect","left","top","appendChild","$c6aaf09eac67e66a$export$9099ad97b570f7c","right","bottom","contains","intersects","getCenter","Object","freeze","$f6487ea1f1072d82$export$9099ad97b570f7c","insert","_getPosition","boundary","_nextItemIndex","NODE_CAPACITY","_items","subdivisions","_getSubdivisions","Error","remove","index","indexOf","splice","_subdivisions","undefined","forEach","subdivision","findItemsInRect","foundItems","push","findItemsInCircle","getBoundingBox","filter","containsPoint","fromLeftTopRightBottom","getPosition","$13f62dedaed9ea72$var$triangles","tileSize","tileHeight","trianglePoints","iy","pointRow","triangleRow","ix","triangle1","id","triangle2","trianglesById","Map","iy1","ref","ref1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","ref10","ref11","triangle","neighbours","fullTriangle","map","neighbourTriangle","sharedPoints","set","$d8388b0338e164d4$export$9099ad97b570f7c","$13f62dedaed9ea72$var$triangleQuadTree","values","$13f62dedaed9ea72$var$items","console","log","wood"],"version":3,"file":"index.d2273f97.js.map"}