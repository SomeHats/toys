{"mappings":"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","sources":["src/lib/scene/SceneObject.ts","src/lib/easings.ts","src/network/effects/Pulse.ts","src/network/colors.ts","src/network/ConnectionDirection.ts","src/network/ConnectionSet.ts","src/network/networkNodes/Consumer.ts","src/lib/scene/SceneSystem.ts","src/lib/QuadTree.ts","src/network/TravellerFinder.ts","src/network/PathFinder.ts","src/network/networkNodes/Intersection.ts","src/lib/scene/SortOrderProvider.ts","src/lib/scene/Entity.ts","src/network/Traveller.ts","src/pals/makePal.ts","src/lib/geom/Path.ts","src/network/Junction.ts","src/network/Road.ts","src/network/networkNodes/Producer.ts","src/network/network-main.ts","src/lib/scene/Scene.ts"],"sourcesContent":["import { assert } from '../assert';\nimport Scene from './Scene';\n\nconst constructorIdCounts = {} as Record<string, number>;\n\nconst getNextCount = (name: string): string => {\n  if (!constructorIdCounts[name]) constructorIdCounts[name] = 0;\n  return `${name}@${constructorIdCounts[name]++}`;\n};\n\nexport default abstract class SceneObject {\n  id: string = getNextCount(this.constructor.name);\n  private scene: Scene | null = null;\n\n  hasScene(): boolean {\n    return this.scene !== null;\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene must be present');\n    return this.scene;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {}\n  update(delta: number): void {}\n\n  addTo(scene: Scene): this {\n    scene.addChild(this);\n    return this;\n  }\n\n  onAddedToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  onRemovedFromScene() {\n    this.scene = null;\n  }\n\n  getSortOrder(): number {\n    return 0;\n  }\n}\n","import { approxEq } from './utils';\n\n/** n should be between 0 and 1 */\nexport type Easing = (n: number) => number;\n\n// based on https://github.com/servo/servo/blob/0d0cfd030347ab0711b3c0607a9ee07ffe7124cf/components/style/bezier.rs\nclass UnitBezier {\n  private static readonly NEWTON_METHOD_ITERATIONS = 8;\n  private static readonly DEFAULT_EPSILON = 1e-6;\n  private readonly ax: number;\n  private readonly bx: number;\n  private readonly cx: number;\n  private readonly ay: number;\n  private readonly by: number;\n  private readonly cy: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    const cx = 3 * x1;\n    const bx = 3 * (x2 - x1) - cx;\n\n    const cy = 3 * y1;\n    const by = 3 * (y2 - y1) - cy;\n\n    this.ax = 1.0 - cx - bx;\n    this.bx = bx;\n    this.cx = cx;\n    this.ay = 1.0 - cy - by;\n    this.by = by;\n    this.cy = cy;\n  }\n\n  private sampleCurveX(t: number): number {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }\n\n  private sampleCurveY(t: number): number {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }\n\n  private sampleCurveDerivativeX(t: number): number {\n    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n  }\n\n  private solveCurveX(x: number, epsilon: number): number {\n    // Fast path: Use Newton's method.\n    let t = x;\n    for (let i = 0; i < UnitBezier.NEWTON_METHOD_ITERATIONS; i++) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      let dx = this.sampleCurveDerivativeX(t);\n      if (approxEq(dx, 0.0, 1e-6)) {\n        break;\n      }\n      t -= (x2 - x) / dx;\n    }\n\n    // Slow path: Use bisection.\n    let lo = 0;\n    let hi = 1;\n    t = x;\n\n    if (t < lo) {\n      return lo;\n    }\n    if (t > hi) {\n      return hi;\n    }\n\n    while (lo < hi) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      if (x > x2) {\n        lo = t;\n      } else {\n        hi = t;\n      }\n      t = (hi - lo) / 2.0 + lo;\n    }\n\n    return t;\n  }\n\n  solve(x: number, epsilon: number = UnitBezier.DEFAULT_EPSILON): number {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n  }\n}\n\nexport const cubicBezier = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): Easing => {\n  const bezier = new UnitBezier(x1, y1, x2, y2);\n  return (x) => bezier.solve(x);\n};\n\n/**\n * P(t) = (1-t)^3*P0 + 3*t*(1-t)^2*P1 + 3*t^2*(1-t)*P2 + t^3*P3\n * x = 3*t*(1-t)^2*p1x + 3*t^2*(1-t)*p2x + t^3\n * y(t) = 3*t*(1-t)^2*p1y + 3*t^2*(1-t)*p2y + t^3\n *\n *\n * y = 3*u1*(1-x)^2*x + 3*u2*(1-x)*x^2 + x^3\n */\n\n// https://gist.github.com/rezoner/713615dabedb59a15470\n// http://gsgd.co.uk/sandbox/jquery/easing/\nexport const reverse =\n  (easing: (n: number) => number) =>\n  (n: number): number =>\n    easing(1 - n);\n\nexport const linear = (n: number): number => n;\n\nexport const inQuad = (t: number): number => t * t;\n\nexport const outQuad = (t: number): number => t * (2 - t);\n\nexport const inOutQuad = (t: number): number =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\nexport const inCubic = (t: number): number => t * t * t;\n\nexport const outCubic = (t: number): number => --t * t * t + 1;\n\nexport const inOutCubic = (t: number): number =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nexport const inQuart = (t: number): number => t * t * t * t;\n\nexport const outQuart = (t: number): number => 1 - --t * t * t * t;\n\nexport const inOutQuart = (t: number): number =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\nexport const inQuint = (t: number): number => t * t * t * t * t;\n\nexport const outQuint = (t: number): number => 1 + --t * t * t * t * t;\n\nexport const inOutQuint = (t: number): number =>\n  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nexport const inSine = (t: number): number =>\n  -1 * Math.cos((t / 1) * (Math.PI * 0.5)) + 1;\n\nexport const outSine = (t: number): number =>\n  Math.sin((t / 1) * (Math.PI * 0.5));\n\nexport const inOutSine = (t: number): number =>\n  (-1 / 2) * (Math.cos(Math.PI * t) - 1);\n\nexport const inExpo = (t: number): number =>\n  t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n\nexport const outExpo = (t: number): number =>\n  t == 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n\nexport const inOutExpo = (t: number): number => {\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if ((t /= 1 / 2) < 1) return (1 / 2) * Math.pow(2, 10 * (t - 1));\n  return (1 / 2) * (-Math.pow(2, -10 * --t) + 2);\n};\n\nexport const inCirc = (t: number): number => -1 * (Math.sqrt(1 - t * t) - 1);\n\nexport const outCirc = (t: number): number => Math.sqrt(1 - (t = t - 1) * t);\n\nexport const inOutCirc = (t: number): number => {\n  if ((t /= 1 / 2) < 1) return (-1 / 2) * (Math.sqrt(1 - t * t) - 1);\n  return (1 / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1);\n};\n\nexport const inElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return -(\n    a *\n    Math.pow(2, 10 * (t -= 1)) *\n    Math.sin(((t - s) * (2 * Math.PI)) / p)\n  );\n};\n\nexport const outElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return a * Math.pow(2, -10 * t) * Math.sin(((t - s) * (2 * Math.PI)) / p) + 1;\n};\n\nexport const inOutElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if ((t /= 1 / 2) == 2) return 1;\n  if (!p) p = 0.3 * 1.5;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  if (t < 1)\n    return (\n      -0.5 *\n      (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p))\n    );\n  return (\n    a *\n      Math.pow(2, -10 * (t -= 1)) *\n      Math.sin(((t - s) * (2 * Math.PI)) / p) *\n      0.5 +\n    1\n  );\n};\n\nexport const inBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    return 1 * t * t * ((s + 1) * t - s);\n  };\n\nexport const outBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    t = t - 1;\n    return 1 * (t * t * ((s + 1) * t + s) + 1);\n  };\n\nexport const inOutBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    if ((t /= 1 / 2) < 1)\n      return (1 / 2) * (t * t * (((s *= 1.525) + 1) * t - s));\n    return (1 / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  };\n\nexport const inBounce = (t: number): number => {\n  return 1 - outBounce(1 - t);\n};\n\nexport const outBounce = (t: number): number => {\n  if ((t /= 1) < 1 / 2.75) {\n    return 7.5625 * t * t;\n  } else if (t < 2 / 2.75) {\n    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n  } else if (t < 2.5 / 2.75) {\n    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n  } else {\n    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n  }\n};\n\nexport const inOutBounce = (t: number): number => {\n  if (t < 1 / 2) return inBounce(t * 2) * 0.5;\n  return outBounce(t * 2 - 1) * 0.5 + 0.5;\n};\n","import Color from 'color';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport Circle from '../../lib/geom/Circle';\nimport { linear, Easing } from '../../lib/easings';\nimport { lerp } from '../../lib/utils';\n\ntype PulseOptions = {\n  x: number;\n  y: number;\n  startRadius: number;\n  endRadius: number;\n  duration: number;\n  color: Color;\n  easeRadius?: Easing;\n  easeOpacity?: Easing;\n  removeOnComplete?: boolean;\n};\n\nexport default class Pulse extends SceneObject {\n  _circle: Circle;\n  _startRadius: number;\n  _endRadius: number;\n  _duration: number;\n  _color: Color;\n  _progress: number;\n  _easeRadius: Easing;\n  _easeOpacity: Easing;\n  _removeOnComplete: boolean;\n\n  constructor({\n    x,\n    y,\n    startRadius,\n    endRadius,\n    duration,\n    color,\n    easeRadius = linear,\n    easeOpacity = linear,\n    removeOnComplete = false,\n  }: PulseOptions) {\n    super();\n    this._circle = new Circle(x, y, startRadius);\n    this._startRadius = startRadius;\n    this._endRadius = endRadius;\n    this._duration = duration;\n    this._color = color;\n    this._progress = 0;\n    this._easeRadius = easeRadius;\n    this._easeOpacity = easeOpacity;\n    this._removeOnComplete = removeOnComplete;\n  }\n\n  update(deltaTime: number) {\n    const deltaProgress = deltaTime / this._duration;\n    this._progress = Math.min(1, this._progress + deltaProgress);\n    this._circle = this._circle.withRadius(\n      lerp(\n        this._startRadius,\n        this._endRadius,\n        this._easeRadius(this._progress),\n      ),\n    );\n\n    if (this._progress === 1 && this._removeOnComplete) {\n      this.getScene().removeChild(this);\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    const opacity = this._easeOpacity(this._progress);\n    ctx.fillStyle = this._color.fade(opacity).toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n  }\n}\n","import Color from 'color';\n\n// https://coolors.co/f8ffe5-06d6a0-1b9aaa-ef476f-ffc43d\nexport const LIGHT_BG = new Color('#F8FFE5');\nexport const TEAL = new Color('#06D6A0');\nexport const BLUE = new Color('#1B9AAA');\nexport const RED = new Color('#EF476F');\nexport const YELLOW = new Color('#FFC43D');\n","enum ConnectionDirection {\n  IN = 'in',\n  OUT = 'out',\n}\n\nexport default ConnectionDirection;\n","import { sample } from '../lib/utils';\nimport Road from './Road';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class ConnectionSet {\n  incoming: Road[] = [];\n  outgoing: Road[] = [];\n\n  add(target: Road, direction: ConnectionDirection) {\n    switch (direction) {\n      case ConnectionDirection.IN:\n        this.addIncoming(target);\n        break;\n      case ConnectionDirection.OUT:\n        this.addOutgoing(target);\n        break;\n      default:\n        throw new Error(`unknow connection direction ${direction}`);\n    }\n  }\n\n  addIncoming(target: Road) {\n    this.incoming.push(target);\n  }\n\n  addOutgoing(target: Road) {\n    this.outgoing.push(target);\n  }\n\n  sampleIncoming(): Road {\n    return sample(this.incoming);\n  }\n\n  sampleOutgoing(): Road {\n    return sample(this.outgoing);\n  }\n}\n","// @flow\nimport { assert } from '../../lib/assert';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { inBack, reverse, linear } from '../../lib/easings';\nimport { constrain, mapRange } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { RED } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 1000;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst PULSE_RADIUS = 25;\n\nconst CLOCK_FADE_DURATION = 150;\nconst PULSE_DURATION = 500;\n\nconst MAIN_COLOR = RED.lighten(0.2).desaturate(0.5);\nconst CLOCK_COLOR = RED.darken(0.2);\nconst PULSE_COLOR = RED.lighten(0.2).fade(0.4);\n\nexport default class Consumer extends SceneObject implements NetworkNode {\n  isDestination = true;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number = 0;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return this._timer >= this._cooldown;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return [this];\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  consumeTraveller() {\n    assert(this.canConsumeTraveller, 'must be ready to consumer traveller');\n    this._resetTimer();\n    this._pulse();\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius * progress,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        endRadius: RADIUS,\n        startRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: inBack(4),\n        easeOpacity: reverse(linear),\n        removeOnComplete: true,\n      }),\n    );\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport Scene from './Scene';\n\nconst DEFAULT_NAME = '$$AbstractSceneSystem$$';\n\nexport default abstract class SceneSystem {\n  static systemName = DEFAULT_NAME;\n  private scene: Scene | null = null;\n\n  constructor() {\n    assert(\n      this.constructor !== SceneSystem,\n      'SceneSystem is an abstract class that must be extended',\n    );\n    assert(\n      (this.constructor as any).systemName !== DEFAULT_NAME,\n      'classes extending SceneSystem must override SceneSystem.systemName',\n    );\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene is required');\n    return this.scene;\n  }\n\n  afterAddToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeRemoveFromScene(scene: Scene) {\n    this.scene = null;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  beforeDraw(ctx: CanvasRenderingContext2D, time: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterDraw(ctx: CanvasRenderingContext2D, time: number) {}\n}\n","import AABB from './geom/AABB';\nimport Circle from './geom/Circle';\nimport Vector2 from './geom/Vector2';\n\ntype Subdivisions<T> = [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>];\n\nexport default class QuadTree<T> {\n  static NODE_CAPACITY = 4;\n\n  boundary: AABB;\n  _items: (T | void)[] = [];\n  _nextItemIndex: number = 0;\n  _subdivisions: null | Subdivisions<T> = null;\n  _getPosition: (item: T) => Vector2;\n\n  constructor(boundary: AABB, getPosition: (item: T) => Vector2) {\n    this.boundary = boundary;\n    this._getPosition = getPosition;\n  }\n\n  // debugDraw(color: string) {\n  //   this.boundary.debugDraw(color);\n  //   if (this._subdivisions) {\n  //     this._subdivisions.forEach(subdivision => subdivision.debugDraw(color));\n  //   }\n  // }\n\n  insert(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    if (this._nextItemIndex < QuadTree.NODE_CAPACITY) {\n      this._items[this._nextItemIndex] = item;\n      this._nextItemIndex++;\n      return true;\n    }\n\n    const subdivisions = this._getSubdivisions();\n\n    if (subdivisions[0].insert(item)) return true;\n    if (subdivisions[1].insert(item)) return true;\n    if (subdivisions[2].insert(item)) return true;\n    if (subdivisions[3].insert(item)) return true;\n\n    throw new Error('Couldnt insert item');\n  }\n\n  remove(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    const index = this._items.indexOf(item);\n    if (index !== -1) {\n      this._items.splice(index, 1);\n      this._nextItemIndex--;\n      return true;\n    }\n\n    const subdivisions = this._subdivisions;\n    if (subdivisions) {\n      if (subdivisions[0].remove(item)) return true;\n      if (subdivisions[1].remove(item)) return true;\n      if (subdivisions[2].remove(item)) return true;\n      if (subdivisions[3].remove(item)) return true;\n    }\n\n    return false;\n  }\n\n  clear() {\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      this._items[i] = undefined;\n      this._nextItemIndex = 0;\n    }\n\n    if (this._subdivisions) {\n      this._subdivisions.forEach(subdivision => subdivision.clear());\n    }\n  }\n\n  findItemsInRect(rect: AABB): T[] {\n    const foundItems = [] as Array<T>;\n\n    if (!this.boundary.intersects(rect)) return foundItems;\n\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      const item = this._items[i];\n      if (item == null) continue;\n      const point = this._getPosition(item);\n      if (rect.contains(point)) foundItems.push(item);\n    }\n\n    const subdivisions = this._subdivisions;\n    if (!subdivisions) return foundItems;\n\n    if (subdivisions[0].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[0].findItemsInRect(rect));\n    }\n    if (subdivisions[1].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[1].findItemsInRect(rect));\n    }\n    if (subdivisions[2].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[2].findItemsInRect(rect));\n    }\n    if (subdivisions[3].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[3].findItemsInRect(rect));\n    }\n\n    return foundItems;\n  }\n\n  findItemsInCircle(circle: Circle): T[] {\n    return this.findItemsInRect(circle.getBoundingBox()).filter(item =>\n      circle.containsPoint(this._getPosition(item)),\n    );\n  }\n\n  _getSubdivisions(): Subdivisions<T> {\n    if (this._subdivisions) return this._subdivisions;\n\n    const center = this.boundary.getCenter();\n    const subdivisions: Subdivisions<T> = [\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          this.boundary.top,\n          center.x,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          this.boundary.top,\n          this.boundary.right,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          center.y,\n          center.x,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          center.y,\n          this.boundary.right,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n    ];\n\n    this._subdivisions = subdivisions;\n    return subdivisions;\n  }\n}\n","// @flow\nimport Scene from '../lib/scene/Scene';\nimport SceneSystem from '../lib/scene/SceneSystem';\nimport QuadTree from '../lib/QuadTree';\nimport Circle from '../lib/geom/Circle';\nimport AABB from '../lib/geom/AABB';\nimport Traveller from './Traveller';\n\nexport default class TravellerFinder extends SceneSystem {\n  static systemName = 'TravellerFinder';\n\n  _quadTree!: QuadTree<Traveller>;\n\n  removeTraveller(traveller: Traveller) {\n    this._quadTree.remove(traveller);\n  }\n\n  afterAddToScene(scene: Scene) {\n    super.afterAddToScene(scene);\n    this._quadTree = new QuadTree(\n      AABB.fromLeftTopRightBottom(0, 0, scene.width, scene.height),\n      traveller => traveller.position,\n    );\n  }\n\n  beforeUpdate() {\n    const scene = this.getScene();\n    this._quadTree.clear();\n    scene.children.forEach(child => {\n      if (child instanceof Traveller) {\n        this._quadTree.insert(child);\n      }\n    });\n    // this._quadTree.debugDraw('red');\n  }\n\n  findTravellersInCircle(circle: Circle) {\n    return this._quadTree.findItemsInCircle(circle);\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Road from './Road';\nimport { NetworkNode } from './networkNodes/NetworkNode';\n\nconst PathFinder = {\n  getNextRoad(initialNode: NetworkNode, destinationNode: NetworkNode): Road {\n    const remainingNodes = new Set(initialNode.getAllReachableNodes());\n    remainingNodes.add(initialNode);\n    assert(\n      remainingNodes.has(destinationNode),\n      'destination must be reachable',\n    );\n    const bestCosts = new Map();\n    const prevRoads = new Map();\n\n    bestCosts.set(initialNode, 0);\n\n    while (remainingNodes.size) {\n      const { node, cost } = PathFinder._nodeWithShortestDistance(\n        remainingNodes,\n        bestCosts,\n      );\n      remainingNodes.delete(node);\n\n      if (node === destinationNode) {\n        return PathFinder._nextRoadFromRoute(\n          prevRoads,\n          initialNode,\n          destinationNode,\n        );\n      }\n\n      PathFinder._updateNeighbours(node, bestCosts, cost, prevRoads);\n    }\n\n    throw new Error('unreachable i hope');\n  },\n\n  _nodeWithShortestDistance(\n    nodes: Set<NetworkNode>,\n    costs: Map<NetworkNode, number>,\n  ): { node: NetworkNode; cost: number } {\n    let bestCost = Infinity;\n    let bestNode = null;\n\n    nodes.forEach(node => {\n      const cost = costs.get(node);\n      if (cost != null && cost <= bestCost) {\n        bestCost = cost;\n        bestNode = node;\n      }\n    });\n\n    assert(bestNode, 'node must be found');\n    return { node: bestNode, cost: bestCost };\n  },\n  _updateNeighbours(\n    node: NetworkNode,\n    bestCosts: Map<NetworkNode, number>,\n    cost: number,\n    prevRoads: Map<NetworkNode, Road>,\n  ) {\n    node.outgoingConnections.forEach(road => {\n      const nextNode = road.to;\n      const nextNodeCost = bestCosts.get(nextNode);\n      const altNextNodeCost = cost + road.expectedTimeFromStartToEnd;\n      if (nextNodeCost == null || altNextNodeCost <= nextNodeCost) {\n        bestCosts.set(nextNode, altNextNodeCost);\n        prevRoads.set(nextNode, road);\n      }\n    });\n  },\n  _nextRoadFromRoute(\n    prevRoads: Map<NetworkNode, Road>,\n    start: NetworkNode,\n    finish: NetworkNode,\n  ): Road {\n    let node = finish;\n    while (prevRoads.has(node)) {\n      const road = prevRoads.get(node);\n      assert(road, 'road must exist');\n      node = road.from;\n      if (node === start) return road;\n    }\n\n    throw new Error('prev road must be found');\n  },\n};\n\nexport default PathFinder;\n","// @flow\nimport { assert } from '../../lib/assert';\nimport Vector2 from '../../lib/geom/Vector2';\nimport { uniq, flatten } from '../../lib/utils';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport PathFinder from '../PathFinder';\nimport Road from '../Road';\nimport Traveller from '../Traveller';\nimport { NetworkNode } from './NetworkNode';\n\nexport default class Intersection implements NetworkNode {\n  isDestination = false;\n  position: Vector2;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number) {\n    this.position = new Vector2(x, y);\n  }\n\n  get incomingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.outgoing;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return true;\n  }\n\n  consumeTraveller(traveller: Traveller) {\n    const destination = traveller.destination;\n    assert(destination, 'traveller must have destination');\n\n    const nextRoad = PathFinder.getNextRoad(this, destination);\n    assert(\n      this.outgoingConnections.includes(nextRoad),\n      'nextRoad must be from this intersection',\n    );\n\n    traveller.removeFromCurrentRoad();\n    nextRoad.addTravellerAtStart(traveller);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(): Vector2 {\n    return this.position;\n  }\n\n  getClosestOutgoingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.outgoingConnections.forEach(road => {\n      const traveller = road.getTravellerAfterPosition(-1);\n      if (traveller && traveller.positionOnCurrentRoad < shortestDistance) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.positionOnCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getClosestIncomingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.incomingConnections.forEach(road => {\n      const traveller = road.getTravellerBeforePosition(road.length);\n      if (\n        traveller &&\n        traveller.distanceToEndOfCurrentRoad < shortestDistance\n      ) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.distanceToEndOfCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n}\n","import Component from './Component';\nimport Entity from './Entity';\n\nexport default class SortOrderProvider extends Component {\n  constructor(\n    entity: Entity,\n    private getSortOrderFn: (entity: Entity) => number,\n  ) {\n    super(entity);\n  }\n\n  getSortOrder(): number {\n    return this.getSortOrderFn(this.entity);\n  }\n}\n","import SceneObject from './SceneObject';\nimport Component from './Component';\nimport { assert } from '../assert';\nimport SortOrderProvider from './SortOrderProvider';\nimport Scene from './Scene';\n\ntype ComponentClass<T extends Component, Args extends unknown[]> = {\n  name: string;\n  new (entity: Entity, ...args: Args): T;\n};\n\nexport default class Entity extends SceneObject {\n  private componentInstances = new Map<\n    ComponentClass<Component, any>,\n    Component\n  >();\n\n  addComponent<T extends Component, Args extends unknown[]>(\n    component: ComponentClass<T, Args>,\n    ...args: Args\n  ): T {\n    assert(\n      !this.componentInstances.has(component),\n      `component instance ${component.name} already exists`,\n    );\n    const instance = new component(this, ...args);\n    this.componentInstances.set(component, instance);\n    return instance;\n  }\n\n  hasComponent<T extends Component>(\n    component: ComponentClass<T, any[]>,\n  ): boolean {\n    return this.componentInstances.has(component);\n  }\n\n  getComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.componentInstances.get(component);\n    assert(instance, `no instance for ${component.name} exists`);\n    assert(instance instanceof component, 'wrong instance type');\n    return instance;\n  }\n\n  removeComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.getComponent(component);\n    this.componentInstances.delete(component);\n    instance.onRemove();\n    return instance;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeDraw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.draw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterDraw(ctx, elapsedTime);\n    }\n  }\n  update(delta: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeUpdate(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.update(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterUpdate(delta);\n    }\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    for (const component of this.componentInstances.values()) {\n      component.onAddedToScene(scene);\n    }\n  }\n\n  onRemovedFromScene() {\n    const scene = this.getScene();\n    super.onRemovedFromScene();\n    for (const component of this.componentInstances.values()) {\n      component.onRemovedFromScene(scene);\n    }\n  }\n\n  getSortOrder() {\n    if (this.hasComponent(SortOrderProvider)) {\n      return this.getComponent(SortOrderProvider).getSortOrder();\n    } else {\n      return super.getSortOrder();\n    }\n  }\n}\n","import { assert } from '../lib/assert';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { outBack, inBack } from '../lib/easings';\nimport { sample, constrain, mapRange, random } from '../lib/utils';\nimport TravellerFinder from './TravellerFinder';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Intersection from './networkNodes/Intersection';\nimport Road from './Road';\nimport Entity from '../lib/scene/Entity';\nimport { makeAbsolutePal } from '../pals/makePal';\nimport { PalAbsoluteController } from '../pals/PalController';\n\n// const TRAVELLER_COLOR = BLUE.fade(0.4);\n// const TRAVELLER_RADIUS = 14;\nconst MIN_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MAX_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MIN_TRAVELLER_SAFE_RADIUS = 30;\nconst MAX_TRAVELLER_SAFE_RADIUS = 30;\nconst NEARBY_RADIUS = 200;\n\nconst INITIAL_SPEED = 5;\nconst MAX_SPEED = 80;\nconst ACCELERATION = 200;\nconst DECELERATION = -200;\nconst ROAD_END_OVERSHOOT = 0;\n\nconst PATIENCE = 1500;\nconst FORCE_ACCELERATE_DURATION = 100;\n\nconst ENTER_DURATION = 400;\nconst EXIT_DURATION = 400;\n\nconst enterEase = outBack(3);\nconst exitEase = inBack(3);\n\nenum StopReason {\n  STOPPED_FOR_DESTINATION = 'STOPPED_FOR_DESTINATION',\n  STOPPED_FOR_TRAFFIC_IN_FRONT = 'STOPPED_FOR_TRAFFIC_IN_FRONT',\n  STOPPED_FOR_TRAFFIC_NEARBY = 'STOPPED_FOR_TRAFFIC_NEARBY',\n}\n\nexport default class Traveller extends SceneObject {\n  static MAX_SPEED = MAX_SPEED;\n  static StopReason = StopReason;\n\n  comfortableRadius = random(\n    MIN_TRAVELLER_COMFORTABLE_RADIUS,\n    MAX_TRAVELLER_COMFORTABLE_RADIUS,\n  );\n  safeRadius = random(MIN_TRAVELLER_SAFE_RADIUS, MAX_TRAVELLER_SAFE_RADIUS);\n  _currentRoad: Road | null = null;\n  _destination: NetworkNode | null = null;\n  _positionOnCurrentRoad: number = 0;\n  _speed: number = INITIAL_SPEED;\n  _age: number = 0;\n  _exitStartedAt: number | null = null;\n  _stoppedTime: number = 0;\n  _forceAccelerateTimer: number = 0;\n  _stopReason: StopReason | null = null;\n  _stoppedFor: Traveller[] = [];\n  _pal: Entity | null = null;\n\n  get currentRoad(): Road | null {\n    return this._currentRoad;\n  }\n\n  get position(): Vector2 {\n    assert(this._currentRoad, 'currentRoad must be defined');\n    return this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad);\n  }\n\n  // get predictedPositionInDirectionOfTravel(): Vector2 {\n  //   assert(this._currentRoad, 'currentRoad must be defined');\n  //   return this._getPredictedPointForPosition(\n  //     this._currentRoad,\n  //     this._positionOnCurrentRoad + 1,\n  //   );\n  // }\n\n  get predictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition);\n  }\n\n  get predictedStopArea(): Circle {\n    const center = this.predictedStopPoint;\n    return new Circle(center.x, center.y, this.safeRadius);\n  }\n\n  get potentialNextPredictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition + 1);\n  }\n\n  get positionOnCurrentRoad(): number {\n    return this._positionOnCurrentRoad;\n  }\n\n  get distanceToEndOfCurrentRoad(): number {\n    assert(this._currentRoad, 'traveller is not on a road');\n    return this._currentRoad.length - this._positionOnCurrentRoad;\n  }\n\n  get destination(): NetworkNode | null {\n    return this._destination;\n  }\n\n  get speed(): number {\n    return this._speed;\n  }\n\n  get isStopped(): boolean {\n    return this.speed === 0;\n  }\n\n  get stoppedTime(): number {\n    return this._stoppedTime;\n  }\n\n  get stopReason(): StopReason | null {\n    return this._stopReason;\n  }\n\n  isStoppedFor(other: Traveller): boolean {\n    return this._stoppedFor.includes(other);\n  }\n\n  onAddedToRoad(road: Road) {\n    this._currentRoad = road;\n    this._positionOnCurrentRoad = 0;\n    if (!this._destination) {\n      this._pickDestination();\n    }\n  }\n\n  onRemovedFromRoad() {\n    this.getScene()\n      .getSystem(TravellerFinder)\n      .removeTraveller(this);\n    this._currentRoad = null;\n  }\n\n  onRemovedFromScene() {\n    this.removeFromCurrentRoad();\n  }\n\n  removeFromCurrentRoad() {\n    if (this._currentRoad) this._currentRoad.removeTraveller(this);\n  }\n\n  update(dtMilliseconds: number) {\n    this._age += dtMilliseconds;\n    this._stopReason = null;\n    this._stoppedFor = [];\n\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._move(dtMilliseconds, currentRoad);\n\n    const pal = this._getPal();\n    pal\n      .getComponent(PalAbsoluteController)\n      .setPosition(\n        this.position,\n        currentRoad.getAngleAtPosition(this._positionOnCurrentRoad),\n        dtMilliseconds / 1000,\n      );\n    pal.update(dtMilliseconds);\n\n    this._getEnterTransitionScale();\n    // if (window.debugDraw) this._debugDraw();\n\n    this._checkAtEndOfRoad(currentRoad);\n    this._checkExit();\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number) {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._getPal().draw(ctx, elapsedTime);\n\n    // const position = this.position;\n    // const scale =\n    //   this._getEnterTransitionScale() * this._getExitTransitionScale();\n\n    // ctx.beginPath();\n    // ctx.fillStyle = TRAVELLER_COLOR.toString();\n    // ShapeHelpers.circle(ctx, position.x, position.y, TRAVELLER_RADIUS * scale);\n    // ctx.fill();\n  }\n\n  getSortOrder(): number {\n    return this.position.y;\n  }\n\n  get _isExiting(): boolean {\n    return this._exitStartedAt !== null;\n  }\n\n  _getPal(): Entity {\n    if (!this._pal) {\n      this._pal = makeAbsolutePal(this.position);\n    }\n\n    return this._pal;\n  }\n\n  // _debugDraw() {\n  //   const currentRoad = this._currentRoad;\n  //   if (!currentRoad) return;\n\n  //   const predictedStopPoint = this.predictedStopPoint;\n  //   new Circle(\n  //     this.position.x,\n  //     this.position.y,\n  //     this.comfortableRadius\n  //   ).debugDraw(\"rgba(0, 255, 0, 0.4)\");\n  //   new Circle(this.position.x, this.position.y, this.safeRadius).debugDraw(\n  //     this._forceAccelerateTimer ? \"cyan\" : \"red\"\n  //   );\n  //   predictedStopPoint.debugDraw(\"lime\");\n  //   this.predictedStopArea.debugDraw(\"rgba(255, 0, 255, 0.5)\");\n\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.fillText(\n  //     `${this.id} ${Math.round(this._stoppedTime)}`,\n  //     this.position.x,\n  //     this.position.y\n  //   );\n  // }\n\n  _getEnterTransitionScale() {\n    return enterEase(\n      constrain(0, 1, mapRange(0, ENTER_DURATION, 0, 1, this._age)),\n    );\n  }\n\n  _getExitTransitionScale() {\n    if (this._exitStartedAt === null) return 1;\n    return (\n      1 -\n      exitEase(\n        constrain(\n          0,\n          1,\n          mapRange(\n            this._exitStartedAt,\n            this._exitStartedAt + EXIT_DURATION,\n            0,\n            1,\n            this._age,\n          ),\n        ),\n      )\n    );\n  }\n\n  _getPredictedStopPositionIfDecelerating(): number {\n    const timeToStop = -this._speed / DECELERATION;\n    return (\n      this._positionOnCurrentRoad +\n      this._speed * timeToStop +\n      0.5 * DECELERATION * timeToStop * timeToStop\n    );\n  }\n\n  _getPredictedPointForPosition(currentRoad: Road, position: number): Vector2 {\n    if (position <= currentRoad.length) {\n      return currentRoad.getPointAtPosition(position);\n    }\n\n    const overshoot = position - currentRoad.length;\n    const overshootAngle = currentRoad.getAngleAtPosition(currentRoad.length);\n    return Vector2.fromPolar(overshootAngle, overshoot).add(currentRoad.end);\n  }\n\n  _pickDestination() {\n    if (!this._currentRoad) return;\n    const potentialDestinations = this._currentRoad\n      .getAllReachableNodes()\n      .filter(node => node.isDestination);\n    const destination = sample(potentialDestinations);\n    this._destination = destination;\n  }\n\n  _move(dtMilliseconds: number, currentRoad: Road) {\n    const dtSeconds = dtMilliseconds / 1000;\n\n    this._forceAccelerateTimer = constrain(\n      0,\n      FORCE_ACCELERATE_DURATION,\n      this._forceAccelerateTimer - dtMilliseconds,\n    );\n\n    if (\n      this._forceAccelerateTimer <= 0 &&\n      this._shouldDecelerate(currentRoad)\n    ) {\n      this._accelerate(DECELERATION, dtSeconds, currentRoad);\n    } else {\n      this._accelerate(ACCELERATION, dtSeconds, currentRoad);\n    }\n\n    if (this._speed === 0) {\n      this._stoppedTime += dtMilliseconds;\n    } else {\n      this._stoppedTime = 0;\n    }\n  }\n\n  _shouldDecelerate(currentRoad: Road): boolean {\n    const predictedStopPosition = this._getPredictedStopPositionIfDecelerating();\n    if (\n      currentRoad.to === this._destination &&\n      currentRoad.length + ROAD_END_OVERSHOOT < predictedStopPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_DESTINATION;\n      return true;\n    }\n\n    const nextTravellerOnRoad = currentRoad.getTravellerAfterPosition(\n      this._positionOnCurrentRoad,\n    );\n\n    const safeStopAheadPosition =\n      predictedStopPosition + this.comfortableRadius;\n\n    if (\n      nextTravellerOnRoad &&\n      nextTravellerOnRoad.positionOnCurrentRoad < safeStopAheadPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n      this._stoppedFor.push(nextTravellerOnRoad);\n      return true;\n    }\n\n    if (currentRoad.to instanceof Intersection) {\n      const intersection = currentRoad.to;\n      const outgoingTraveller = intersection.getClosestOutgoingTraveller();\n      if (outgoingTraveller) {\n        const outgoingTravellerPosition =\n          currentRoad.length + outgoingTraveller.positionOnCurrentRoad;\n\n        if (outgoingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(outgoingTraveller);\n          return true;\n        }\n      }\n\n      const incomingTraveller = intersection.getClosestIncomingTraveller();\n      if (incomingTraveller && incomingTraveller !== this) {\n        const incomingTravellerPosition =\n          currentRoad.length - incomingTraveller.distanceToEndOfCurrentRoad;\n        if (incomingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(incomingTraveller);\n          return true;\n        }\n      }\n    }\n\n    if (this._shouldDecelerateForNearbyTravellers(currentRoad)) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_NEARBY;\n      return true;\n    }\n\n    // const currentPoint = this.position;\n    // const currentSafeCircle = new Circle(\n    //   currentPoint.x,\n    //   currentPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     currentSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    // const predictedStopPoint = this._getPredictedStopPointIfDecelerating(\n    //   currentRoad,\n    // );\n    // const predictedSafeCircle = new Circle(\n    //   predictedStopPoint.x,\n    //   predictedStopPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     predictedSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    return false;\n  }\n\n  _shouldDecelerateForNearbyTravellers(currentRoad: Road): boolean {\n    const travellerFinder = this.getScene().getSystem(TravellerFinder);\n    const stopArea = this.predictedStopArea;\n    const stopPoint = stopArea.center;\n    const nextStopPoint = this.potentialNextPredictedStopPoint;\n    const searchArea = stopArea.withRadius(NEARBY_RADIUS);\n    const nearbyTravellers = travellerFinder.findTravellersInCircle(searchArea);\n\n    for (const other of nearbyTravellers) {\n      // cannot crash into self\n      if (other === this) continue;\n\n      // if we both started breaking now, we would be a safe distance so we're fine\n      const otherStopArea = other.predictedStopArea;\n      const otherStopPoint = otherStopArea.center;\n      if (!stopArea.intersectsCircle(otherStopArea)) continue;\n\n      // currently we think other will stop at the center of otherStopArea.\n      // otherNextStopPoint is one pixel further forward based other's current\n      // heading\n      const otherNextStopPoint = other.potentialNextPredictedStopPoint;\n\n      // if we're moving away from each other, everything is fine:\n      const currentStopDistance = stopPoint.distanceTo(otherStopArea.center);\n      const nextStopDistance = nextStopPoint.distanceTo(otherNextStopPoint);\n      if (nextStopDistance > currentStopDistance) continue;\n\n      // who is moving in a direction that's headed more towards the other's\n      // stop position? if they're moving towards me but i'm moving more\n      // orthagonally relative to them, they should slow down\n      const approachAmount = stopPoint.distanceTo(otherNextStopPoint);\n      const otherApproachAmount = otherStopPoint.distanceTo(nextStopPoint);\n      if (approachAmount < otherApproachAmount) {\n        continue;\n      }\n\n      // so we know we're moving towards them faster than they're moving\n      // towards us, but how much? If it's barely any and we're not already too\n      // close to them, we could just keep going\n      if (\n        approachAmount - otherApproachAmount <\n        0.15\n        // approachAmount > this.safeRadius * 0.8\n      ) {\n        continue;\n      }\n\n      // if there's a clash... just randomly tie-break\n      if (approachAmount === otherApproachAmount) {\n        return Math.random() < 0.5;\n      }\n\n      // if we've been waiting around for fuckin ever just slam that fuckin\n      // pedal to the floor like ugh (in reality just nudge forward a little)\n      // (unless the other one is stopped to cus otherwise we'll just crash)\n      if (this._stoppedTime > PATIENCE && !other.isStopped) {\n        this._forceAcceleration();\n        return false;\n      }\n\n      // attempt to break deadlocks. i guess this is the equivalent of 'other'\n      // waving at the current traveller to continue\n      if (other.isStoppedFor(this)) continue;\n\n      this._stoppedFor.push(other);\n    }\n\n    if (this._stoppedFor.length) return true;\n\n    return false;\n  }\n\n  // _shouldDecelerateForTravellersInCircle(currentRoad: Road, circle: Circle) {\n  //   const travellerFinder = this.getScene().getSystem(TravellerFinder);\n  //   const overlappingTravellers = travellerFinder.findTravellersInCircle(\n  //     circle,\n  //   );\n\n  //   const currentPosition = this.position;\n  //   const nextPosition = this.predictedPositionInDirectionOfTravel;\n\n  //   const clashingTravellers = overlappingTravellers.filter(other => {\n  //     if (other === this) return false;\n  //     if (other.currentRoad === currentRoad) return false;\n\n  // const currentDistance = currentPosition.distanceTo(other.position);\n  // const nextDistance = nextPosition.distanceTo(other.position);\n\n  // const isGettingCloser = nextDistance < currentDistance;\n  // if (!isGettingCloser) return false;\n\n  // const otherNextPosition = other.predictedPositionInDirectionOfTravel;\n  // const otherNextDistance = currentPosition.distanceTo(otherNextPosition);\n  // const thisMoveDelta = nextDistance - currentDistance;\n  // const otherMoveDelta = otherNextDistance - currentDistance;\n  // if (thisMoveDelta < otherMoveDelta) return true;\n\n  // if (this.isStopped && !other.isStopped) return true;\n\n  // if (this.isStopped && other.isStopped) {\n  //   if (this.stoppedTime === other.stoppedTime && this.id < other.id)\n  //     return false;\n  //   if (this.stoppedTime < other.stoppedTime) return false;\n  // }\n\n  //     return true;\n  //   });\n\n  //   return clashingTravellers.length > 0;\n  // }\n\n  _forceAcceleration() {\n    this._forceAccelerateTimer = FORCE_ACCELERATE_DURATION;\n  }\n\n  _accelerate(acceleration: number, dtSeconds: number, currentRoad: Road) {\n    const lastSpeed = this._speed;\n    this._speed = constrain(\n      0,\n      MAX_SPEED,\n      this._speed + acceleration * dtSeconds,\n    );\n    const avgSpeed = (lastSpeed + this._speed) / 2;\n    this._positionOnCurrentRoad = constrain(\n      0,\n      currentRoad.length,\n      this._positionOnCurrentRoad + avgSpeed * dtSeconds,\n    );\n  }\n\n  _checkAtEndOfRoad(currentRoad: Road) {\n    if (this._positionOnCurrentRoad === currentRoad.length) {\n      if (this._isExiting) return;\n      this._onReachEndOfCurrentRoad(currentRoad);\n    }\n  }\n\n  _checkExit() {\n    if (this._isExiting) {\n      assert(this._exitStartedAt);\n      if (this._age >= this._exitStartedAt + EXIT_DURATION) {\n        this._onExit();\n      }\n    }\n  }\n\n  _onReachEndOfCurrentRoad(currentRoad: Road) {\n    const nextNode = currentRoad.to;\n    const destination = this._destination;\n    if (nextNode.canConsumeTraveller) {\n      nextNode.consumeTraveller(this);\n      if (nextNode === destination) {\n        this._onReachDestination();\n      }\n    }\n  }\n\n  _onReachDestination() {\n    this._exit();\n  }\n\n  _onExit() {\n    this.getScene().removeChild(this);\n  }\n\n  _exit() {\n    this._exitStartedAt = this._age;\n  }\n}\n","import Entity from '../lib/scene/Entity';\nimport { PalTargetController, PalAbsoluteController } from './PalController';\nimport Vector2 from '../lib/geom/Vector2';\nimport { generateRandomPalConfig } from './PalConfig';\nimport PalGeom from './PalGeom';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport PalRenderer from './PalRenderer';\n\nexport function makeTargetPal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalTargetController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n\nexport function makeAbsolutePal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalAbsoluteController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n","// @flow\nimport { assert } from '../assert';\nimport { constrain, compact } from '../utils';\nimport Circle from './Circle';\nimport Vector2 from './Vector2';\nimport StraightPathSegment from './StraightPathSegment';\nimport CirclePathSegment from './CirclePathSegment';\nimport Line2 from './Line2';\n\nexport interface PathSegment {\n  getStart(): Vector2;\n  getEnd(): Vector2;\n  getLength(): number;\n  getPointAtPosition(position: number): Vector2;\n  getAngleAtPosition(position: number): number;\n}\n\nexport default class Path implements PathSegment {\n  static straightThroughPoints(...points: ReadonlyArray<Vector2>): Path {\n    let [lastPoint, ...remainingPoints] = points;\n    const path = new Path();\n\n    for (const point of remainingPoints) {\n      path.addSegment(new StraightPathSegment(lastPoint, point));\n      lastPoint = point;\n    }\n\n    return path;\n  }\n\n  static segmentAcrossCircle(\n    containingCircle: Circle,\n    entryAngle: number,\n    exitAngle: number,\n  ): CirclePathSegment | StraightPathSegment {\n    entryAngle = entryAngle + Math.PI;\n    const entryPoint = containingCircle.pointOnCircumference(entryAngle);\n    const exitPoint = containingCircle.pointOnCircumference(exitAngle);\n\n    const entryLineNormal = new Line2(\n      containingCircle.center,\n      entryPoint,\n    ).perpendicularLineThroughPoint(entryPoint);\n    const exitLineNormal = new Line2(\n      containingCircle.center,\n      exitPoint,\n    ).perpendicularLineThroughPoint(exitPoint);\n\n    if (entryLineNormal.isParallelTo(exitLineNormal)) {\n      return new StraightPathSegment(entryPoint, exitPoint);\n    }\n\n    const roadCircleCenter = entryLineNormal.pointAtIntersectionWith(\n      exitLineNormal,\n    );\n    const roadCircleRadius = entryPoint.distanceTo(roadCircleCenter);\n\n    // containingCircle.center.debugDraw('lime');\n    // roadCircleCenter.debugDraw('blue');\n    // entryPoint.debugDraw('magenta');\n    // exitPoint.debugDraw('red');\n\n    return new CirclePathSegment(\n      roadCircleCenter,\n      roadCircleRadius,\n      entryPoint.sub(roadCircleCenter).angle,\n      exitPoint.sub(roadCircleCenter).angle,\n    );\n  }\n\n  segments: PathSegment[] = [];\n\n  constructor(...segments: PathSegment[]) {\n    this.addSegments(...segments);\n  }\n\n  getStart(): Vector2 {\n    return this.segments[0].getStart();\n  }\n\n  getEnd(): Vector2 {\n    return this.segments[this.segments.length - 1].getEnd();\n  }\n\n  getLength(): number {\n    return this.segments.reduce(\n      (length, segment) => length + segment.getLength(),\n      0,\n    );\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getPointAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  getAngleAtPosition(position: number): number {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getAngleAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  addSegment(segment: PathSegment): this {\n    const lastSegment = this.segments[this.segments.length - 1];\n    if (lastSegment) {\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        `segments must neatly join together - ${lastSegment\n          .getEnd()\n          .toString()} !== ${segment.getStart().toString()}`,\n      );\n    }\n    this.segments.push(segment);\n    return this;\n  }\n\n  addSegments(...segments: PathSegment[]): this {\n    segments.forEach(segment => this.addSegment(segment));\n    return this;\n  }\n\n  autoRound(radius: number): this {\n    const newSegments = this.segments.map((segment, i): PathSegment | null => {\n      const lastSegment = i === 0 ? null : this.segments[i - 1];\n      if (!lastSegment) {\n        if (segment instanceof StraightPathSegment) return null;\n        return segment;\n      }\n\n      if (!(segment instanceof StraightPathSegment)) return segment;\n      if (!(lastSegment instanceof StraightPathSegment)) return null;\n\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        'segments must join',\n      );\n\n      const entryAngle = lastSegment.angle;\n      const exitAngle = segment.angle;\n      const usableRadius = Math.min(\n        radius,\n        lastSegment.getLength() / 2,\n        segment.getLength() / 2,\n      );\n\n      const containingCircle = new Circle(\n        segment.getStart().x,\n        segment.getStart().y,\n        usableRadius,\n      );\n\n      return Path.segmentAcrossCircle(containingCircle, entryAngle, exitAngle);\n    });\n\n    const compacted = compact(newSegments);\n\n    const start = this.getStart();\n    const end = this.getEnd();\n    let lastPoint = start;\n    this.segments = [];\n\n    compacted.forEach(segment => {\n      if (segment.getStart().equals(lastPoint)) {\n        this.addSegment(segment);\n      } else {\n        this.addSegment(new StraightPathSegment(lastPoint, segment.getStart()));\n        this.addSegment(segment);\n      }\n\n      lastPoint = segment.getEnd();\n    });\n\n    if (!lastPoint.equals(end)) {\n      this.addSegment(new StraightPathSegment(lastPoint, end));\n    }\n\n    return this;\n  }\n}\n","// @flow\nimport { compact } from '../lib/utils';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Scene from '../lib/scene/Scene';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\nimport Path from '../lib/geom/Path';\nimport Road from './Road';\nimport Intersection from './networkNodes/Intersection';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class Junction extends SceneObject {\n  _circle: Circle;\n  _intersectionsByAngle: { [angleString: string]: Intersection } = {};\n  _incomingIntersections: Set<Intersection> = new Set();\n  _outgoingIntersections: Set<Intersection> = new Set();\n  _roads: Road[] = [];\n\n  constructor(x: number, y: number, radius: number) {\n    super();\n    this._circle = new Circle(x, y, radius);\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    this._roads.forEach(road => scene.addChild(road));\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._circle.pointOnCircumference(radians);\n  }\n\n  connectToRoadAtAngle(\n    road: Road,\n    angle: number,\n    direction: ConnectionDirection,\n  ): Intersection {\n    const intersection = this._intersectionAtAngle(angle);\n    intersection.connectTo(road, direction);\n\n    const isIncoming =\n      direction === ConnectionDirection.IN ||\n      this._incomingIntersections.has(intersection);\n\n    const isOutgoing =\n      direction === ConnectionDirection.OUT ||\n      this._outgoingIntersections.has(intersection);\n\n    if (isIncoming) this._incomingIntersections.add(intersection);\n    if (isOutgoing) this._outgoingIntersections.add(intersection);\n\n    this._intersections.forEach(other => {\n      if (other === intersection) return;\n\n      if (isIncoming && this._outgoingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(intersection.position).angle,\n            other.position.sub(this._circle.center).angle,\n          ),\n        );\n\n        this._addRoad(new Road(intersection, other, { path }));\n      }\n\n      if (isOutgoing && this._incomingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(other.position).angle,\n            intersection.position.sub(this._circle.center).angle,\n          ),\n        );\n        this._addRoad(new Road(other, intersection, { path }));\n      }\n    });\n\n    return intersection;\n  }\n\n  _intersectionAtAngle(angle: number): Intersection {\n    const angleStr = angle.toString();\n    if (this._intersectionsByAngle[angleStr]) {\n      return this._intersectionsByAngle[angleStr];\n    }\n\n    const intersection = this._createIntersectionAtAngle(angle);\n    this._intersectionsByAngle[angleStr] = intersection;\n    return intersection;\n  }\n\n  _createIntersectionAtAngle(angle: number): Intersection {\n    const position = this.getVisualConnectionPointAtAngle(angle);\n    return new Intersection(position.x, position.y);\n  }\n\n  get _intersections(): Intersection[] {\n    return compact(\n      Object.keys(this._intersectionsByAngle).map(\n        angle => this._intersectionsByAngle[angle],\n      ),\n    );\n  }\n\n  _addRoad(road: Road) {\n    this._roads.push(road);\n    if (this.hasScene()) {\n      this.getScene().addChild(road);\n    }\n  }\n}\n","// @flow\nimport SceneObject from '../lib/scene/SceneObject';\nimport Path from '../lib/geom/Path';\nimport StraightPathSegment from '../lib/geom/StraightPathSegment';\nimport Vector2 from '../lib/geom/Vector2';\nimport * as ShapeHelpers from '../lib/canvasShapeHelpers';\nimport { YELLOW } from './colors';\nimport ConnectionDirection from './ConnectionDirection';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Junction from './Junction';\nimport Traveller from './Traveller';\n\n// const ROAD_OUTER_COLOR = BLUE;\n// const ROAD_INNER_COLOR = LIGHT_BG;\nconst ROAD_DASH_COLOR = YELLOW.darken(0.2);\n// const ROAD_OUTER_WIDTH = 12;\n// const ROAD_INNER_WIDTH = 13;\nconst ROAD_DASH_WIDTH = 3;\nconst ROAD_IDEAL_DASH = [5, 10];\nconst ROAD_IDEAL_DASH_LENGTH = ROAD_IDEAL_DASH.reduce((a, b) => a + b, 0);\nconst ROAD_DASH_SPEED = 0.05;\n\nexport type RoadOptions = {\n  autoRound?: number;\n  points?: Array<Vector2>;\n  path?: Path;\n};\n\nexport default class Road extends SceneObject {\n  isNode = false;\n  from: NetworkNode;\n  to: NetworkNode;\n  _path: Path;\n  _currentTravellers: Traveller[] = [];\n\n  constructor(\n    from: NetworkNode | Junction,\n    to: NetworkNode | Junction,\n    { points, autoRound, path }: RoadOptions = {},\n  ) {\n    super();\n\n    const angleFrom = points\n      ? from.position.angleTo(points[0])\n      : from.position.angleTo(to.position);\n\n    const angleTo = points\n      ? to.position.angleTo(points[points.length - 1])\n      : to.position.angleTo(from.position);\n\n    if (path) {\n      this._path = path;\n    } else if (points) {\n      this._path = Path.straightThroughPoints(\n        from.getVisualConnectionPointAtAngle(angleFrom),\n        ...points,\n        to.getVisualConnectionPointAtAngle(angleTo),\n      );\n    } else {\n      this._path = new Path().addSegment(\n        new StraightPathSegment(\n          from.getVisualConnectionPointAtAngle(angleFrom),\n          to.getVisualConnectionPointAtAngle(angleTo),\n        ),\n      );\n    }\n\n    if (autoRound != null) {\n      this._path.autoRound(autoRound);\n    }\n\n    if (from instanceof Junction) {\n      this.from = from.connectToRoadAtAngle(\n        this,\n        angleFrom,\n        ConnectionDirection.OUT,\n      );\n    } else {\n      this.from = from;\n      from.connectTo(this, ConnectionDirection.OUT);\n    }\n\n    if (to instanceof Junction) {\n      this.to = to.connectToRoadAtAngle(this, angleTo, ConnectionDirection.IN);\n    } else {\n      this.to = to;\n      to.connectTo(this, ConnectionDirection.IN);\n    }\n  }\n\n  get length(): number {\n    return this._path.getLength();\n  }\n\n  get start(): Vector2 {\n    return this._path.getStart();\n  }\n\n  get end(): Vector2 {\n    return this._path.getEnd();\n  }\n\n  get expectedTimeFromStartToEnd(): number {\n    if (this._currentTravellers.length) {\n      const avgSpeed =\n        this._currentTravellers.reduce(\n          (sum, traveller) => sum + traveller.speed,\n          0,\n        ) / this._currentTravellers.length;\n      return this.length / avgSpeed;\n    }\n\n    return this.length / (Traveller.MAX_SPEED * 0.7);\n  }\n\n  canAddTravellerAtStart(): boolean {\n    const nextTraveller = this.getTravellerAfterPosition(0);\n    if (!nextTraveller) return true;\n    return (\n      nextTraveller.positionOnCurrentRoad > nextTraveller.comfortableRadius\n    );\n  }\n\n  addTravellerAtStart(traveller: Traveller) {\n    this._currentTravellers.push(traveller);\n    traveller.onAddedToRoad(this);\n  }\n\n  removeTraveller(traveller: Traveller): boolean {\n    const index = this._currentTravellers.indexOf(traveller);\n    if (index === -1) return false;\n    this.removeTravellerAtIndex(index);\n    return true;\n  }\n\n  removeTravellerAtIndex(index: number): Traveller {\n    const traveller = this._currentTravellers[index];\n    this._currentTravellers.splice(index, 1);\n    traveller.onRemovedFromRoad();\n    return traveller;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    const nodes = [] as Array<NetworkNode>;\n    if (visited.has(this.to)) return nodes;\n    return [...this.to.getAllReachableNodes(visited), this.to];\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    return this._path.getPointAtPosition(position);\n  }\n\n  getAngleAtPosition(position: number): number {\n    return this._path.getAngleAtPosition(position);\n  }\n\n  getTravellerAfterPosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = traveller.positionOnCurrentRoad - position;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getTravellerBeforePosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = position - traveller.positionOnCurrentRoad;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, time: number) {\n    ctx.beginPath();\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ShapeHelpers.path(ctx, this._path);\n\n    // ctx.strokeStyle = ROAD_OUTER_COLOR.toString();\n    // ctx.lineWidth = ROAD_OUTER_WIDTH;\n    // ctx.stroke();\n\n    // ctx.strokeStyle = ROAD_INNER_COLOR.toString();\n    // ctx.lineWidth = ROAD_INNER_WIDTH;\n    // ctx.stroke();\n\n    const dashScale = this._getLineDashScale();\n    const dashLength = ROAD_IDEAL_DASH_LENGTH * dashScale;\n    ctx.setLineDash(ROAD_IDEAL_DASH.map(length => length * dashScale));\n    ctx.strokeStyle = ROAD_DASH_COLOR.toString();\n    ctx.lineDashOffset = (-time * ROAD_DASH_SPEED * dashScale) % dashLength;\n    ctx.lineWidth = ROAD_DASH_WIDTH;\n    // ctx.strokeStyle = 'black';\n    // ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  _getLineDashScale(): number {\n    const wholeDashCount = Math.floor(this.length / ROAD_IDEAL_DASH_LENGTH);\n    const wholeDashLength = wholeDashCount * ROAD_IDEAL_DASH_LENGTH;\n\n    const roundDownLength = this.length - wholeDashLength;\n    const roundUpLength =\n      wholeDashLength + ROAD_IDEAL_DASH_LENGTH - this.length;\n\n    const dashScale =\n      roundDownLength < roundUpLength\n        ? this.length / wholeDashLength\n        : this.length / (wholeDashLength + ROAD_IDEAL_DASH_LENGTH);\n\n    return dashScale;\n  }\n}\n","// @flow\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { outSine } from '../../lib/easings';\nimport { mapRange, constrain, flatten, uniq } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { TEAL } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Traveller from '../Traveller';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 500;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst CLOCK_RADIUS = RADIUS * 0.7;\nconst PULSE_RADIUS = 35;\n\nconst PULSE_DURATION = 500;\nconst CLOCK_FADE_DURATION = 150;\n\nconst MAIN_COLOR = TEAL.lighten(0.1);\nconst CLOCK_COLOR = TEAL.darken(0.1);\nconst PULSE_COLOR = TEAL.lighten(0.2).fade(0.1);\n\nexport default class Producer extends SceneObject implements NetworkNode {\n  isDestination = false;\n  canConsumeTraveller = false;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n    this._timer = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()) {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  consumeTraveller() {\n    throw new Error('producer cannot consume traveller');\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n    if (this._timer >= this._cooldown) {\n      this._onTimerEnd();\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ctx.arc(\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n      -Math.PI / 2,\n      progress * 2 * Math.PI - Math.PI / 2,\n      false,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = MAIN_COLOR.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      CLOCK_RADIUS,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _onTimerEnd() {\n    const didEmitTraveller = this._attemptEmitTraveller();\n    if (didEmitTraveller) {\n      this._pulse();\n      this._resetTimer();\n    }\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        startRadius: RADIUS,\n        endRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: outSine,\n        removeOnComplete: true,\n      }),\n    );\n  }\n\n  _attemptEmitTraveller(): boolean {\n    const road = this._connectionSet.sampleOutgoing();\n    if (!(road instanceof Road)) return false;\n\n    if (road.canAddTravellerAtStart()) {\n      const traveller = new Traveller();\n      road.addTravellerAtStart(traveller);\n      this.getScene().addChild(traveller);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Scene from '../lib/scene/Scene';\nimport Consumer from './networkNodes/Consumer';\nimport Producer from './networkNodes/Producer';\nimport Road from './Road';\nimport Junction from './Junction';\n// import DebugOverlay from \"./systems/DebugOverlay\";\nimport TravellerFinder from './TravellerFinder';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst ROUND = 50;\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nconst root = document.getElementById('root');\nassert(root, '#root must be present');\nscene.appendTo(root);\n\n// scene.addSystem(new DebugOverlay());\nscene.addSystem(new TravellerFinder());\n\nscenario3();\n\nscene.start();\n\nfunction scenario1() {\n  const producer1 = new Producer(100, 100, 500);\n  // const producer2 = new Consumer(100, 300, 2500);\n  const consumer1 = new Consumer(400, 200, 1500);\n  const consumer2 = new Consumer(250, 200, 1500);\n  scene.addChild(producer1);\n  // scene.addChild(producer2);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n\n  const junction1 = new Junction(250, 100, ROUND);\n  scene.addChild(junction1);\n  scene.addChild(new Road(producer1, junction1));\n  scene.addChild(\n    new Road(junction1, consumer1, {\n      points: [new Vector2(400, 100)],\n      autoRound: ROUND,\n    }),\n  );\n  scene.addChild(new Road(junction1, consumer2));\n\n  // const path2 = new Path();\n  // path2.addSegments(\n  //   new StraightPathSegment(new Vector2(130, 300), new Vector2(380, 300)),\n  //   new CirclePathSegment(new Vector2(380, 280), 20, Math.PI * 0.5, 0),\n  //   new StraightPathSegment(new Vector2(400, 280), new Vector2(400, 230)),\n  // );\n  // const road2 = new Road(producer2, consumer1, path2);\n  // scene.addChild(road2);\n}\n\nfunction scenario2() {\n  const producer = new Producer(100, 300, 500);\n  const junction = new Junction(300, 300, ROUND);\n  const consumer1 = new Consumer(300, 100, 5000);\n  const consumer2 = new Consumer(500, 300, 5000);\n  const consumer3 = new Consumer(300, 500, 5000);\n\n  scene.addChild(new Road(producer, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  scene.addChild(producer);\n  scene.addChild(junction);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n}\n\nfunction scenario3() {\n  const northConsumer = new Consumer(300, 550, 1500);\n  const middleConsumer = new Consumer(100, 450, 1500);\n  const southConsumer = new Consumer(100, 250, 1500);\n  const eastProducer = new Producer(600, 150, 500);\n  const westProducer = new Producer(100, 100, 500);\n  // const westProducer = new Producer(250, 250, 100);\n\n  scene.addChild(northConsumer);\n  scene.addChild(middleConsumer);\n  scene.addChild(southConsumer);\n  scene.addChild(eastProducer);\n  scene.addChild(westProducer);\n\n  const mainJunction = new Junction(300, 150, ROUND);\n  const eastProducerSplit = new Junction(500, 370, ROUND);\n  const southConsumerJoin = new Junction(330, 400, ROUND);\n  scene.addChild(mainJunction);\n  scene.addChild(eastProducerSplit);\n  scene.addChild(southConsumerJoin);\n  scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(eastProducer, eastProducerSplit));\n  scene.addChild(new Road(eastProducerSplit, southConsumerJoin));\n  // scene.addChild(\n  //   new Road(eastProducerSplit, mainJunction, {\n  //     points: [[600, 280], [700, 50], [450, 180], [450, 100], [300, 20]],\n  //     // points: [[400, 100]],\n  //     autoRound: 50,\n  //   }),\n  // );\n  scene.addChild(\n    new Road(eastProducerSplit, mainJunction, {\n      points: [new Vector2(400, 300), new Vector2(500, 50)],\n      autoRound: ROUND,\n    }),\n  );\n\n  // scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(mainJunction, southConsumerJoin));\n  scene.addChild(new Road(southConsumerJoin, northConsumer));\n  scene.addChild(new Road(mainJunction, middleConsumer));\n  scene.addChild(new Road(mainJunction, southConsumer));\n}\n\nfunction scenario4() {\n  const producer1 = new Producer(100, 100, 1000);\n  const producer2 = new Producer(300, 200, 1000);\n  const producer3 = new Producer(100, 300, 1000);\n  // const producer4 = new Producer(400, 100, 1000);\n  const consumer1 = new Consumer(300, 100, 1000);\n  const consumer2 = new Consumer(100, 200, 1000);\n  const consumer3 = new Consumer(300, 300, 1000);\n  // const consumer4 = new Consumer(430, 300, 1000);\n  scene.addChild(producer1);\n  scene.addChild(producer2);\n  scene.addChild(producer3);\n  // scene.addChild(producer4);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n  // scene.addChild(consumer4);\n\n  const junction = new Junction(200, 200, 30);\n  scene.addChild(junction);\n\n  scene.addChild(new Road(producer1, junction));\n  scene.addChild(new Road(producer2, junction));\n  scene.addChild(new Road(producer3, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  // scene.addChild(\n  //   new Road(producer4, consumer4, {\n  //     points: [[400, 250], [415, 250], [415, 150], [430, 150]],\n  //     autoRound: 30,\n  //   }),\n  // );\n}\n\nfunction scenario6() {\n  const producer = new Producer(300, 50, 1500).addTo(scene);\n  const consumer = new Consumer(500, 50, 100).addTo(scene);\n  new Road(producer, consumer, {\n    points: [\n      new Vector2(350, 150),\n      new Vector2(150, 350),\n      new Vector2(400, 500),\n      new Vector2(650, 350),\n      new Vector2(450, 150),\n    ],\n    autoRound: 400,\n  }).addTo(scene);\n}\n","import { assert } from '../assert';\nimport SceneObject from './SceneObject';\nimport SceneSystem from './SceneSystem';\n\nconst speed = 1;\nconst scale = 1;\nconst repeatUpdate = 1;\n\ntype SystemClass<T extends SceneSystem = SceneSystem> = {\n  systemName: string;\n  new (): T;\n};\n\nexport default class Scene {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  private _scaleFactor: number;\n  private _children: SceneObject[] = [];\n  private _isPlaying: boolean = false;\n  private frameHandle: number | null = null;\n  private lastElapsedTime: number | null = null;\n  private systemsByClass = new Map<SystemClass<SceneSystem>, SceneSystem>();\n\n  constructor(width: number, height: number, scaleFactor: number = 1) {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = width * scaleFactor;\n    this.canvas.height = height * scaleFactor;\n    this.canvas.style.width = `${width}px`;\n    this.canvas.style.height = `${height}px`;\n    const ctx = this.canvas.getContext('2d');\n    assert(ctx, 'ctx');\n    this.ctx = ctx;\n    this._scaleFactor = scaleFactor * scale;\n\n    this._setupVisiblityChange();\n  }\n\n  get width(): number {\n    return this.canvas.width / this._scaleFactor;\n  }\n\n  get height(): number {\n    return this.canvas.height / this._scaleFactor;\n  }\n\n  get scaleFactor(): number {\n    return this._scaleFactor;\n  }\n\n  get isPlaying(): boolean {\n    return this.frameHandle !== null && this._isPlaying;\n  }\n\n  set isPlaying(newValue: boolean) {\n    assert(\n      this.frameHandle !== null,\n      'cannot set isPlaying without calling start',\n    );\n    this._isPlaying = newValue;\n  }\n\n  get children(): SceneObject[] {\n    return this._children;\n  }\n\n  appendTo(element: HTMLElement) {\n    element.appendChild(this.canvas);\n  }\n\n  hasSystem(systemType: SystemClass): boolean {\n    return this.systemsByClass.has(systemType);\n  }\n\n  getSystem<T extends SceneSystem>(systemType: SystemClass<T>): T {\n    const system = this.systemsByClass.get(systemType);\n    assert(system, `system, ${systemType.systemName} not found`);\n    assert(system instanceof systemType, 'system is wrong instance type');\n    return system;\n  }\n\n  addSystem(system: SceneSystem) {\n    assert(\n      !this.hasSystem(system.constructor as any),\n      'only one system of each type allowed',\n    );\n    this.systemsByClass.set(system.constructor as any, system);\n    system.afterAddToScene(this);\n  }\n\n  removeSystem(systemType: SystemClass) {\n    const system = this.getSystem(systemType);\n    system.beforeRemoveFromScene(this);\n    this.systemsByClass.delete(systemType);\n  }\n\n  addChild(child: SceneObject) {\n    this._children.push(child);\n    child.onAddedToScene(this);\n  }\n\n  addChildBefore(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index, newChild);\n  }\n\n  addChildAfter(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index + 1, newChild);\n  }\n\n  addChildAtIndex(index: number, child: SceneObject) {\n    this._children.splice(index, 0, child);\n    child.onAddedToScene(this);\n  }\n\n  removeChild(child: SceneObject): boolean {\n    const index = this._children.indexOf(child);\n    if (index === -1) return false;\n\n    this.removeChildAtIndex(index);\n    return true;\n  }\n\n  removeChildAtIndex(index: number): SceneObject {\n    const child = this._children[index];\n    this._children.splice(index, 1);\n    child.onRemovedFromScene();\n    return child;\n  }\n\n  update(delta: number) {\n    for (let i = 0; i < repeatUpdate; i++) {\n      for (const system of this.systemsByClass.values()) {\n        system.beforeUpdate(delta);\n      }\n      this._children.forEach((child) => child.update(delta));\n      for (const system of this.systemsByClass.values()) {\n        system.afterUpdate(delta);\n      }\n    }\n  }\n\n  draw(elapsedTime: number) {\n    this.ctx.save();\n    this.ctx.scale(this._scaleFactor, this._scaleFactor);\n    this.ctx.clearRect(0, 0, this.width, this.height);\n\n    for (const system of this.systemsByClass.values()) {\n      system.beforeDraw(this.ctx, elapsedTime);\n    }\n    this._children\n      .sort((a, b) => a.getSortOrder() - b.getSortOrder())\n      .forEach((child) => child.draw(this.ctx, elapsedTime));\n    for (const system of this.systemsByClass.values()) {\n      system.afterDraw(this.ctx, elapsedTime);\n    }\n\n    this.ctx.restore();\n  }\n\n  start() {\n    this._isPlaying = true;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  }\n\n  stop() {\n    if (this.frameHandle !== null) {\n      window.cancelAnimationFrame(this.frameHandle);\n      this.frameHandle = null;\n    }\n    this._isPlaying = false;\n    this.lastElapsedTime = null;\n  }\n\n  _tick = (elapsedTime: number) => {\n    elapsedTime = elapsedTime * speed;\n    const lastElapsedTime = this.lastElapsedTime;\n    if (lastElapsedTime !== null) {\n      const deltaTime = elapsedTime - lastElapsedTime;\n      if (this.isPlaying) {\n        this.update(deltaTime);\n        this.draw(elapsedTime);\n      }\n    }\n\n    this.lastElapsedTime = elapsedTime;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  };\n\n  _setupVisiblityChange() {\n    let playOnVisible = false;\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.isPlaying) {\n        playOnVisible = true;\n        this.stop();\n      }\n      if (playOnVisible && !document.hidden) {\n        playOnVisible = false;\n        this.start();\n      }\n    });\n  }\n}\n"],"names":["$83bf66e14d730e78$var$constructorIdCounts","$83bf66e14d730e78$export$9099ad97b570f7c","hasScene","scene","getScene","$aILhO","assert","this","draw","ctx","elapsedTime","update","delta","addTo","addChild","onAddedToScene","onRemovedFromScene","getSortOrder","name","id","constructor","$72a5e864b25fc7c2$var$UnitBezier","sampleCurveX","t","ax","bx","cx","sampleCurveY","ay","by","cy","sampleCurveDerivativeX","solveCurveX","x","epsilon","i","NEWTON_METHOD_ITERATIONS","x2","$j18jr","approxEq","dx","lo","hi","solve","DEFAULT_EPSILON","x1","y1","y2","$72a5e864b25fc7c2$export$5523e35ab8ae283a","n","$72a5e864b25fc7c2$export$101a56202f2aee9f","Math","sin","PI","$72a5e864b25fc7c2$export$46cc86e91d1dfb63","s","$79f9b2304bc276e5$export$9099ad97b570f7c","deltaTime","deltaProgress","_duration","_progress","min","_circle","withRadius","lerp","_startRadius","_endRadius","_easeRadius","_removeOnComplete","removeChild","beginPath","opacity","_easeOpacity","fillStyle","_color","fade","toString","$93VSc","circle","center","y","radius","fill","startRadius","endRadius","duration","color","easeRadius","easeOpacity","removeOnComplete","super","$gJsWu","default","$parcel$interopDefault","$11cc8","$a26dc568db70c81d$export$5aa0848f4abbb9a4","$a26dc568db70c81d$export$1d121502596d3ac9","$a26dc568db70c81d$export$5fac07ad2bc2fd13","ConnectionDirection","$f0857397cf738045$var$ConnectionDirection","$f0857397cf738045$export$9099ad97b570f7c","$527e99376fcb33fc$export$9099ad97b570f7c","add","target","direction","IN","addIncoming","OUT","addOutgoing","Error","incoming","push","outgoing","sampleIncoming","sample","sampleOutgoing","$58f5f207586fda4f$var$MAIN_COLOR","lighten","desaturate","$58f5f207586fda4f$var$CLOCK_COLOR","darken","$58f5f207586fda4f$var$PULSE_COLOR","$58f5f207586fda4f$export$9099ad97b570f7c","position","canConsumeTraveller","_timer","_cooldown","incomingConnections","_connectionSet","outgoingConnections","getVisualConnectionPointAtAngle","radians","_visualConnectionCircle","pointOnCircumference","getAllReachableNodes","visited","Set","connectTo","node","consumeTraveller","_resetTimer","_pulse","constrain","progress","colorMixAmount","mapRange","bgColor","mix","moveTo","easing","addChildBefore","cooldown","isDestination","$a07b9228bda8e081$export$9099ad97b570f7c","afterAddToScene","beforeRemoveFromScene","beforeUpdate","afterUpdate","beforeDraw","time","afterDraw","systemName","$f6487ea1f1072d82$export$9099ad97b570f7c","insert","item","point","_getPosition","boundary","contains","_nextItemIndex","NODE_CAPACITY","_items","subdivisions","_getSubdivisions","remove","index","indexOf","splice","_subdivisions","clear","undefined","forEach","subdivision","findItemsInRect","rect","foundItems","intersects","findItemsInCircle","getBoundingBox","filter","containsPoint","getCenter","$44Lwt","fromLeftTopRightBottom","left","top","right","bottom","getPosition","$168e3c09180a8de2$export$9099ad97b570f7c","removeTraveller","traveller","_quadTree","width","height","children","child","$accef68175fca195$export$9099ad97b570f7c","findTravellersInCircle","$f99664623130cb5c$var$PathFinder","getNextRoad","initialNode","destinationNode","remainingNodes","has","bestCosts","Map","prevRoads","set","size","cost","_nodeWithShortestDistance","delete","_nextRoadFromRoute","_updateNeighbours","nodes","costs","bestCost","Infinity","bestNode","get","road","nextNode","to","nextNodeCost","altNextNodeCost","expectedTimeFromStartToEnd","start","finish","from","$f99664623130cb5c$export$9099ad97b570f7c","$d16cc6ba04d329e8$export$9099ad97b570f7c","destination","nextRoad","includes","removeFromCurrentRoad","addTravellerAtStart","uniq","flatten","map","getClosestOutgoingTraveller","bestTraveller","shortestDistance","getTravellerAfterPosition","positionOnCurrentRoad","getClosestIncomingTraveller","getTravellerBeforePosition","length","distanceToEndOfCurrentRoad","$gcFVl","$3f847b092ae83168$export$9099ad97b570f7c","$5WDzG","getSortOrderFn","entity","$26fe585cf8d37501$export$9099ad97b570f7c","addComponent","component","args","componentInstances","instance","hasComponent","getComponent","removeComponent","onRemove","values","component1","component2","$accef68175fca195$var$enterEase","$72a5e864b25fc7c2$export$a6155a2e10c8a18c","$accef68175fca195$var$exitEase","StopReason","$accef68175fca195$var$StopReason","currentRoad","_currentRoad","getPointAtPosition","_positionOnCurrentRoad","predictedStopPoint","stopPosition","_getPredictedStopPositionIfDecelerating","_getPredictedPointForPosition","predictedStopArea","safeRadius","potentialNextPredictedStopPoint","_destination","speed","_speed","isStopped","stoppedTime","_stoppedTime","stopReason","_stopReason","isStoppedFor","other","_stoppedFor","onAddedToRoad","_pickDestination","onRemovedFromRoad","getSystem","dtMilliseconds","_age","_move","pal","_getPal","$hGok8","PalAbsoluteController","setPosition","getAngleAtPosition","_getEnterTransitionScale","_checkAtEndOfRoad","_checkExit","_isExiting","_exitStartedAt","_pal","config","$180ke","generateRandomPalConfig","$6QVeV","setAnimationController","$7n8qG","$181T4","$a932c909512106a0$export$fd5ea85005084744","_getExitTransitionScale","timeToStop","overshoot","overshootAngle","fromPolar","end","potentialDestinations","dtSeconds","_forceAccelerateTimer","_shouldDecelerate","_accelerate","predictedStopPosition","STOPPED_FOR_DESTINATION","nextTravellerOnRoad","safeStopAheadPosition","comfortableRadius","STOPPED_FOR_TRAFFIC_IN_FRONT","intersection","outgoingTraveller","incomingTraveller","_shouldDecelerateForNearbyTravellers","STOPPED_FOR_TRAFFIC_NEARBY","travellerFinder","stopArea","stopPoint","nextStopPoint","searchArea","nearbyTravellers","otherStopArea","otherStopPoint","intersectsCircle","otherNextStopPoint","currentStopDistance","distanceTo","approachAmount","otherApproachAmount","random","_forceAcceleration","acceleration","lastSpeed","avgSpeed","_onReachEndOfCurrentRoad","_onExit","_onReachDestination","_exit","MAX_SPEED","$542ff7e65194c77e$export$9099ad97b570f7c","points","lastPoint","remainingPoints","path","addSegment","$izhPG","containingCircle","entryAngle","exitAngle","entryPoint","exitPoint","entryLineNormal","$jIpjz","perpendicularLineThroughPoint","exitLineNormal","isParallelTo","roadCircleCenter","pointAtIntersectionWith","roadCircleRadius","$cGqeu","sub","angle","getStart","segments","getEnd","getLength","reduce","segment","constrained","soFar","lastSegment","equals","addSegments","autoRound","newSegments","usableRadius","segmentAcrossCircle","compacted","compact","$cc4343ebd69c11eb$export$9099ad97b570f7c","_roads","connectToRoadAtAngle","_intersectionAtAngle","isIncoming","_incomingIntersections","isOutgoing","_outgoingIntersections","_intersections","_addRoad","$81f8ce477450b881$export$9099ad97b570f7c","angleStr","_intersectionsByAngle","_createIntersectionAtAngle","Object","keys","$81f8ce477450b881$var$ROAD_DASH_COLOR","$81f8ce477450b881$var$ROAD_IDEAL_DASH","$81f8ce477450b881$var$ROAD_IDEAL_DASH_LENGTH","a","b","_path","_currentTravellers","sum","canAddTravellerAtStart","nextTraveller","removeTravellerAtIndex","bestDistance","distance","lineCap","lineJoin","dashScale","_getLineDashScale","dashLength","setLineDash","strokeStyle","lineDashOffset","lineWidth","stroke","wholeDashLength","floor","isNode","angleFrom","angleTo","straightThroughPoints","$3f6b73372870a4a3$var$MAIN_COLOR","$3f6b73372870a4a3$var$CLOCK_COLOR","$3f6b73372870a4a3$var$PULSE_COLOR","$3f6b73372870a4a3$export$9099ad97b570f7c","_onTimerEnd","arc","$3f6b73372870a4a3$var$RADIUS","_attemptEmitTraveller","$9b5c66fc2680c4fa$var$scene","canvas","_scaleFactor","scaleFactor","isPlaying","frameHandle","_isPlaying","newValue","_children","appendTo","element","appendChild","hasSystem","systemType","systemsByClass","system","addSystem","removeSystem","targetChild","newChild","addChildAtIndex","addChildAfter","removeChildAtIndex","system1","save","scale","clearRect","sort","restore","window","requestAnimationFrame","_tick","stop","cancelAnimationFrame","lastElapsedTime","_setupVisiblityChange","playOnVisible","document","addEventListener","hidden","createElement","style","getContext","devicePixelRatio","$9b5c66fc2680c4fa$var$root","getElementById","northConsumer","middleConsumer","southConsumer","eastProducer","westProducer","mainJunction","eastProducerSplit","southConsumerJoin","$9b5c66fc2680c4fa$var$scenario3"],"version":3,"file":"index.7e7ee871.js.map"}