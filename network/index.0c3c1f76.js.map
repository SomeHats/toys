{"mappings":"8pBAMMA,EAAN,iCAAMA,EAUQC,EAAYC,EAAYC,EAAYC,yBAV5CJ,GAWF,IAAMK,EAAK,EAAIJ,EACTK,EAAK,GAAKH,EAAKF,GAAMI,EAErBE,EAAK,EAAIL,EACTM,EAAK,GAAKJ,EAAKF,GAAMK,EAE3BE,KAAKC,GAAK,EAAML,EAAKC,EACrBG,KAAKH,GAAKA,EACVG,KAAKJ,GAAKA,EACVI,KAAKE,GAAK,EAAMJ,EAAKC,EACrBC,KAAKD,GAAKA,EACVC,KAAKF,GAAKA,uBAtBRP,EAAU,EAyBNY,IAAA,qBAAR,SAAqBC,GACnB,QAASJ,KAAKC,GAAKG,EAAIJ,KAAKH,IAAMO,EAAIJ,KAAKJ,IAAMQ,KAG3CD,IAAA,qBAAR,SAAqBC,GACnB,QAASJ,KAAKE,GAAKE,EAAIJ,KAAKD,IAAMK,EAAIJ,KAAKF,IAAMM,KAG3CD,IAAA,+BAAR,SAA+BC,GAC7B,OAAQ,EAAMJ,KAAKC,GAAKG,EAAI,EAAMJ,KAAKH,IAAMO,EAAIJ,KAAKJ,MAGhDO,IAAA,oBAAR,SAAoBE,EAAWC,GAG7B,IADA,IAAIF,EAAIC,EACCE,EAAI,EAAGA,EAAIhB,EAAWiB,yBAA0BD,IAAK,CAC5D,IAAIb,EAAKM,KAAKS,aAAaL,GAC3B,GAAIM,EAAAC,SAASjB,EAAIW,EAAGC,GAClB,OAAOF,EAET,IAAIQ,EAAKZ,KAAKa,uBAAuBT,GACrC,GAAIM,EAAAC,SAASC,EAAI,EAAK,MACpB,MAEFR,IAAMV,EAAKW,GAAKO,EAIlB,IAAIE,EAAK,EACLC,EAAK,EAGT,IAFAX,EAAIC,GAEIS,EACN,OAAOA,EAET,GAAIV,EAAIW,EACN,OAAOA,OAGFD,EAAKC,GAAI,CACd,IAAIC,EAAKhB,KAAKS,aAAaL,GAC3B,GAAIM,EAAAC,SAASK,EAAIX,EAAGC,GAClB,OAAOF,EAELC,EAAIW,EACNF,EAAKV,EAELW,EAAKX,EAEPA,GAAKW,EAAKD,GAAM,EAAMA,EAGxB,OAAOV,KAGTD,IAAA,cAAA,SAAME,EAAWY,OAAAX,OAA4C,IAA5CW,EAAkB1B,EAAW2B,gBAA7BD,EACf,OAAOjB,KAAKmB,aAAanB,KAAKoB,YAAYf,EAAGC,QAjF3Cf,EAAN,GAAMA,EACoBiB,yBAA2B,EAD/CjB,EAEoB2B,gBAAkB,KAmFrC,MC3FFG,EDqHQC,EAAS,SAACC,GAAsB,OAAAA,GAiChCC,EAAU,SAACpB,GACtB,OAAAqB,KAAKC,IAAKtB,EAAI,GAAgB,GAAVqB,KAAKE,MA0FdC,EACX,SAAQX,OAAPY,OAAS,IAAAZ,EAAG,QAAOA,EACpB,OAAA,SAACb,GACC,OAAO,EAAIA,EAAIA,IAAMyB,EAAI,GAAKzB,EAAIyB,KEjOjBC,iFAAN,SAAQC,yBAAFD,EAWPb,SACVZ,EADUY,EACVZ,EACA2B,EAFUf,EAEVe,EACAC,EAHUhB,EAGVgB,YACAC,EAJUjB,EAIViB,UACAC,EALUlB,EAKVkB,SACAC,EANUnB,EAMVmB,MAAKC,EANKpB,EAOVqB,WAAAA,OAAU,IAAAD,EAAGf,EAAMe,EAAAE,EAPTtB,EAQVuB,YAAAA,OAAW,IAAAD,EAAGjB,EAAMiB,EAAAE,EARVxB,EASVyB,iBAAAA,OAAgB,IAAAD,GAAQA,+BApBPX,wDAAAA,GAAKa,KAAA3C,QAuBjB4C,QAAU,IAAIC,EAAAC,QAAOzC,EAAG2B,EAAGC,KAC3Bc,aAAed,IACfe,WAAad,IACbe,UAAYd,IACZe,OAASd,IACTe,UAAY,IACZd,YAAcC,IACdC,aAAeC,IACfC,kBAAoBC,sBA/BRZ,EAAKC,iBAALD,EAAK,EAkCxB3B,IAAA,eAAA,SAAOiD,GACL,IAAMC,EAAgBD,EAAYpD,KAAKiD,UACvCjD,KAAKmD,UAAY1B,KAAK6B,IAAI,EAAGtD,KAAKmD,UAAYE,GAC9CrD,KAAK4C,QAAU5C,KAAK4C,QAAQW,WAC1B7C,EAAA8C,KACExD,KAAK+C,aACL/C,KAAKgD,WACLhD,KAAKqC,YAAYrC,KAAKmD,aAIH,IAAnBnD,KAAKmD,WAAmBnD,KAAKyC,mBAC/BzC,KAAKyD,WAAWC,YAAY1D,SAIhCG,IAAA,aAAA,SAAKwD,GACHA,EAAIC,YACJ,IAAMC,EAAU7D,KAAKuC,aAAavC,KAAKmD,WACvCQ,EAAIG,UAAY9D,KAAKkD,OAAOa,KAAKF,GAASG,WAC1CC,EAAAC,OACEP,EACA3D,KAAK4C,QAAQuB,OAAO9D,EACpBL,KAAK4C,QAAQuB,OAAOnC,EACpBhC,KAAK4C,QAAQwB,QAEfT,EAAIU,WA5DavC,EAAN,CAAoBwC,EAAAxB,uBCftByB,GADW,IAAIC,EAAAC,GAAJ,CAAU,WACd,IAAID,EAAAC,GAAJ,CAAU,YAEjBC,GADO,IAAIF,EAAAC,GAAJ,CAAU,WACX,IAAID,EAAAC,GAAJ,CAAU,YAChBE,EAAS,IAAIH,EAAAC,GAAJ,CAAU,sCFP3BpD,EAAAuD,IAAAA,EAAmB,KACpB,GAAG,KADFvD,EAEA,IAAG,UAGRwD,EAAeD,EGDME,EAAN,iCAAMA,0BAAAA,GAAN9E,KACb+E,SAAmB,GADN/E,KAEbgF,SAAmB,wBAFAF,EAAa,EAIhC3E,IAAA,YAAA,SAAI8E,EAAcC,GAChB,OAAQA,GACN,KAAKL,EAAoBM,GACvBnF,KAAKoF,YAAYH,GACjB,MACF,KAAKJ,EAAoBQ,IACvBrF,KAAKsF,YAAYL,GACjB,cAEA,MAAM,IAAIM,MAAO,+BAAwCC,OAAVN,QAIrD/E,IAAA,oBAAA,SAAY8E,GACVjF,KAAK+E,SAASU,KAAKR,MAGrB9E,IAAA,oBAAA,SAAY8E,GACVjF,KAAKgF,SAASS,KAAKR,MAGrB9E,IAAA,uBAAA,WACE,OAAOO,EAAAgF,OAAO1F,KAAK+E,aAGrB5E,IAAA,uBAAA,WACE,OAAOO,EAAAgF,OAAO1F,KAAKgF,cA9BFF,EAAN,GCoBTa,EAAajB,EAAIkB,QAAQ,IAAKC,WAAW,IACzCC,EAAcpB,EAAIqB,OAAO,IACzBC,EAActB,EAAIkB,QAAQ,IAAK7B,KAAK,IAErBkC,EAAN,SAAQlE,yBAAFkE,EAQP5F,EAAW2B,EAAWf,SAAAiF,OAAmC,IAAnCjF,EArBX,IAqBWA,+BARfgF,wDAAAA,GAAQtD,KAAA3C,QAC3BmG,eAAgB,IAIhBC,OAAiB,IACjBC,eAAgC,IAAIvB,IAI7BlC,QAAU,IAAIC,EAAAC,QAAOzC,EAAG2B,EArBlB,MAsBNsE,wBAA0B,IAAIzD,EAAAC,QAAOzC,EAAG2B,EArBhB,MAsBxBuE,UAAYL,sBAZAD,EAAQlE,iBAARkE,EAAQ,EAevB9F,IAAA,eAAJ,WACE,OAAOH,KAAK4C,QAAQuB,UAGlBhE,IAAA,0BAAJ,WACE,OAAOH,KAAKoG,QAAUpG,KAAKuG,aAGzBpG,IAAA,0BAAJ,WACE,OAAOH,KAAKqG,eAAetB,YAGzB5E,IAAA,0BAAJ,WACE,OAAOH,KAAKqG,eAAerB,YAG7B7E,IAAA,wCAAA,SAAgCqG,GAC9B,OAAOxG,KAAKsG,wBAAwBG,qBAAqBD,MAG3DrG,IAAA,6BAAA,SAAqBc,GAEnB,YAFwD,IAArCA,EAA4B,IAAIyF,IAAhCzF,GACX0F,IAAI3G,MACL,CAACA,SAGVG,IAAA,kBAAA,SAAUyG,EAAY1B,GACpBlF,KAAKqG,eAAeM,IAAIC,EAAM1B,MAGhC/E,IAAA,yBAAA,WACE0G,EAAAC,OAAO9G,KAAK+G,oBAAqB,uCACjC/G,KAAKgH,cACLhH,KAAKiH,YAGP9G,IAAA,eAAA,SAAO+G,GACLlH,KAAKoG,OAAS1F,EAAAyG,UAAU,EAAGnH,KAAKuG,UAAWvG,KAAKoG,OAASc,MAG3D/G,IAAA,aAAA,SAAKwD,GACH,IAAMyD,EAAWpH,KAAKoG,OAASpG,KAAKuG,UAC9Bc,EAAiB3G,EAAAyG,UACrB,EACA,EACAzG,EAAA4G,SAAS,EAlEa,IAkEW,EAAG,EAAGtH,KAAKoG,SAExCmB,EAAU5B,EAAW6B,IAAI1B,EAAauB,GAE5C1D,EAAIC,YACJD,EAAIG,UAAYyD,EAAQvD,WACxBC,EAAAC,OACEP,EACA3D,KAAK4C,QAAQuB,OAAO9D,EACpBL,KAAK4C,QAAQuB,OAAOnC,EACpBhC,KAAK4C,QAAQwB,QAEfT,EAAIU,OAEJV,EAAIC,YACJD,EAAIG,UAAYgC,EAAY9B,WAC5BL,EAAI8D,OAAOzH,KAAK4C,QAAQuB,OAAO9D,EAAGL,KAAK4C,QAAQuB,OAAOnC,GACtDiC,EAAAC,OACEP,EACA3D,KAAK4C,QAAQuB,OAAO9D,EACpBL,KAAK4C,QAAQuB,OAAOnC,EACpBhC,KAAK4C,QAAQwB,OAASgD,GAExBzD,EAAIU,UAGNlE,IAAA,oBAAA,WACEH,KAAKoG,OAAS,KAGhBjG,IAAA,eAAA,WLJA,IAACuH,EKKC1H,KAAKyD,WAAWkE,eACd3H,KACA,IAAI8B,EAAM,CACRzB,EAAGL,KAAK4C,QAAQuB,OAAO9D,EACvB2B,EAAGhC,KAAK4C,QAAQuB,OAAOnC,EACvBE,UA1GO,GA2GPD,YAzGa,GA0GbE,SAvGe,IAwGfC,MAAO4D,EACP1D,WAAYV,EAAO,GACnBY,aLfLkF,EKe0BpG,ELd3B,SAACC,GACC,OAAAmG,EAAO,EAAInG,KKcPmB,kBAAkB,SArGLuD,EAAN,CAAuB3B,EAAAxB,6ICxBhC8E,uDAAe,2BAESC,EAAf,iCAAeA,0BAAAA,GAAf7H,KAEL8H,MAAsB,KAG5BjB,EAAAC,OACE9G,KAAK+H,cAAgBF,EACrB,0DAEFhB,EAAAC,OACG9G,KAAK+H,YAAoBC,aAAeJ,EACzC,2FAXwBC,EAAW,EAevC1H,IAAA,iBAAA,WAEE,OADA0G,EAAAC,OAAO9G,KAAK8H,MAAO,qBACZ9H,KAAK8H,SAGd3H,IAAA,wBAAA,SAAgB2H,GACd9H,KAAK8H,MAAQA,KAIf3H,IAAA,8BAAA,SAAsB2H,GACpB9H,KAAK8H,MAAQ,QAIf3H,IAAA,qBAAA,SAAa+G,OAGb/G,IAAA,oBAAA,SAAY+G,OAGZ/G,IAAA,mBAAA,SAAWwD,EAA+BsE,OAG1C9H,IAAA,kBAAA,SAAUwD,EAA+BsE,QAvCbJ,EAAf,GAAeA,EACrBG,WAAaJ,gCCCDM,EAAN,SAAQC,yBAAFD,iCAAAA,qDAAAA,GAAeE,MAAApI,KAAAqI,8BAAfH,EAAeC,iBAAfD,EAAe,EAKlC/H,IAAA,wBAAA,SAAgBmI,GACdtI,KAAKuI,UAAUC,OAAOF,MAGxBnI,IAAA,wBAAA,SAAgB2H,0BATGI,EAAeO,WAU1B,kBAANzI,MAAK2C,KAAA3C,KAAiB8H,GACtB9H,KAAKuI,UAAY,IAAIG,EAAA5F,QACnB6F,EAAA7F,QAAK8F,uBAAuB,EAAG,EAAGd,EAAMe,MAAOf,EAAMgB,SACrD,SAAAR,GAAa,OAAAA,EAAUS,eAI3B5I,IAAA,qBAAA,sBACQ2H,EAAQ9H,KAAKyD,WACnBzD,KAAKuI,UAAUS,QACflB,EAAMmB,SAASC,SAAQ,SAAAC,GACjBA,aAAiBC,GAASC,EACvBd,UAAUe,OAAOH,SAM5BhJ,IAAA,+BAAA,SAAuB+D,GACrB,OAAOlE,KAAKuI,UAAUgB,kBAAkBrF,OA7BvBgE,EAAN,CAA8BL,GAAxBK,EACZF,WAAa,uFCJhBwB,EAAa,CACjBC,YAAA,SAAYC,EAA0BC,GACpC,IAAMC,EAAiB,IAAIlD,IAAIgD,EAAYG,wBAC3CD,EAAejD,IAAI+C,GACnB7C,EAAAC,OACE8C,EAAeE,IAAIH,GACnB,iCAEF,IAAMI,EAAY,IAAIC,IAChBC,EAAY,IAAID,QAEtBD,EAAUG,IAAIR,EAAa,GAEpBE,EAAeO,MAAM,CAC1B,IAAuBC,EAAAZ,EAAWa,0BAChCT,EACAG,GAFMnD,EAAewD,EAAfxD,KAAM0D,EAASF,EAATE,KAMd,GAFAV,EAAeW,OAAO3D,GAElBA,IAAS+C,EACX,OAAOH,EAAWgB,mBAChBP,EACAP,EACAC,GAIJH,EAAWiB,kBAAkB7D,EAAMmD,EAAWO,EAAML,GAGtD,MAAM,IAAI1E,MAAM,uBAGlB8E,0BAAA,SACEK,EACAC,GAEA,IAAIC,EAAWC,EAAAA,EACXC,EAAW,KAWf,OATAJ,EAAMxB,SAAQ,SAAAtC,GACZ,IAAM0D,EAAOK,EAAMI,IAAInE,GACX,MAAR0D,GAAgBA,GAAQM,IAC1BA,EAAWN,EACXQ,EAAWlE,MAIfC,EAAAC,OAAOgE,EAAU,sBACV,CAAElE,KAAMkE,EAAUR,KAAMM,IAEjCH,kBAAA,SACE7D,EACAmD,EACAO,EACAL,GAEArD,EAAKoE,oBAAoB9B,SAAQ,SAAA+B,GAC/B,IAAMC,EAAWD,EAAKE,GAChBC,EAAerB,EAAUgB,IAAIG,GAC7BG,EAAkBf,EAAOW,EAAKK,4BAChB,MAAhBF,GAAwBC,GAAmBD,KAC7CrB,EAAUG,IAAIgB,EAAUG,GACxBpB,EAAUC,IAAIgB,EAAUD,QAI9BT,mBAAA,SACEP,EACAsB,EACAC,OAEA,IAAI5E,EAAO4E,EACJvB,EAAUH,IAAIlD,IAAO,CAC1B,IAAMqE,EAAOhB,EAAUc,IAAInE,GAG3B,GAFAC,EAAAC,OAAOmE,EAAM,oBACbrE,EAAOqE,EAAKQ,QACCF,EAAO,OAAON,EAG7B,MAAM,IAAI1F,MAAM,6BAIpBmG,EAAelC,EC/EMmC,EAAN,iCAAMA,EAKPtL,EAAW2B,yBALJ2J,GAAN3L,KACbmG,eAAgB,EADHnG,KAGbqG,eAAgC,IAAIvB,EAGlC9E,KAAK+I,SAAW,IAAI6C,EAAA9I,QAAQzC,EAAG2B,wBANd2J,EAAY,EAS3BxL,IAAA,0BAAJ,WACE,OAAOH,KAAKqG,eAAetB,YAGzB5E,IAAA,0BAAJ,WACE,OAAOH,KAAKqG,eAAerB,YAGzB7E,IAAA,0BAAJ,WACE,OAAO,KAGTA,IAAA,yBAAA,SAAiBmI,GACf,IAAMuD,EAAcvD,EAAUuD,YAC9BhF,EAAAC,OAAO+E,EAAa,mCAEpB,IAAMC,EAAWJ,EAAWjC,YAAYzJ,KAAM6L,GAC9ChF,EAAAC,OACE9G,KAAKgL,oBAAoBe,SAASD,GAClC,2CAGFxD,EAAU0D,wBACVF,EAASG,oBAAoB3D,MAG/BnI,IAAA,6BAAA,SAAqBc,OAAAiL,OAAqC,IAArCjL,EAA4B,IAAIyF,IAAhCzF,EAEnB,OADAiL,EAAQvF,IAAI3G,MACLU,EAAAyL,KACLzL,EAAA0L,QACEpM,KAAKqG,eAAerB,SAASqH,KAAI,SAAApB,GAC/B,OAAAA,EAAKpB,qBAAqBqC,WAMlC/L,IAAA,wCAAA,WACE,OAAOH,KAAK+I,YAGd5I,IAAA,oCAAA,WACE,IAAImM,EAAgB,KAChBC,EAAmB1B,EAAAA,EASvB,OARA7K,KAAKgL,oBAAoB9B,SAAQ,SAAA+B,GAC/B,IAAM3C,EAAY2C,EAAKuB,2BAA0B,GAC7ClE,GAAaA,EAAUmE,sBAAwBF,IACjDD,EAAgBhE,EAChBiE,EAAmBjE,EAAUmE,0BAI1BH,KAGTnM,IAAA,oCAAA,WACE,IAAImM,EAAgB,KAChBC,EAAmB1B,EAAAA,EAYvB,OAXA7K,KAAK0M,oBAAoBxD,SAAQ,SAAA+B,GAC/B,IAAM3C,EAAY2C,EAAK0B,2BAA2B1B,EAAK2B,QAErDtE,GACAA,EAAUuE,2BAA6BN,IAEvCD,EAAgBhE,EAChBiE,EAAmBjE,EAAUuE,+BAI1BP,KAGTnM,IAAA,kBAAA,SAAUyG,EAAY1B,GACpBlF,KAAKqG,eAAeM,IAAIC,EAAM1B,OAlFbyG,EAAN,kGT6OL1K,EAAPY,IUnNEiL,EAZCC,GAAe,IASfC,GVsNHnL,OAAS,KAAFZ,EUtNgB,GVsNX,QAAOA,EACpB,SAACb,GAEC,OAAO,IADPA,GAAQ,GACQA,IAAMyB,EAAI,GAAKzB,EAAIyB,GAAK,KUxNtCoL,EAAWrL,EAAO,IAEnBkL,EAAAI,IAAAA,EAAU,KACU,wBAAvB,0BADGJ,EAEyB,6BAA5B,+BAFGA,EAGuB,2BAA1B,iCAGmB1D,EAAN,SAAQrH,yBAAFqH,uCAAAA,wDAAAA,GAAShB,MAAApI,KAAAqI,aAI5B8E,kBAAoBzM,EAAA0M,OA/BmB,GACA,MAkCvCC,WAAa3M,EAAA0M,OAjCmB,GACA,MAiChCE,aAA4B,OAC5BC,aAAmC,OACnCC,uBAAiC,IACjCC,OAjCoB,IAkCpBC,KAAe,IACfC,eAAgC,OAChCC,aAAuB,IACvBC,sBAAgC,IAChCC,YAAiC,OACjCC,YAA2B,KAC3BC,KAAsB,yBAnBH5E,EAASrH,iBAATqH,EAAS,EAqBxBjJ,IAAA,kBAAJ,WACE,OAAOH,KAAKsN,gBAGVnN,IAAA,eAAJ,WAEE,OADA0G,EAAAC,OAAO9G,KAAKsN,aAAc,+BACnBtN,KAAKsN,aAAaW,mBAAmBjO,KAAKwN,2BAW/CrN,IAAA,yBAAJ,WACE,IAAM+N,EAAclO,KAAKsN,aACzBzG,EAAAC,OAAOoH,EAAa,+BACpB,IAAMC,EAAenO,KAAKoO,0CAC1B,OAAOpO,KAAKqO,8BAA8BH,EAAaC,MAGrDhO,IAAA,wBAAJ,WACE,IAAMgE,EAASnE,KAAKsO,mBACpB,OAAO,IAAIzL,EAAAC,QAAOqB,EAAO9D,EAAG8D,EAAOnC,EAAGhC,KAAKqN,eAGzClN,IAAA,sCAAJ,WACE,IAAM+N,EAAclO,KAAKsN,aACzBzG,EAAAC,OAAOoH,EAAa,+BACpB,IAAMC,EAAenO,KAAKoO,0CAC1B,OAAOpO,KAAKqO,8BAA8BH,EAAaC,EAAe,MAGpEhO,IAAA,4BAAJ,WACE,OAAOH,KAAKwN,0BAGVrN,IAAA,iCAAJ,WAEE,OADA0G,EAAAC,OAAO9G,KAAKsN,aAAc,8BACnBtN,KAAKsN,aAAaV,OAAS5M,KAAKwN,0BAGrCrN,IAAA,kBAAJ,WACE,OAAOH,KAAKuN,gBAGVpN,IAAA,YAAJ,WACE,OAAOH,KAAKyN,UAGVtN,IAAA,gBAAJ,WACE,OAAsB,IAAfH,KAAKuO,SAGVpO,IAAA,kBAAJ,WACE,OAAOH,KAAK4N,gBAGVzN,IAAA,iBAAJ,WACE,OAAOH,KAAK8N,eAGd3N,IAAA,qBAAA,SAAaqO,GACX,OAAOxO,KAAK+N,YAAYhC,SAASyC,MAGnCrO,IAAA,sBAAA,SAAc8K,GACZjL,KAAKsN,aAAerC,EACpBjL,KAAKwN,uBAAyB,EACzBxN,KAAKuN,cACRvN,KAAKyO,sBAITtO,IAAA,0BAAA,WACEH,KAAKyD,WACFiL,UAAUxG,GACVyG,gBAAgB3O,MACnBA,KAAKsN,aAAe,QAGtBnN,IAAA,2BAAA,WACEH,KAAKgM,2BAGP7L,IAAA,8BAAA,WACMH,KAAKsN,cAActN,KAAKsN,aAAaqB,gBAAgB3O,SAG3DG,IAAA,eAAA,SAAOyO,GACL5O,KAAK0N,MAAQkB,EACb5O,KAAK8N,YAAc,KACnB9N,KAAK+N,YAAc,GAEnB,IAAMG,EAAclO,KAAKsN,aACzBzG,EAAAC,OAAOoH,EAAa,gCAEpBlO,KAAK6O,MAAMD,EAAgBV,GAE3B,IAAMY,EAAM9O,KAAK+O,UACjBD,EACGE,aAAaC,EAAAC,uBACbC,YACCnP,KAAK+I,SACLmF,EAAYkB,mBAAmBpP,KAAKwN,wBACpCoB,EAAiB,KAErBE,EAAIO,OAAOT,GAEX5O,KAAKsP,2BAGLtP,KAAKuP,kBAAkBrB,GACvBlO,KAAKwP,gBAGPrP,IAAA,aAAA,SAAKwD,EAA+B8L,GAClC,IAAMvB,EAAclO,KAAKsN,aACzBzG,EAAAC,OAAOoH,EAAa,gCAEpBlO,KAAK+O,UAAUW,KAAK/L,EAAK8L,MAY3BtP,IAAA,qBAAA,WACE,OAAOH,KAAK+I,SAAS/G,KAGnB7B,IAAA,iBAAJ,WACE,OAA+B,OAAxBH,KAAK2N,kBAGdxN,IAAA,gBAAA,WAKE,OAJKH,KAAKgO,OACRhO,KAAKgO,cC/LqBjF,GAC9B,IAAM+F,EAAM,IAAIa,EAAA7M,QAChBgM,EAAIc,aAAaX,EAAAC,sBAAuBnG,GACxC,IAAM8G,EAASC,EAAAC,0BAIf,OAHajB,EAAIc,aAAaI,EAAAlN,QAAS+M,GAClCI,uBAAuB,IAAIC,EAAApN,QAA2B+M,IAC3Df,EAAIc,aAAaO,EAAArN,QAAa+M,GACvBf,EDwLSsB,CAAgBpQ,KAAK+I,WAG5B/I,KAAKgO,QA2Bd7N,IAAA,iCAAA,WACE,OAAO6M,EACLtM,EAAAyG,UAAU,EAAG,EAAGzG,EAAA4G,SAAS,EAlNR,IAkN2B,EAAG,EAAGtH,KAAK0N,WAI3DvN,IAAA,gCAAA,WACE,OAA4B,OAAxBH,KAAK2N,eAAgC,EAEvC,EACAV,EACEvM,EAAAyG,UACE,EACA,EACAzG,EAAA4G,SACEtH,KAAK2N,eACL3N,KAAK2N,eA/NK,IAgOV,EACA,EACA3N,KAAK0N,WAOfvN,IAAA,gDAAA,WACE,IAAMkQ,GAAcrQ,KAAKyN,OAASV,EAClC,OACE/M,KAAKwN,uBACLxN,KAAKyN,OAAS4C,GACd,IAAqBA,EAAaA,KAItClQ,IAAA,sCAAA,SAA8B+N,EAAmBnF,GAC/C,GAAIA,GAAYmF,EAAYtB,OAC1B,OAAOsB,EAAYD,mBAAmBlF,GAGxC,IAAMuH,EAAYvH,EAAWmF,EAAYtB,OACnC2D,EAAiBrC,EAAYkB,mBAAmBlB,EAAYtB,QAClE,OAAOhB,EAAA9I,QAAQ0N,UAAUD,EAAgBD,GAAW3J,IAAIuH,EAAYuC,QAGtEtQ,IAAA,yBAAA,WACE,GAAKH,KAAKsN,aAAV,CACA,IAAMoD,EAAwB1Q,KAAKsN,aAChCzD,uBACA8G,QAAO,SAAA/J,GAAQ,OAAAA,EAAKT,iBACjB0F,EAAcnL,EAAAgF,OAAOgL,GAC3B1Q,KAAKuN,aAAe1B,MAGtB1L,IAAA,cAAA,SAAMyO,EAAwBV,GAC5B,IAAM0C,EAAYhC,EAAiB,IAEnC5O,KAAK6N,sBAAwBnN,EAAAyG,UAC3B,EA5Q4B,IA8Q5BnH,KAAK6N,sBAAwBe,GAI7B5O,KAAK6N,uBAAyB,GAC9B7N,KAAK6Q,kBAAkB3C,GAEvBlO,KAAK8Q,YAAY/D,EAAc6D,EAAW1C,GAE1ClO,KAAK8Q,YA5RU,IA4RgBF,EAAW1C,GAGxB,IAAhBlO,KAAKyN,OACPzN,KAAK4N,cAAgBgB,EAErB5O,KAAK4N,aAAe,KAIxBzN,IAAA,0BAAA,SAAkB+N,GAChB,IAAM6C,EAAwB/Q,KAAKoO,0CACnC,GACEF,EAAY/C,KAAOnL,KAAKuN,cACxBW,EAAYtB,OAxSS,EAwSqBmE,EAG1C,OADA/Q,KAAK8N,YAAcZ,EAAW8D,yBACvB,EAGT,IAAMC,EAAsB/C,EAAY1B,0BACtCxM,KAAKwN,wBAGD0D,EACJH,EAAwB/Q,KAAKmN,kBAE/B,GACE8D,GACAA,EAAoBxE,sBAAwByE,EAI5C,OAFAlR,KAAK8N,YAAcZ,EAAWiE,6BAC9BnR,KAAK+N,YAAYtI,KAAKwL,IACf,EAGT,GAAI/C,EAAY/C,cAAcQ,EAAc,CAC1C,IAAMyF,EAAelD,EAAY/C,GAC3BkG,EAAoBD,EAAaE,8BACvC,GAAID,EAIF,GAFEnD,EAAYtB,OAASyE,EAAkB5E,sBAETyE,EAG9B,OAFAlR,KAAK8N,YAAcZ,EAAWiE,6BAC9BnR,KAAK+N,YAAYtI,KAAK4L,IACf,EAIX,IAAME,EAAoBH,EAAaI,8BACvC,GAAID,GAAqBA,IAAsBvR,KAG7C,GADEkO,EAAYtB,OAAS2E,EAAkB1E,2BACTqE,EAG9B,OAFAlR,KAAK8N,YAAcZ,EAAWiE,6BAC9BnR,KAAK+N,YAAYtI,KAAK8L,IACf,EAKb,QAAIvR,KAAKyR,qCAAqCvD,KAC5ClO,KAAK8N,YAAcZ,EAAWwE,4BACvB,MAsCXvR,IAAA,6CAAA,SAAqC+N,GACnC,IAAMyD,EAAkB3R,KAAKyD,WAAWiL,UAAUxG,GAC5C0J,EAAW5R,KAAK6R,kBAChBC,EAAYF,EAASzN,OACrB4N,EAAgB/R,KAAKgS,gCACrBC,EAAaL,EAASrO,WA3YV,KA4YZ2O,EAAmBP,EAAgBQ,uBAAuBF,GAE3DG,GAAW,EAAXC,GAAW,EAAXC,OAAWC,MAAhB,IAAG,IAAEC,EAAAC,EAAeP,EAAgBQ,OAAAC,cAA/BP,GAAAI,EAAAC,EAAWG,QAAAC,MAAXT,GAAW,EAAsB,CAAjC,IAAM5D,EAANgE,EAAWM,MAEd,GAAItE,IAAUxO,KAAd,CAGA,IAAM+S,EAAgBvE,EAAMqD,kBACtBmB,EAAiBD,EAAc5O,OACrC,GAAKyN,EAASqB,iBAAiBF,GAA/B,CAKA,IAAMG,EAAqB1E,EAAMwD,gCAG3BmB,EAAsBrB,EAAUsB,WAAWL,EAAc5O,QAE/D,KADyB4N,EAAcqB,WAAWF,GAC3BC,GAAvB,CAKA,IAAME,EAAiBvB,EAAUsB,WAAWF,GACtCI,EAAsBN,EAAeI,WAAWrB,GACtD,KAAIsB,EAAiBC,GAQnBD,EAAiBC,EACjB,KAFF,CASA,GAAID,IAAmBC,EACrB,OAAO7R,KAAK2L,SAAW,GAMzB,GAAIpN,KAAK4N,aArbE,OAqb0BY,EAAM+E,UAEzC,OADAvT,KAAKwT,sBACE,EAKLhF,EAAMiF,aAAazT,OAEvBA,KAAK+N,YAAYtI,KAAK+I,iBAxDnB6D,GAAW,EAAXC,EAAWoB,cAAXtB,GAAW,MAAXK,EAAWkB,QAAXlB,EAAWkB,oBAAXtB,QAAAC,GA2DL,QAAItS,KAAK+N,YAAYnB,UA4CvBzM,IAAA,2BAAA,WACEH,KAAK6N,sBA7eyB,OAgfhC1N,IAAA,oBAAA,SAAYyT,EAAsBhD,EAAmB1C,GACnD,IAAM2F,EAAY7T,KAAKyN,OACvBzN,KAAKyN,OAAS/M,EAAAyG,UACZ,EAzfY,GA2fZnH,KAAKyN,OAASmG,EAAehD,GAE/B,IAAMkD,GAAYD,EAAY7T,KAAKyN,QAAU,EAC7CzN,KAAKwN,uBAAyB9M,EAAAyG,UAC5B,EACA+G,EAAYtB,OACZ5M,KAAKwN,uBAAyBsG,EAAWlD,MAI7CzQ,IAAA,0BAAA,SAAkB+N,GAChB,GAAIlO,KAAKwN,yBAA2BU,EAAYtB,OAAQ,CACtD,GAAI5M,KAAK+T,WAAY,OACrB/T,KAAKgU,yBAAyB9F,OAIlC/N,IAAA,mBAAA,WACMH,KAAK+T,aACPlN,EAAAC,OAAO9G,KAAK2N,gBACR3N,KAAK0N,MAAQ1N,KAAK2N,eAtgBN,KAugBd3N,KAAKiU,cAKX9T,IAAA,iCAAA,SAAyB+N,GACvB,IAAMhD,EAAWgD,EAAY/C,GACvBU,EAAc7L,KAAKuN,aACrBrC,EAASnE,sBACXmE,EAASgJ,iBAAiBlU,MACtBkL,IAAaW,GACf7L,KAAKmU,0BAKXhU,IAAA,4BAAA,WACEH,KAAKoU,WAGPjU,IAAA,gBAAA,WACEH,KAAKyD,WAAWC,YAAY1D,SAG9BG,IAAA,cAAA,WACEH,KAAK2N,eAAiB3N,KAAK0N,SArhBVtE,EAAN,CAAwB9E,EAAAxB,SAAlBsG,EACZiL,UArBS,GAoBGjL,EAEZ0D,WAAaI,4HE5BDoH,GAAN,iCAAMA,IAuDP,IAAA,IAAAC,EAAAlM,UAAAuE,OAAG4H,EAAH,IAAYC,MAAZF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAGF,EAAHE,GAAArM,UAAAqM,yBAvDOJ,GAANtU,KAqDbwU,SAA0B,GAGxBxU,KAAK2U,YAALvM,MAAApI,KAAI4U,EAAAC,kBAAgBL,yBAxDHF,EAAI,EA2DvBnU,IAAA,iBAAA,WACE,OAAOH,KAAKwU,SAAS,GAAGM,cAG1B3U,IAAA,eAAA,WACE,OAAOH,KAAKwU,SAASxU,KAAKwU,SAAS5H,OAAS,GAAGmI,YAGjD5U,IAAA,kBAAA,WACE,OAAOH,KAAKwU,SAASQ,QACnB,SAACpI,EAAQqI,GAAY,OAAArI,EAASqI,EAAQC,cACtC,MAIJ/U,IAAA,2BAAA,SAAmB4I,GACjB,IAAMoM,EAAczU,EAAAyG,UAAU,EAAGnH,KAAKkV,YAAanM,GAC/CqM,EAAQ,EACPhD,GAAa,EAAbC,GAAa,EAAbC,OAAaC,MAAlB,IAAG,IAAEC,EAAAC,EAAiBzS,KAAKwU,SAAQ9B,OAAAC,cAA9BP,GAAAI,EAAAC,EAAaG,QAAAC,MAAbT,GAAa,EAAmB,CAAhC,IAAM6C,EAANzC,EAAaM,MAChB,GAAIqC,GAAeC,EAAQH,EAAQC,YACjC,OAAOD,EAAQhH,mBAAmBkH,EAAcC,GAElDA,GAASH,EAAQC,sBAJd7C,GAAa,EAAbC,EAAaoB,cAAbtB,GAAa,MAAbK,EAAakB,QAAblB,EAAakB,oBAAbtB,QAAAC,GAML,MAAM,IAAI/M,MAAM,8CAGlBpF,IAAA,2BAAA,SAAmB4I,GACjB,IAAMoM,EAAczU,EAAAyG,UAAU,EAAGnH,KAAKkV,YAAanM,GAC/CqM,EAAQ,EACPhD,GAAa,EAAbC,GAAa,EAAbC,OAAaC,MAAlB,IAAG,IAAEC,EAAAC,EAAiBzS,KAAKwU,SAAQ9B,OAAAC,cAA9BP,GAAAI,EAAAC,EAAaG,QAAAC,MAAbT,GAAa,EAAmB,CAAhC,IAAM6C,EAANzC,EAAaM,MAChB,GAAIqC,GAAeC,EAAQH,EAAQC,YACjC,OAAOD,EAAQ7F,mBAAmB+F,EAAcC,GAElDA,GAASH,EAAQC,sBAJd7C,GAAa,EAAbC,EAAaoB,cAAbtB,GAAa,MAAbK,EAAakB,QAAblB,EAAakB,oBAAbtB,QAAAC,GAML,MAAM,IAAI/M,MAAM,8CAGlBpF,IAAA,mBAAA,SAAW8U,GACT,IAAMI,EAAcrV,KAAKwU,SAASxU,KAAKwU,SAAS5H,OAAS,GAUzD,OATIyI,GACFxO,EAAAC,OACEuO,EAAYN,SAASO,OAAOL,EAAQH,YACnC,wCAEoBtP,OAFmB6P,EACrCN,SACA/Q,WAAW,SAAqCwB,OAA9ByP,EAAQH,WAAW9Q,aAG5ChE,KAAKwU,SAAS/O,KAAKwP,GACZjV,QAGTG,IAAA,oBAAA,WAAY,IAAA,IAAAoU,EAAAlM,UAAAuE,OAAG4H,EAAH,IAAYC,MAAZF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAGF,EAAHE,GAAArM,UAAAqM,cAEV,OADAF,EAAStL,SAAQ,SAAA+L,GAAW,OAAM5L,EAADkM,WAAWN,MACrCjV,QAGTG,IAAA,kBAAA,SAAUiE,qBACFoR,EAAcxV,KAAKwU,SAASnI,KAAI,SAAC4I,EAAS1U,GAC9C,IAAM8U,EAAoB,IAAN9U,EAAU,KAAI8I,EAAQmL,SAASjU,EAAI,GACvD,IAAK8U,EACH,OAAIJ,aAAmBQ,EAAA3S,QAA4B,KAC5CmS,EAGT,KAAMA,aAAmBQ,EAAA3S,SAAsB,OAAOmS,EACtD,KAAMI,aAAuBI,EAAA3S,SAAsB,OAAO,KAE1D+D,EAAAC,OACEuO,EAAYN,SAASO,OAAOL,EAAQH,YACpC,sBAGF,IAAMY,EAAaL,EAAYM,MACzBC,EAAYX,EAAQU,MACpBE,EAAepU,KAAK6B,IACxBc,EACAiR,EAAYH,YAAc,EAC1BD,EAAQC,YAAc,GAGlBY,EAAmB,IAAIjT,EAAAC,QAC3BmS,EAAQH,WAAWzU,EACnB4U,EAAQH,WAAW9S,EACnB6T,GAGF,OAAOvB,EAAKyB,oBAAoBD,EAAkBJ,EAAYE,MAG1DI,EAAYtV,EAAAuV,QAAQT,GAEpBjK,EAAQvL,KAAK8U,WACbrE,EAAMzQ,KAAK+U,SACbmB,EAAY3K,EAkBhB,OAjBAvL,KAAKwU,SAAW,GAEhBwB,EAAU9M,SAAQ,SAAA+L,GACZA,EAAQH,WAAWQ,OAAOY,MAGvBX,WAAW,IAAIE,EAAA3S,QAAoBoT,EAAWjB,EAAQH,aAHtBqB,EAChCZ,WAAWN,GAMlBiB,EAAYjB,EAAQF,YAGjBmB,EAAUZ,OAAO7E,IACpBzQ,KAAKuV,WAAW,IAAIE,EAAA3S,QAAoBoT,EAAWzF,IAG9CzQ,UA3KFG,IAAA,8BAAP,WAA6B,IAAA,IAAAoU,EAAAlM,UAAAuE,OAAGwJ,EAAH,IAAU3B,MAAVF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAG0B,EAAH1B,GAAArM,UAAAqM,GAC3B,IAAsC2B,EAAMzB,EAAA0B,QAANF,GAAjCF,EAAiCG,EAAM,GAAzBE,EAAmBF,EAAMG,MAA5B,GACVC,EAAO,IAAInC,EAEZlC,GAAW,EAAXC,GAAW,EAAXC,OAAWC,MAAhB,IAAG,IAAEC,EAAAC,EAAe8D,EAAe7D,OAAAC,cAA9BP,GAAAI,EAAAC,EAAWG,QAAAC,MAAXT,GAAW,EAAqB,CAAhC,IAAMsE,EAANlE,EAAWM,MACd2D,EAAKlB,WAAW,IAAIE,EAAA3S,QAAoBoT,EAAWQ,IACnDR,EAAYQ,YAFTrE,GAAW,EAAXC,EAAWoB,cAAXtB,GAAW,MAAXK,EAAWkB,QAAXlB,EAAWkB,oBAAXtB,QAAAC,GAKL,OAAOmE,KAGFtW,IAAA,4BAAP,SACE2V,EACAJ,EACAE,GAEAF,GAA0BjU,KAAKE,GAC/B,IAAMgV,EAAab,EAAiBrP,qBAAqBiP,GACnDkB,EAAYd,EAAiBrP,qBAAqBmP,GAElDiB,EAAkB,IAAIC,GAAAhU,QAC1BgT,EAAiB3R,OACjBwS,GACAI,8BAA8BJ,GAC1BK,EAAiB,IAAIF,GAAAhU,QACzBgT,EAAiB3R,OACjByS,GACAG,8BAA8BH,GAEhC,GAAIC,EAAgBI,aAAaD,GAC/B,OAAO,IAAIvB,EAAA3S,QAAoB6T,EAAYC,GAG7C,IAAMM,EAAmBL,EAAgBM,wBACvCH,GAEII,EAAmBT,EAAWvD,WAAW8D,GAO/C,OAAO,IAAIG,EAAAvU,QACToU,EACAE,EACAT,EAAWW,IAAIJ,GAAkBvB,MACjCiB,EAAUU,IAAIJ,GAAkBvB,WAjDjBrB,EAAN,GCNMiD,kFAAN,SAAQxV,yBAAFwV,EAOPlX,EAAW2B,EAAWoC,sCAPfmT,wDAAAA,GAAQ5U,KAAA3C,QAE3BwX,sBAAiE,KACjEC,uBAA4C,IAAI/Q,MAChDgR,uBAA4C,IAAIhR,MAChDiR,OAAiB,KAIV/U,QAAU,IAAIC,EAAAC,QAAOzC,EAAG2B,EAAGoC,uBATfmT,EAAQxV,iBAARwV,EAAQ,EAYvBpX,IAAA,eAAJ,WACE,OAAOH,KAAK4C,QAAQuB,UAGtBhE,IAAA,uBAAA,SAAe2H,0BAhBIyP,EAAQ9O,WAiBnB,iBAANzI,MAAK2C,KAAA3C,KAAgB8H,GACrB9H,KAAK2X,OAAOzO,SAAQ,SAAA+B,GAAQ,OAAAnD,EAAM8P,SAAS3M,SAG7C9K,IAAA,wCAAA,SAAgCqG,GAC9B,OAAOxG,KAAK4C,QAAQ6D,qBAAqBD,MAG3CrG,IAAA,6BAAA,SACE8K,EACA0K,EACAzQ,cAEMkM,EAAepR,KAAK6X,qBAAqBlC,GAC/CvE,EAAa0G,UAAU7M,EAAM/F,GAE7B,IAAM6S,EACJ7S,IAAcL,EAAoBM,IAClCnF,KAAKyX,uBAAuB3N,IAAIsH,GAE5B4G,EACJ9S,IAAcL,EAAoBQ,KAClCrF,KAAK0X,uBAAuB5N,IAAIsH,GAgClC,OA9BI2G,GAAY/X,KAAKyX,uBAAuB9Q,IAAIyK,GAC5C4G,GAAYhY,KAAK0X,uBAAuB/Q,IAAIyK,GAEhDpR,KAAKiY,eAAe/O,SAAQ,SAAAsF,GAC1B,GAAIA,IAAU4C,EAAd,CAEA,GAAI2G,GAAU1O,EAASqO,uBAAuB5N,IAAI0E,GAAQ,CACxD,IAAMiI,EAAO,IAAInC,GACfA,GAAKyB,oBAAmB1M,EACjBzG,QAAOyG,EACPzG,QAAQuB,OAAOmT,IAAIlG,EAAarI,UAAU4M,MAC/CnH,EAAMzF,SAASuO,IAAGjO,EAAMzG,QAAQuB,QAAQwR,UAIvCuC,SAAS,IAAIC,GAAK/G,EAAc5C,EAAO,CAAEiI,KAAAA,KAGhD,GAAIuB,GAAU3O,EAASoO,uBAAuB3N,IAAI0E,GAAQ,CACxD,IAAM4J,EAAO,IAAI9D,GACfA,GAAKyB,oBAAmB1M,EACjBzG,QAAOyG,EACPzG,QAAQuB,OAAOmT,IAAI9I,EAAMzF,UAAU4M,MACxCvE,EAAarI,SAASuO,IAAGjO,EAAMzG,QAAQuB,QAAQwR,UAG9CuC,SAAS,IAAIC,GAAK3J,EAAO4C,EAAc,CAAEqF,KAAA2B,UAI3ChH,KAGTjR,IAAA,6BAAA,SAAqBwV,GACnB,IAAM0C,EAAW1C,EAAM3R,WACvB,GAAIhE,KAAKwX,sBAAsBa,GAC7B,OAAOrY,KAAKwX,sBAAsBa,GAGpC,IAAMjH,EAAepR,KAAKsY,2BAA2B3C,GAErD,OADA3V,KAAKwX,sBAAsBa,GAAYjH,EAChCA,KAGTjR,IAAA,mCAAA,SAA2BwV,GACzB,IAAM5M,EAAW/I,KAAKuY,gCAAgC5C,GACtD,OAAO,IAAIhK,EAAa5C,EAAS1I,EAAG0I,EAAS/G,MAG3C7B,IAAA,qBAAJ,sBACE,OAAOO,EAAAuV,QACLuC,OAAOC,KAAKzY,KAAKwX,uBAAuBnL,KACtC,SAAAsJ,GAAS,OAAMtM,EAADmO,sBAAsB7B,UAK1CxV,IAAA,iBAAA,SAAS8K,GACPjL,KAAK2X,OAAOlS,KAAKwF,GACbjL,KAAK0Y,YACP1Y,KAAKyD,WAAWmU,SAAS3M,OArGVsM,EAAN,CAAuBjT,EAAAxB,UCGhC6V,GAAkBhU,EAAOoB,OAAO,IAIhC6S,GAAkB,CAAC,EAAG,IACtBC,GAAyBD,GAAgB5D,QAAO,SAAC8D,EAAGC,GAAM,OAAAD,EAAIC,IAAG,GASlDZ,GAAN,SAAQpW,yBAAFoW,EAQjB1M,EACAN,EACAlK,OAee+X,WAf8B,IAA7C/X,EAA2C,GAA3CA,EAAEmV,EAAMhM,EAANgM,OAAQ6C,EAAS7O,EAAT6O,UAAWxC,EAAIrM,EAAJqM,2BAVJ0B,wDAAAA,GAAIxV,KAAA3C,QACvBkZ,QAAS,IAITC,mBAAkC,GAShC,IAAMC,EAAYhD,EACd3K,EAAK1C,SAASsQ,QAAQjD,EAAO,IAC7B3K,EAAK1C,SAASsQ,QAAQlO,EAAGpC,UAEvBsQ,EAAUjD,EACZjL,EAAGpC,SAASsQ,QAAQjD,EAAOA,EAAOxJ,OAAS,IAC3CzB,EAAGpC,SAASsQ,QAAQ5N,EAAK1C,iBAErBM,EACDiQ,MADH7C,IAEOL,GACI4C,EAAA1E,IAAKiF,sBAALnR,MAAA4Q,EAAA,CACXvN,EAAK8M,gCAAgCa,IAD1B5T,OAIZoP,EAAAC,kBAFIuB,GAFQ,CAGXjL,EAAGoN,gCAAgCc,OAGxB,IAAI/E,IAAOiB,WACtB,IAAIE,EAAA3S,QACF2I,EAAK8M,gCAAgCa,GACrCjO,EAAGoN,gCAAgCc,MAKxB,MAAbJ,GAAiB5P,EACdiQ,MAAML,UAAUA,GAGnBxN,aAAgB8L,GAAQlO,EACrBoC,KAAOA,EAAK+N,qBAAoB5E,EAAA6E,sBAAApQ,GAEnC+P,EACAvU,EAAoBQ,QAGjBoG,KAAOA,EACZA,EAAKqM,UAASlD,EAAA6E,sBAAApQ,GAAOxE,EAAoBQ,MAGvC8F,aAAcoM,GAAQlO,EACnB8B,GAAKA,EAAGqO,qBAAoB5E,EAAA6E,sBAAApQ,GAAOgQ,EAASxU,EAAoBM,OAEhEgG,GAAKA,EACVA,EAAG2M,UAASlD,EAAA6E,sBAAApQ,GAAOxE,EAAoBM,yBA1DxBgT,EAAIpW,iBAAJoW,EAAI,EA8DnBhY,IAAA,aAAJ,WACE,OAAOH,KAAKsZ,MAAMpE,eAGhB/U,IAAA,YAAJ,WACE,OAAOH,KAAKsZ,MAAMxE,cAGhB3U,IAAA,UAAJ,WACE,OAAOH,KAAKsZ,MAAMvE,YAGhB5U,IAAA,iCAAJ,WACE,GAAIH,KAAKmZ,mBAAmBvM,OAAQ,CAClC,IAAMkH,EACJ9T,KAAKmZ,mBAAmBnE,QACtB,SAAC0E,EAAKpR,GAAc,OAAAoR,EAAMpR,EAAUiG,QACpC,GACEvO,KAAKmZ,mBAAmBvM,OAC9B,OAAO5M,KAAK4M,OAASkH,EAGvB,OAAO9T,KAAK4M,QAAgC,GAAtBxD,EAAUiL,cAGlClU,IAAA,+BAAA,WACE,IAAMwZ,EAAgB3Z,KAAKwM,0BAA0B,GACrD,OAAKmN,GAEHA,EAAclN,sBAAwBkN,EAAcxM,qBAIxDhN,IAAA,4BAAA,SAAoBmI,GAClBtI,KAAKmZ,mBAAmB1T,KAAK6C,GAC7BA,EAAUsR,cAAc5Z,SAG1BG,IAAA,wBAAA,SAAgBmI,GACd,IAAMuR,EAAQ7Z,KAAKmZ,mBAAmBW,QAAQxR,GAC9C,OAAc,IAAVuR,IACJ7Z,KAAK+Z,uBAAuBF,IACrB,MAGT1Z,IAAA,+BAAA,SAAuB0Z,GACrB,IAAMvR,EAAYtI,KAAKmZ,mBAAmBU,GAG1C,OAFA7Z,KAAKmZ,mBAAmBa,OAAOH,EAAO,GACtCvR,EAAU2R,oBACH3R,KAGTnI,IAAA,6BAAA,SAAqBc,OAAAiL,OAAqC,IAArCjL,EAA4B,IAAIyF,IAAhCzF,EAEnB,OAAIiL,EAAQpC,IAAI9J,KAAKmL,IADP,GAERyJ,EAAAC,kBAAK7U,KAAKmL,GAAGtB,qBAAqBqC,IAAO1G,OAAxC,CAA2CxF,KAAKmL,QAGzDhL,IAAA,2BAAA,SAAmB4I,GACjB,OAAO/I,KAAKsZ,MAAMrL,mBAAmBlF,MAGvC5I,IAAA,2BAAA,SAAmB4I,GACjB,OAAO/I,KAAKsZ,MAAMlK,mBAAmBrG,MAGvC5I,IAAA,kCAAA,SAA0B4I,GACxB,IAAIuD,EAAgB,KAChB4N,EAAerP,EAAAA,EAWnB,OATA7K,KAAKmZ,mBAAmBjQ,SAAQ,SAAAZ,GAC9B,IAAM6R,EAAW7R,EAAUmE,sBAAwB1D,EAC/CoR,GAAY,GACZA,EAAWD,IACbA,EAAeC,EACf7N,EAAgBhE,MAIbgE,KAGTnM,IAAA,mCAAA,SAA2B4I,GACzB,IAAIuD,EAAgB,KAChB4N,EAAerP,EAAAA,EAWnB,OATA7K,KAAKmZ,mBAAmBjQ,SAAQ,SAAAZ,GAC9B,IAAM6R,EAAWpR,EAAWT,EAAUmE,sBAClC0N,GAAY,GACZA,EAAWD,IACbA,EAAeC,EACf7N,EAAgBhE,MAIbgE,KAGTnM,IAAA,aAAA,SAAKwD,EAA+BsE,GAClCtE,EAAIC,YACJD,EAAIyW,QAAU,QACdzW,EAAI0W,SAAW,QACfpW,EAAAwS,KAAkB9S,EAAK3D,KAAKsZ,OAU5B,IAAMgB,EAAYta,KAAKua,oBACjBC,EAAa3B,GAAyByB,EAC5C3W,EAAI8W,YAAY7B,GAAgBvM,KAAI,SAAAO,GAAU,OAAAA,EAAS0N,MACvD3W,EAAI+W,YAAc/B,GAAgB3U,WAClCL,EAAIgX,eA1LgB,KA0LG1S,EAAyBqS,EAAaE,EAC7D7W,EAAIiX,UA9LgB,EAiMpBjX,EAAIkX,YAGN1a,IAAA,0BAAA,WACE,IACM2a,EADiBrZ,KAAKsZ,MAAM/a,KAAK4M,OAASiM,IACPA,GAWzC,OATwB7Y,KAAK4M,OAASkO,EAEpCA,EAAkBjC,GAAyB7Y,KAAK4M,OAI5C5M,KAAK4M,OAASkO,EACd9a,KAAK4M,QAAUkO,EAAkBjC,QApMtBV,EAAN,CAAmB7T,EAAAxB,SCH5BkY,GAAazW,EAAKqB,QAAQ,IAC1BqV,GAAc1W,EAAKwB,OAAO,IAC1BmV,GAAc3W,EAAKqB,QAAQ,IAAK7B,KAAK,IAEtBoX,GAAN,SAAQpZ,yBAAFoZ,EASP9a,EAAW2B,EAAWf,SAAAiF,OAAmC,IAAnCjF,EAvBX,IAuBWA,+BATfka,wDAAAA,GAAQxY,KAAA3C,QAC3BmG,eAAgB,IAChBY,qBAAsB,IAKtBV,eAAgC,IAAIvB,IAI7BlC,QAAU,IAAIC,EAAAC,QAAOzC,EAAG2B,EAvBlB,MAwBNsE,wBAA0B,IAAIzD,EAAAC,QAAOzC,EAAG2B,EAvBhB,MAwBxBuE,UAAYL,IACZE,OAASF,sBAdGiV,EAAQpZ,iBAARoZ,EAAQ,EAiBvBhb,IAAA,eAAJ,WACE,OAAOH,KAAK4C,QAAQuB,UAGlBhE,IAAA,0BAAJ,WACE,OAAOH,KAAKqG,eAAetB,YAGzB5E,IAAA,0BAAJ,WACE,OAAOH,KAAKqG,eAAerB,YAG7B7E,IAAA,6BAAA,SAAqBc,OAAAiL,OAAqC,IAArCjL,EAA4B,IAAIyF,IAAhCzF,EAEnB,OADAiL,EAAQvF,IAAI3G,MACLU,EAAAyL,KACLzL,EAAA0L,QACEpM,KAAKqG,eAAerB,SAASqH,KAAI,SAAApB,GAC/B,OAAAA,EAAKpB,qBAAqBqC,WAMlC/L,IAAA,wCAAA,SAAgCqG,GAC9B,OAAOxG,KAAKsG,wBAAwBG,qBAAqBD,MAG3DrG,IAAA,yBAAA,WACE,MAAM,IAAIoF,MAAM,wCAGlBpF,IAAA,kBAAA,SAAUyG,EAAY1B,GACpBlF,KAAKqG,eAAeM,IAAIC,EAAM1B,MAGhC/E,IAAA,eAAA,SAAO+G,GACLlH,KAAKoG,OAAS1F,EAAAyG,UAAU,EAAGnH,KAAKuG,UAAWvG,KAAKoG,OAASc,GACrDlH,KAAKoG,QAAUpG,KAAKuG,WACtBvG,KAAKob,iBAITjb,IAAA,aAAA,SAAKwD,GACH,IAAMyD,EAAWpH,KAAKoG,OAASpG,KAAKuG,UAE9Bc,EAAiB3G,EAAAyG,UACrB,EACA,EACAzG,EAAA4G,SAAS,EAvEa,IAuEW,EAAG,EAAGtH,KAAKoG,SAExCmB,EAAUyT,GAAWxT,IAAIyT,GAAa5T,GAE5C1D,EAAIC,YACJD,EAAIG,UAAYyD,EAAQvD,WACxBC,EAAAC,OACEP,EACA3D,KAAK4C,QAAQuB,OAAO9D,EACpBL,KAAK4C,QAAQuB,OAAOnC,EACpBhC,KAAK4C,QAAQwB,QAEfT,EAAIU,OAEJV,EAAIC,YACJD,EAAIG,UAAYmX,GAAYjX,WAC5BL,EAAI8D,OAAOzH,KAAK4C,QAAQuB,OAAO9D,EAAGL,KAAK4C,QAAQuB,OAAOnC,GACtD2B,EAAI0X,IACFrb,KAAK4C,QAAQuB,OAAO9D,EACpBL,KAAK4C,QAAQuB,OAAOnC,EACpBhC,KAAK4C,QAAQwB,QACZ3C,KAAKE,GAAK,EACA,EAAXyF,EAAe3F,KAAKE,GAAKF,KAAKE,GAAK,GACnC,GAEFgC,EAAIU,OAEJV,EAAIC,YACJD,EAAIG,UAAYkX,GAAWhX,WAC3BC,EAAAC,OACEP,EACA3D,KAAK4C,QAAQuB,OAAO9D,EACpBL,KAAK4C,QAAQuB,OAAOnC,EA3GLsZ,IA8GjB3X,EAAIU,UAGNlE,IAAA,oBAAA,WACEH,KAAKoG,OAAS,KAGhBjG,IAAA,oBAAA,WAC2BH,KAAKub,0BAE5Bvb,KAAKiH,SACLjH,KAAKgH,kBAIT7G,IAAA,eAAA,WACEH,KAAKyD,WAAWkE,eACd3H,KACA,IAAI8B,EAAM,CACRzB,EAAGL,KAAK4C,QAAQuB,OAAO9D,EACvB2B,EAAGhC,KAAK4C,QAAQuB,OAAOnC,EACvBC,YArIO,GAsIPC,UAnIa,GAoIbC,SAlIe,IAmIfC,MAAO8Y,GACP5Y,WAAYd,EACZkB,kBAAkB,QAKxBvC,IAAA,8BAAA,WACE,IAAM8K,EAAOjL,KAAKqG,eAAemV,iBACjC,KAAMvQ,aAAgBkN,IAAO,OAAO,EAEpC,GAAIlN,EAAKwQ,yBAA0B,CACjC,IAAMnT,EAAY,IAAIc,EAGtB,OAFA6B,EAAKgB,oBAAoB3D,GACzBtI,KAAKyD,WAAWmU,SAAStP,IAClB,EAEP,OAAO,MA7IQ6S,EAAN,CAAuB7W,EAAAxB,SClBhC4Y,iBAAQ,IAERC,GAAQ,IAAIC,EAAA9Y,QAAM,IAAK,IAAK+Y,OAAOC,kBACnCC,GAAOC,SAASC,eAAe,QACrCpV,EAAAC,OAAOiV,GAAM,yBACbJ,GAAMO,SAASH,IAGfJ,GAAMQ,UAAU,IAAIjU,cAyDlB,IAAMkU,EAAgB,IAAInW,EAAS,IAAK,IAAK,MACvCoW,EAAiB,IAAIpW,EAAS,IAAK,IAAK,MACxCqW,EAAgB,IAAIrW,EAAS,IAAK,IAAK,MACvCsW,EAAe,IAAIpB,GAAS,IAAK,IAAK,KACtCqB,EAAe,IAAIrB,GAAS,IAAK,IAAK,KAG5CQ,GAAM/D,SAASwE,GACfT,GAAM/D,SAASyE,GACfV,GAAM/D,SAAS0E,GACfX,GAAM/D,SAAS2E,GACfZ,GAAM/D,SAAS4E,GAEf,IAAMC,EAAe,IAAIlF,GAAS,IAAK,IAAKmE,IACtCgB,EAAoB,IAAInF,GAAS,IAAK,IAAKmE,IAC3CiB,EAAoB,IAAIpF,GAAS,IAAK,IAAKmE,IACjDC,GAAM/D,SAAS6E,GACfd,GAAM/D,SAAS8E,GACff,GAAM/D,SAAS+E,GACfhB,GAAM/D,SAAS,IAAIO,GAAKqE,EAAcC,IACtCd,GAAM/D,SAAS,IAAIO,GAAKoE,EAAcG,IACtCf,GAAM/D,SAAS,IAAIO,GAAKuE,EAAmBC,IAQ3ChB,GAAM/D,SACJ,IAAIO,GAAKuE,EAAmBD,EAAc,CACxCrG,OAAQ,CAAC,IAAIxK,EAAA9I,QAAQ,IAAK,KAAM,IAAI8I,EAAA9I,QAAQ,IAAK,KACjDmW,UAAWyC,MAKfC,GAAM/D,SAAS,IAAIO,GAAKsE,EAAcE,IACtChB,GAAM/D,SAAS,IAAIO,GAAKwE,EAAmBP,IAC3CT,GAAM/D,SAAS,IAAIO,GAAKsE,EAAcJ,IACtCV,GAAM/D,SAAS,IAAIO,GAAKsE,EAAcH,IA/FxCM,GAEAjB,GAAMpQ","sources":["src/lib/easings.ts","src/network/ConnectionDirection.ts","src/network/effects/Pulse.ts","src/network/colors.ts","src/network/ConnectionSet.ts","src/network/networkNodes/Consumer.ts","src/lib/scene/SceneSystem.ts","src/network/TravellerFinder.ts","src/network/PathFinder.ts","src/network/networkNodes/Intersection.ts","src/network/Traveller.ts","src/pals/makePal.ts","src/lib/geom/Path.ts","src/network/Junction.ts","src/network/Road.ts","src/network/networkNodes/Producer.ts","src/network/network-main.ts"],"sourcesContent":["import { approxEq } from './utils';\n\n/** n should be between 0 and 1 */\nexport type Easing = (n: number) => number;\n\n// based on https://github.com/servo/servo/blob/0d0cfd030347ab0711b3c0607a9ee07ffe7124cf/components/style/bezier.rs\nclass UnitBezier {\n  private static readonly NEWTON_METHOD_ITERATIONS = 8;\n  private static readonly DEFAULT_EPSILON = 1e-6;\n  private readonly ax: number;\n  private readonly bx: number;\n  private readonly cx: number;\n  private readonly ay: number;\n  private readonly by: number;\n  private readonly cy: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    const cx = 3 * x1;\n    const bx = 3 * (x2 - x1) - cx;\n\n    const cy = 3 * y1;\n    const by = 3 * (y2 - y1) - cy;\n\n    this.ax = 1.0 - cx - bx;\n    this.bx = bx;\n    this.cx = cx;\n    this.ay = 1.0 - cy - by;\n    this.by = by;\n    this.cy = cy;\n  }\n\n  private sampleCurveX(t: number): number {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }\n\n  private sampleCurveY(t: number): number {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }\n\n  private sampleCurveDerivativeX(t: number): number {\n    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n  }\n\n  private solveCurveX(x: number, epsilon: number): number {\n    // Fast path: Use Newton's method.\n    let t = x;\n    for (let i = 0; i < UnitBezier.NEWTON_METHOD_ITERATIONS; i++) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      let dx = this.sampleCurveDerivativeX(t);\n      if (approxEq(dx, 0.0, 1e-6)) {\n        break;\n      }\n      t -= (x2 - x) / dx;\n    }\n\n    // Slow path: Use bisection.\n    let lo = 0;\n    let hi = 1;\n    t = x;\n\n    if (t < lo) {\n      return lo;\n    }\n    if (t > hi) {\n      return hi;\n    }\n\n    while (lo < hi) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      if (x > x2) {\n        lo = t;\n      } else {\n        hi = t;\n      }\n      t = (hi - lo) / 2.0 + lo;\n    }\n\n    return t;\n  }\n\n  solve(x: number, epsilon: number = UnitBezier.DEFAULT_EPSILON): number {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n  }\n}\n\nexport const cubicBezier = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): Easing => {\n  const bezier = new UnitBezier(x1, y1, x2, y2);\n  return (x) => bezier.solve(x);\n};\n\n/**\n * P(t) = (1-t)^3*P0 + 3*t*(1-t)^2*P1 + 3*t^2*(1-t)*P2 + t^3*P3\n * x = 3*t*(1-t)^2*p1x + 3*t^2*(1-t)*p2x + t^3\n * y(t) = 3*t*(1-t)^2*p1y + 3*t^2*(1-t)*p2y + t^3\n *\n *\n * y = 3*u1*(1-x)^2*x + 3*u2*(1-x)*x^2 + x^3\n */\n\n// https://gist.github.com/rezoner/713615dabedb59a15470\n// http://gsgd.co.uk/sandbox/jquery/easing/\nexport const reverse =\n  (easing: (n: number) => number) =>\n  (n: number): number =>\n    easing(1 - n);\n\nexport const linear = (n: number): number => n;\n\nexport const inQuad = (t: number): number => t * t;\n\nexport const outQuad = (t: number): number => t * (2 - t);\n\nexport const inOutQuad = (t: number): number =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\nexport const inCubic = (t: number): number => t * t * t;\n\nexport const outCubic = (t: number): number => --t * t * t + 1;\n\nexport const inOutCubic = (t: number): number =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nexport const inQuart = (t: number): number => t * t * t * t;\n\nexport const outQuart = (t: number): number => 1 - --t * t * t * t;\n\nexport const inOutQuart = (t: number): number =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\nexport const inQuint = (t: number): number => t * t * t * t * t;\n\nexport const outQuint = (t: number): number => 1 + --t * t * t * t * t;\n\nexport const inOutQuint = (t: number): number =>\n  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nexport const inSine = (t: number): number =>\n  -1 * Math.cos((t / 1) * (Math.PI * 0.5)) + 1;\n\nexport const outSine = (t: number): number =>\n  Math.sin((t / 1) * (Math.PI * 0.5));\n\nexport const inOutSine = (t: number): number =>\n  (-1 / 2) * (Math.cos(Math.PI * t) - 1);\n\nexport const inExpo = (t: number): number =>\n  t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n\nexport const outExpo = (t: number): number =>\n  t == 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n\nexport const inOutExpo = (t: number): number => {\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if ((t /= 1 / 2) < 1) return (1 / 2) * Math.pow(2, 10 * (t - 1));\n  return (1 / 2) * (-Math.pow(2, -10 * --t) + 2);\n};\n\nexport const inCirc = (t: number): number => -1 * (Math.sqrt(1 - t * t) - 1);\n\nexport const outCirc = (t: number): number => Math.sqrt(1 - (t = t - 1) * t);\n\nexport const inOutCirc = (t: number): number => {\n  if ((t /= 1 / 2) < 1) return (-1 / 2) * (Math.sqrt(1 - t * t) - 1);\n  return (1 / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1);\n};\n\nexport const inElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return -(\n    a *\n    Math.pow(2, 10 * (t -= 1)) *\n    Math.sin(((t - s) * (2 * Math.PI)) / p)\n  );\n};\n\nexport const outElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return a * Math.pow(2, -10 * t) * Math.sin(((t - s) * (2 * Math.PI)) / p) + 1;\n};\n\nexport const inOutElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if ((t /= 1 / 2) == 2) return 1;\n  if (!p) p = 0.3 * 1.5;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  if (t < 1)\n    return (\n      -0.5 *\n      (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p))\n    );\n  return (\n    a *\n      Math.pow(2, -10 * (t -= 1)) *\n      Math.sin(((t - s) * (2 * Math.PI)) / p) *\n      0.5 +\n    1\n  );\n};\n\nexport const inBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    return 1 * t * t * ((s + 1) * t - s);\n  };\n\nexport const outBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    t = t - 1;\n    return 1 * (t * t * ((s + 1) * t + s) + 1);\n  };\n\nexport const inOutBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    if ((t /= 1 / 2) < 1)\n      return (1 / 2) * (t * t * (((s *= 1.525) + 1) * t - s));\n    return (1 / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  };\n\nexport const inBounce = (t: number): number => {\n  return 1 - outBounce(1 - t);\n};\n\nexport const outBounce = (t: number): number => {\n  if ((t /= 1) < 1 / 2.75) {\n    return 7.5625 * t * t;\n  } else if (t < 2 / 2.75) {\n    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n  } else if (t < 2.5 / 2.75) {\n    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n  } else {\n    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n  }\n};\n\nexport const inOutBounce = (t: number): number => {\n  if (t < 1 / 2) return inBounce(t * 2) * 0.5;\n  return outBounce(t * 2 - 1) * 0.5 + 0.5;\n};\n","enum ConnectionDirection {\n  IN = 'in',\n  OUT = 'out',\n}\n\nexport default ConnectionDirection;\n","import Color from 'color';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport Circle from '../../lib/geom/Circle';\nimport { linear, Easing } from '../../lib/easings';\nimport { lerp } from '../../lib/utils';\n\ntype PulseOptions = {\n  x: number;\n  y: number;\n  startRadius: number;\n  endRadius: number;\n  duration: number;\n  color: Color;\n  easeRadius?: Easing;\n  easeOpacity?: Easing;\n  removeOnComplete?: boolean;\n};\n\nexport default class Pulse extends SceneObject {\n  _circle: Circle;\n  _startRadius: number;\n  _endRadius: number;\n  _duration: number;\n  _color: Color;\n  _progress: number;\n  _easeRadius: Easing;\n  _easeOpacity: Easing;\n  _removeOnComplete: boolean;\n\n  constructor({\n    x,\n    y,\n    startRadius,\n    endRadius,\n    duration,\n    color,\n    easeRadius = linear,\n    easeOpacity = linear,\n    removeOnComplete = false,\n  }: PulseOptions) {\n    super();\n    this._circle = new Circle(x, y, startRadius);\n    this._startRadius = startRadius;\n    this._endRadius = endRadius;\n    this._duration = duration;\n    this._color = color;\n    this._progress = 0;\n    this._easeRadius = easeRadius;\n    this._easeOpacity = easeOpacity;\n    this._removeOnComplete = removeOnComplete;\n  }\n\n  update(deltaTime: number) {\n    const deltaProgress = deltaTime / this._duration;\n    this._progress = Math.min(1, this._progress + deltaProgress);\n    this._circle = this._circle.withRadius(\n      lerp(\n        this._startRadius,\n        this._endRadius,\n        this._easeRadius(this._progress),\n      ),\n    );\n\n    if (this._progress === 1 && this._removeOnComplete) {\n      this.getScene().removeChild(this);\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    const opacity = this._easeOpacity(this._progress);\n    ctx.fillStyle = this._color.fade(opacity).toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n  }\n}\n","import Color from 'color';\n\n// https://coolors.co/f8ffe5-06d6a0-1b9aaa-ef476f-ffc43d\nexport const LIGHT_BG = new Color('#F8FFE5');\nexport const TEAL = new Color('#06D6A0');\nexport const BLUE = new Color('#1B9AAA');\nexport const RED = new Color('#EF476F');\nexport const YELLOW = new Color('#FFC43D');\n","import { sample } from '../lib/utils';\nimport Road from './Road';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class ConnectionSet {\n  incoming: Road[] = [];\n  outgoing: Road[] = [];\n\n  add(target: Road, direction: ConnectionDirection) {\n    switch (direction) {\n      case ConnectionDirection.IN:\n        this.addIncoming(target);\n        break;\n      case ConnectionDirection.OUT:\n        this.addOutgoing(target);\n        break;\n      default:\n        throw new Error(`unknow connection direction ${direction}`);\n    }\n  }\n\n  addIncoming(target: Road) {\n    this.incoming.push(target);\n  }\n\n  addOutgoing(target: Road) {\n    this.outgoing.push(target);\n  }\n\n  sampleIncoming(): Road {\n    return sample(this.incoming);\n  }\n\n  sampleOutgoing(): Road {\n    return sample(this.outgoing);\n  }\n}\n","// @flow\nimport { assert } from '../../lib/assert';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { inBack, reverse, linear } from '../../lib/easings';\nimport { constrain, mapRange } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { RED } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 1000;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst PULSE_RADIUS = 25;\n\nconst CLOCK_FADE_DURATION = 150;\nconst PULSE_DURATION = 500;\n\nconst MAIN_COLOR = RED.lighten(0.2).desaturate(0.5);\nconst CLOCK_COLOR = RED.darken(0.2);\nconst PULSE_COLOR = RED.lighten(0.2).fade(0.4);\n\nexport default class Consumer extends SceneObject implements NetworkNode {\n  isDestination = true;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number = 0;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return this._timer >= this._cooldown;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return [this];\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  consumeTraveller() {\n    assert(this.canConsumeTraveller, 'must be ready to consumer traveller');\n    this._resetTimer();\n    this._pulse();\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius * progress,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        endRadius: RADIUS,\n        startRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: inBack(4),\n        easeOpacity: reverse(linear),\n        removeOnComplete: true,\n      }),\n    );\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport Scene from './Scene';\n\nconst DEFAULT_NAME = '$$AbstractSceneSystem$$';\n\nexport default abstract class SceneSystem {\n  static systemName = DEFAULT_NAME;\n  private scene: Scene | null = null;\n\n  constructor() {\n    assert(\n      this.constructor !== SceneSystem,\n      'SceneSystem is an abstract class that must be extended',\n    );\n    assert(\n      (this.constructor as any).systemName !== DEFAULT_NAME,\n      'classes extending SceneSystem must override SceneSystem.systemName',\n    );\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene is required');\n    return this.scene;\n  }\n\n  afterAddToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeRemoveFromScene(scene: Scene) {\n    this.scene = null;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  beforeDraw(ctx: CanvasRenderingContext2D, time: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterDraw(ctx: CanvasRenderingContext2D, time: number) {}\n}\n","// @flow\nimport Scene from '../lib/scene/Scene';\nimport SceneSystem from '../lib/scene/SceneSystem';\nimport QuadTree from '../lib/QuadTree';\nimport Circle from '../lib/geom/Circle';\nimport AABB from '../lib/geom/AABB';\nimport Traveller from './Traveller';\n\nexport default class TravellerFinder extends SceneSystem {\n  static systemName = 'TravellerFinder';\n\n  _quadTree!: QuadTree<Traveller>;\n\n  removeTraveller(traveller: Traveller) {\n    this._quadTree.remove(traveller);\n  }\n\n  afterAddToScene(scene: Scene) {\n    super.afterAddToScene(scene);\n    this._quadTree = new QuadTree(\n      AABB.fromLeftTopRightBottom(0, 0, scene.width, scene.height),\n      traveller => traveller.position,\n    );\n  }\n\n  beforeUpdate() {\n    const scene = this.getScene();\n    this._quadTree.clear();\n    scene.children.forEach(child => {\n      if (child instanceof Traveller) {\n        this._quadTree.insert(child);\n      }\n    });\n    // this._quadTree.debugDraw('red');\n  }\n\n  findTravellersInCircle(circle: Circle) {\n    return this._quadTree.findItemsInCircle(circle);\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Road from './Road';\nimport { NetworkNode } from './networkNodes/NetworkNode';\n\nconst PathFinder = {\n  getNextRoad(initialNode: NetworkNode, destinationNode: NetworkNode): Road {\n    const remainingNodes = new Set(initialNode.getAllReachableNodes());\n    remainingNodes.add(initialNode);\n    assert(\n      remainingNodes.has(destinationNode),\n      'destination must be reachable',\n    );\n    const bestCosts = new Map();\n    const prevRoads = new Map();\n\n    bestCosts.set(initialNode, 0);\n\n    while (remainingNodes.size) {\n      const { node, cost } = PathFinder._nodeWithShortestDistance(\n        remainingNodes,\n        bestCosts,\n      );\n      remainingNodes.delete(node);\n\n      if (node === destinationNode) {\n        return PathFinder._nextRoadFromRoute(\n          prevRoads,\n          initialNode,\n          destinationNode,\n        );\n      }\n\n      PathFinder._updateNeighbours(node, bestCosts, cost, prevRoads);\n    }\n\n    throw new Error('unreachable i hope');\n  },\n\n  _nodeWithShortestDistance(\n    nodes: Set<NetworkNode>,\n    costs: Map<NetworkNode, number>,\n  ): { node: NetworkNode; cost: number } {\n    let bestCost = Infinity;\n    let bestNode = null;\n\n    nodes.forEach(node => {\n      const cost = costs.get(node);\n      if (cost != null && cost <= bestCost) {\n        bestCost = cost;\n        bestNode = node;\n      }\n    });\n\n    assert(bestNode, 'node must be found');\n    return { node: bestNode, cost: bestCost };\n  },\n  _updateNeighbours(\n    node: NetworkNode,\n    bestCosts: Map<NetworkNode, number>,\n    cost: number,\n    prevRoads: Map<NetworkNode, Road>,\n  ) {\n    node.outgoingConnections.forEach(road => {\n      const nextNode = road.to;\n      const nextNodeCost = bestCosts.get(nextNode);\n      const altNextNodeCost = cost + road.expectedTimeFromStartToEnd;\n      if (nextNodeCost == null || altNextNodeCost <= nextNodeCost) {\n        bestCosts.set(nextNode, altNextNodeCost);\n        prevRoads.set(nextNode, road);\n      }\n    });\n  },\n  _nextRoadFromRoute(\n    prevRoads: Map<NetworkNode, Road>,\n    start: NetworkNode,\n    finish: NetworkNode,\n  ): Road {\n    let node = finish;\n    while (prevRoads.has(node)) {\n      const road = prevRoads.get(node);\n      assert(road, 'road must exist');\n      node = road.from;\n      if (node === start) return road;\n    }\n\n    throw new Error('prev road must be found');\n  },\n};\n\nexport default PathFinder;\n","// @flow\nimport { assert } from '../../lib/assert';\nimport Vector2 from '../../lib/geom/Vector2';\nimport { uniq, flatten } from '../../lib/utils';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport PathFinder from '../PathFinder';\nimport Road from '../Road';\nimport Traveller from '../Traveller';\nimport { NetworkNode } from './NetworkNode';\n\nexport default class Intersection implements NetworkNode {\n  isDestination = false;\n  position: Vector2;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number) {\n    this.position = new Vector2(x, y);\n  }\n\n  get incomingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.outgoing;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return true;\n  }\n\n  consumeTraveller(traveller: Traveller) {\n    const destination = traveller.destination;\n    assert(destination, 'traveller must have destination');\n\n    const nextRoad = PathFinder.getNextRoad(this, destination);\n    assert(\n      this.outgoingConnections.includes(nextRoad),\n      'nextRoad must be from this intersection',\n    );\n\n    traveller.removeFromCurrentRoad();\n    nextRoad.addTravellerAtStart(traveller);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(): Vector2 {\n    return this.position;\n  }\n\n  getClosestOutgoingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.outgoingConnections.forEach(road => {\n      const traveller = road.getTravellerAfterPosition(-1);\n      if (traveller && traveller.positionOnCurrentRoad < shortestDistance) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.positionOnCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getClosestIncomingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.incomingConnections.forEach(road => {\n      const traveller = road.getTravellerBeforePosition(road.length);\n      if (\n        traveller &&\n        traveller.distanceToEndOfCurrentRoad < shortestDistance\n      ) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.distanceToEndOfCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n}\n","import { assert } from '../lib/assert';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { outBack, inBack } from '../lib/easings';\nimport { sample, constrain, mapRange, random } from '../lib/utils';\nimport TravellerFinder from './TravellerFinder';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Intersection from './networkNodes/Intersection';\nimport Road from './Road';\nimport Entity from '../lib/scene/Entity';\nimport { makeAbsolutePal } from '../pals/makePal';\nimport { PalAbsoluteController } from '../pals/PalController';\n\n// const TRAVELLER_COLOR = BLUE.fade(0.4);\n// const TRAVELLER_RADIUS = 14;\nconst MIN_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MAX_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MIN_TRAVELLER_SAFE_RADIUS = 30;\nconst MAX_TRAVELLER_SAFE_RADIUS = 30;\nconst NEARBY_RADIUS = 200;\n\nconst INITIAL_SPEED = 5;\nconst MAX_SPEED = 80;\nconst ACCELERATION = 200;\nconst DECELERATION = -200;\nconst ROAD_END_OVERSHOOT = 0;\n\nconst PATIENCE = 1500;\nconst FORCE_ACCELERATE_DURATION = 100;\n\nconst ENTER_DURATION = 400;\nconst EXIT_DURATION = 400;\n\nconst enterEase = outBack(3);\nconst exitEase = inBack(3);\n\nenum StopReason {\n  STOPPED_FOR_DESTINATION = 'STOPPED_FOR_DESTINATION',\n  STOPPED_FOR_TRAFFIC_IN_FRONT = 'STOPPED_FOR_TRAFFIC_IN_FRONT',\n  STOPPED_FOR_TRAFFIC_NEARBY = 'STOPPED_FOR_TRAFFIC_NEARBY',\n}\n\nexport default class Traveller extends SceneObject {\n  static MAX_SPEED = MAX_SPEED;\n  static StopReason = StopReason;\n\n  comfortableRadius = random(\n    MIN_TRAVELLER_COMFORTABLE_RADIUS,\n    MAX_TRAVELLER_COMFORTABLE_RADIUS,\n  );\n  safeRadius = random(MIN_TRAVELLER_SAFE_RADIUS, MAX_TRAVELLER_SAFE_RADIUS);\n  _currentRoad: Road | null = null;\n  _destination: NetworkNode | null = null;\n  _positionOnCurrentRoad: number = 0;\n  _speed: number = INITIAL_SPEED;\n  _age: number = 0;\n  _exitStartedAt: number | null = null;\n  _stoppedTime: number = 0;\n  _forceAccelerateTimer: number = 0;\n  _stopReason: StopReason | null = null;\n  _stoppedFor: Traveller[] = [];\n  _pal: Entity | null = null;\n\n  get currentRoad(): Road | null {\n    return this._currentRoad;\n  }\n\n  get position(): Vector2 {\n    assert(this._currentRoad, 'currentRoad must be defined');\n    return this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad);\n  }\n\n  // get predictedPositionInDirectionOfTravel(): Vector2 {\n  //   assert(this._currentRoad, 'currentRoad must be defined');\n  //   return this._getPredictedPointForPosition(\n  //     this._currentRoad,\n  //     this._positionOnCurrentRoad + 1,\n  //   );\n  // }\n\n  get predictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition);\n  }\n\n  get predictedStopArea(): Circle {\n    const center = this.predictedStopPoint;\n    return new Circle(center.x, center.y, this.safeRadius);\n  }\n\n  get potentialNextPredictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition + 1);\n  }\n\n  get positionOnCurrentRoad(): number {\n    return this._positionOnCurrentRoad;\n  }\n\n  get distanceToEndOfCurrentRoad(): number {\n    assert(this._currentRoad, 'traveller is not on a road');\n    return this._currentRoad.length - this._positionOnCurrentRoad;\n  }\n\n  get destination(): NetworkNode | null {\n    return this._destination;\n  }\n\n  get speed(): number {\n    return this._speed;\n  }\n\n  get isStopped(): boolean {\n    return this.speed === 0;\n  }\n\n  get stoppedTime(): number {\n    return this._stoppedTime;\n  }\n\n  get stopReason(): StopReason | null {\n    return this._stopReason;\n  }\n\n  isStoppedFor(other: Traveller): boolean {\n    return this._stoppedFor.includes(other);\n  }\n\n  onAddedToRoad(road: Road) {\n    this._currentRoad = road;\n    this._positionOnCurrentRoad = 0;\n    if (!this._destination) {\n      this._pickDestination();\n    }\n  }\n\n  onRemovedFromRoad() {\n    this.getScene()\n      .getSystem(TravellerFinder)\n      .removeTraveller(this);\n    this._currentRoad = null;\n  }\n\n  onRemovedFromScene() {\n    this.removeFromCurrentRoad();\n  }\n\n  removeFromCurrentRoad() {\n    if (this._currentRoad) this._currentRoad.removeTraveller(this);\n  }\n\n  update(dtMilliseconds: number) {\n    this._age += dtMilliseconds;\n    this._stopReason = null;\n    this._stoppedFor = [];\n\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._move(dtMilliseconds, currentRoad);\n\n    const pal = this._getPal();\n    pal\n      .getComponent(PalAbsoluteController)\n      .setPosition(\n        this.position,\n        currentRoad.getAngleAtPosition(this._positionOnCurrentRoad),\n        dtMilliseconds / 1000,\n      );\n    pal.update(dtMilliseconds);\n\n    this._getEnterTransitionScale();\n    // if (window.debugDraw) this._debugDraw();\n\n    this._checkAtEndOfRoad(currentRoad);\n    this._checkExit();\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number) {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._getPal().draw(ctx, elapsedTime);\n\n    // const position = this.position;\n    // const scale =\n    //   this._getEnterTransitionScale() * this._getExitTransitionScale();\n\n    // ctx.beginPath();\n    // ctx.fillStyle = TRAVELLER_COLOR.toString();\n    // ShapeHelpers.circle(ctx, position.x, position.y, TRAVELLER_RADIUS * scale);\n    // ctx.fill();\n  }\n\n  getSortOrder(): number {\n    return this.position.y;\n  }\n\n  get _isExiting(): boolean {\n    return this._exitStartedAt !== null;\n  }\n\n  _getPal(): Entity {\n    if (!this._pal) {\n      this._pal = makeAbsolutePal(this.position);\n    }\n\n    return this._pal;\n  }\n\n  // _debugDraw() {\n  //   const currentRoad = this._currentRoad;\n  //   if (!currentRoad) return;\n\n  //   const predictedStopPoint = this.predictedStopPoint;\n  //   new Circle(\n  //     this.position.x,\n  //     this.position.y,\n  //     this.comfortableRadius\n  //   ).debugDraw(\"rgba(0, 255, 0, 0.4)\");\n  //   new Circle(this.position.x, this.position.y, this.safeRadius).debugDraw(\n  //     this._forceAccelerateTimer ? \"cyan\" : \"red\"\n  //   );\n  //   predictedStopPoint.debugDraw(\"lime\");\n  //   this.predictedStopArea.debugDraw(\"rgba(255, 0, 255, 0.5)\");\n\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.fillText(\n  //     `${this.id} ${Math.round(this._stoppedTime)}`,\n  //     this.position.x,\n  //     this.position.y\n  //   );\n  // }\n\n  _getEnterTransitionScale() {\n    return enterEase(\n      constrain(0, 1, mapRange(0, ENTER_DURATION, 0, 1, this._age)),\n    );\n  }\n\n  _getExitTransitionScale() {\n    if (this._exitStartedAt === null) return 1;\n    return (\n      1 -\n      exitEase(\n        constrain(\n          0,\n          1,\n          mapRange(\n            this._exitStartedAt,\n            this._exitStartedAt + EXIT_DURATION,\n            0,\n            1,\n            this._age,\n          ),\n        ),\n      )\n    );\n  }\n\n  _getPredictedStopPositionIfDecelerating(): number {\n    const timeToStop = -this._speed / DECELERATION;\n    return (\n      this._positionOnCurrentRoad +\n      this._speed * timeToStop +\n      0.5 * DECELERATION * timeToStop * timeToStop\n    );\n  }\n\n  _getPredictedPointForPosition(currentRoad: Road, position: number): Vector2 {\n    if (position <= currentRoad.length) {\n      return currentRoad.getPointAtPosition(position);\n    }\n\n    const overshoot = position - currentRoad.length;\n    const overshootAngle = currentRoad.getAngleAtPosition(currentRoad.length);\n    return Vector2.fromPolar(overshootAngle, overshoot).add(currentRoad.end);\n  }\n\n  _pickDestination() {\n    if (!this._currentRoad) return;\n    const potentialDestinations = this._currentRoad\n      .getAllReachableNodes()\n      .filter(node => node.isDestination);\n    const destination = sample(potentialDestinations);\n    this._destination = destination;\n  }\n\n  _move(dtMilliseconds: number, currentRoad: Road) {\n    const dtSeconds = dtMilliseconds / 1000;\n\n    this._forceAccelerateTimer = constrain(\n      0,\n      FORCE_ACCELERATE_DURATION,\n      this._forceAccelerateTimer - dtMilliseconds,\n    );\n\n    if (\n      this._forceAccelerateTimer <= 0 &&\n      this._shouldDecelerate(currentRoad)\n    ) {\n      this._accelerate(DECELERATION, dtSeconds, currentRoad);\n    } else {\n      this._accelerate(ACCELERATION, dtSeconds, currentRoad);\n    }\n\n    if (this._speed === 0) {\n      this._stoppedTime += dtMilliseconds;\n    } else {\n      this._stoppedTime = 0;\n    }\n  }\n\n  _shouldDecelerate(currentRoad: Road): boolean {\n    const predictedStopPosition = this._getPredictedStopPositionIfDecelerating();\n    if (\n      currentRoad.to === this._destination &&\n      currentRoad.length + ROAD_END_OVERSHOOT < predictedStopPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_DESTINATION;\n      return true;\n    }\n\n    const nextTravellerOnRoad = currentRoad.getTravellerAfterPosition(\n      this._positionOnCurrentRoad,\n    );\n\n    const safeStopAheadPosition =\n      predictedStopPosition + this.comfortableRadius;\n\n    if (\n      nextTravellerOnRoad &&\n      nextTravellerOnRoad.positionOnCurrentRoad < safeStopAheadPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n      this._stoppedFor.push(nextTravellerOnRoad);\n      return true;\n    }\n\n    if (currentRoad.to instanceof Intersection) {\n      const intersection = currentRoad.to;\n      const outgoingTraveller = intersection.getClosestOutgoingTraveller();\n      if (outgoingTraveller) {\n        const outgoingTravellerPosition =\n          currentRoad.length + outgoingTraveller.positionOnCurrentRoad;\n\n        if (outgoingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(outgoingTraveller);\n          return true;\n        }\n      }\n\n      const incomingTraveller = intersection.getClosestIncomingTraveller();\n      if (incomingTraveller && incomingTraveller !== this) {\n        const incomingTravellerPosition =\n          currentRoad.length - incomingTraveller.distanceToEndOfCurrentRoad;\n        if (incomingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(incomingTraveller);\n          return true;\n        }\n      }\n    }\n\n    if (this._shouldDecelerateForNearbyTravellers(currentRoad)) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_NEARBY;\n      return true;\n    }\n\n    // const currentPoint = this.position;\n    // const currentSafeCircle = new Circle(\n    //   currentPoint.x,\n    //   currentPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     currentSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    // const predictedStopPoint = this._getPredictedStopPointIfDecelerating(\n    //   currentRoad,\n    // );\n    // const predictedSafeCircle = new Circle(\n    //   predictedStopPoint.x,\n    //   predictedStopPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     predictedSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    return false;\n  }\n\n  _shouldDecelerateForNearbyTravellers(currentRoad: Road): boolean {\n    const travellerFinder = this.getScene().getSystem(TravellerFinder);\n    const stopArea = this.predictedStopArea;\n    const stopPoint = stopArea.center;\n    const nextStopPoint = this.potentialNextPredictedStopPoint;\n    const searchArea = stopArea.withRadius(NEARBY_RADIUS);\n    const nearbyTravellers = travellerFinder.findTravellersInCircle(searchArea);\n\n    for (const other of nearbyTravellers) {\n      // cannot crash into self\n      if (other === this) continue;\n\n      // if we both started breaking now, we would be a safe distance so we're fine\n      const otherStopArea = other.predictedStopArea;\n      const otherStopPoint = otherStopArea.center;\n      if (!stopArea.intersectsCircle(otherStopArea)) continue;\n\n      // currently we think other will stop at the center of otherStopArea.\n      // otherNextStopPoint is one pixel further forward based other's current\n      // heading\n      const otherNextStopPoint = other.potentialNextPredictedStopPoint;\n\n      // if we're moving away from each other, everything is fine:\n      const currentStopDistance = stopPoint.distanceTo(otherStopArea.center);\n      const nextStopDistance = nextStopPoint.distanceTo(otherNextStopPoint);\n      if (nextStopDistance > currentStopDistance) continue;\n\n      // who is moving in a direction that's headed more towards the other's\n      // stop position? if they're moving towards me but i'm moving more\n      // orthagonally relative to them, they should slow down\n      const approachAmount = stopPoint.distanceTo(otherNextStopPoint);\n      const otherApproachAmount = otherStopPoint.distanceTo(nextStopPoint);\n      if (approachAmount < otherApproachAmount) {\n        continue;\n      }\n\n      // so we know we're moving towards them faster than they're moving\n      // towards us, but how much? If it's barely any and we're not already too\n      // close to them, we could just keep going\n      if (\n        approachAmount - otherApproachAmount <\n        0.15\n        // approachAmount > this.safeRadius * 0.8\n      ) {\n        continue;\n      }\n\n      // if there's a clash... just randomly tie-break\n      if (approachAmount === otherApproachAmount) {\n        return Math.random() < 0.5;\n      }\n\n      // if we've been waiting around for fuckin ever just slam that fuckin\n      // pedal to the floor like ugh (in reality just nudge forward a little)\n      // (unless the other one is stopped to cus otherwise we'll just crash)\n      if (this._stoppedTime > PATIENCE && !other.isStopped) {\n        this._forceAcceleration();\n        return false;\n      }\n\n      // attempt to break deadlocks. i guess this is the equivalent of 'other'\n      // waving at the current traveller to continue\n      if (other.isStoppedFor(this)) continue;\n\n      this._stoppedFor.push(other);\n    }\n\n    if (this._stoppedFor.length) return true;\n\n    return false;\n  }\n\n  // _shouldDecelerateForTravellersInCircle(currentRoad: Road, circle: Circle) {\n  //   const travellerFinder = this.getScene().getSystem(TravellerFinder);\n  //   const overlappingTravellers = travellerFinder.findTravellersInCircle(\n  //     circle,\n  //   );\n\n  //   const currentPosition = this.position;\n  //   const nextPosition = this.predictedPositionInDirectionOfTravel;\n\n  //   const clashingTravellers = overlappingTravellers.filter(other => {\n  //     if (other === this) return false;\n  //     if (other.currentRoad === currentRoad) return false;\n\n  // const currentDistance = currentPosition.distanceTo(other.position);\n  // const nextDistance = nextPosition.distanceTo(other.position);\n\n  // const isGettingCloser = nextDistance < currentDistance;\n  // if (!isGettingCloser) return false;\n\n  // const otherNextPosition = other.predictedPositionInDirectionOfTravel;\n  // const otherNextDistance = currentPosition.distanceTo(otherNextPosition);\n  // const thisMoveDelta = nextDistance - currentDistance;\n  // const otherMoveDelta = otherNextDistance - currentDistance;\n  // if (thisMoveDelta < otherMoveDelta) return true;\n\n  // if (this.isStopped && !other.isStopped) return true;\n\n  // if (this.isStopped && other.isStopped) {\n  //   if (this.stoppedTime === other.stoppedTime && this.id < other.id)\n  //     return false;\n  //   if (this.stoppedTime < other.stoppedTime) return false;\n  // }\n\n  //     return true;\n  //   });\n\n  //   return clashingTravellers.length > 0;\n  // }\n\n  _forceAcceleration() {\n    this._forceAccelerateTimer = FORCE_ACCELERATE_DURATION;\n  }\n\n  _accelerate(acceleration: number, dtSeconds: number, currentRoad: Road) {\n    const lastSpeed = this._speed;\n    this._speed = constrain(\n      0,\n      MAX_SPEED,\n      this._speed + acceleration * dtSeconds,\n    );\n    const avgSpeed = (lastSpeed + this._speed) / 2;\n    this._positionOnCurrentRoad = constrain(\n      0,\n      currentRoad.length,\n      this._positionOnCurrentRoad + avgSpeed * dtSeconds,\n    );\n  }\n\n  _checkAtEndOfRoad(currentRoad: Road) {\n    if (this._positionOnCurrentRoad === currentRoad.length) {\n      if (this._isExiting) return;\n      this._onReachEndOfCurrentRoad(currentRoad);\n    }\n  }\n\n  _checkExit() {\n    if (this._isExiting) {\n      assert(this._exitStartedAt);\n      if (this._age >= this._exitStartedAt + EXIT_DURATION) {\n        this._onExit();\n      }\n    }\n  }\n\n  _onReachEndOfCurrentRoad(currentRoad: Road) {\n    const nextNode = currentRoad.to;\n    const destination = this._destination;\n    if (nextNode.canConsumeTraveller) {\n      nextNode.consumeTraveller(this);\n      if (nextNode === destination) {\n        this._onReachDestination();\n      }\n    }\n  }\n\n  _onReachDestination() {\n    this._exit();\n  }\n\n  _onExit() {\n    this.getScene().removeChild(this);\n  }\n\n  _exit() {\n    this._exitStartedAt = this._age;\n  }\n}\n","import Entity from '../lib/scene/Entity';\nimport { PalTargetController, PalAbsoluteController } from './PalController';\nimport Vector2 from '../lib/geom/Vector2';\nimport { generateRandomPalConfig } from './PalConfig';\nimport PalGeom from './PalGeom';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport PalRenderer from './PalRenderer';\n\nexport function makeTargetPal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalTargetController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n\nexport function makeAbsolutePal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalAbsoluteController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n","// @flow\nimport { assert } from '../assert';\nimport { constrain, compact } from '../utils';\nimport Circle from './Circle';\nimport Vector2 from './Vector2';\nimport StraightPathSegment from './StraightPathSegment';\nimport CirclePathSegment from './CirclePathSegment';\nimport Line2 from './Line2';\n\nexport interface PathSegment {\n  getStart(): Vector2;\n  getEnd(): Vector2;\n  getLength(): number;\n  getPointAtPosition(position: number): Vector2;\n  getAngleAtPosition(position: number): number;\n}\n\nexport default class Path implements PathSegment {\n  static straightThroughPoints(...points: ReadonlyArray<Vector2>): Path {\n    let [lastPoint, ...remainingPoints] = points;\n    const path = new Path();\n\n    for (const point of remainingPoints) {\n      path.addSegment(new StraightPathSegment(lastPoint, point));\n      lastPoint = point;\n    }\n\n    return path;\n  }\n\n  static segmentAcrossCircle(\n    containingCircle: Circle,\n    entryAngle: number,\n    exitAngle: number,\n  ): CirclePathSegment | StraightPathSegment {\n    entryAngle = entryAngle + Math.PI;\n    const entryPoint = containingCircle.pointOnCircumference(entryAngle);\n    const exitPoint = containingCircle.pointOnCircumference(exitAngle);\n\n    const entryLineNormal = new Line2(\n      containingCircle.center,\n      entryPoint,\n    ).perpendicularLineThroughPoint(entryPoint);\n    const exitLineNormal = new Line2(\n      containingCircle.center,\n      exitPoint,\n    ).perpendicularLineThroughPoint(exitPoint);\n\n    if (entryLineNormal.isParallelTo(exitLineNormal)) {\n      return new StraightPathSegment(entryPoint, exitPoint);\n    }\n\n    const roadCircleCenter = entryLineNormal.pointAtIntersectionWith(\n      exitLineNormal,\n    );\n    const roadCircleRadius = entryPoint.distanceTo(roadCircleCenter);\n\n    // containingCircle.center.debugDraw('lime');\n    // roadCircleCenter.debugDraw('blue');\n    // entryPoint.debugDraw('magenta');\n    // exitPoint.debugDraw('red');\n\n    return new CirclePathSegment(\n      roadCircleCenter,\n      roadCircleRadius,\n      entryPoint.sub(roadCircleCenter).angle,\n      exitPoint.sub(roadCircleCenter).angle,\n    );\n  }\n\n  segments: PathSegment[] = [];\n\n  constructor(...segments: PathSegment[]) {\n    this.addSegments(...segments);\n  }\n\n  getStart(): Vector2 {\n    return this.segments[0].getStart();\n  }\n\n  getEnd(): Vector2 {\n    return this.segments[this.segments.length - 1].getEnd();\n  }\n\n  getLength(): number {\n    return this.segments.reduce(\n      (length, segment) => length + segment.getLength(),\n      0,\n    );\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getPointAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  getAngleAtPosition(position: number): number {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getAngleAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  addSegment(segment: PathSegment): this {\n    const lastSegment = this.segments[this.segments.length - 1];\n    if (lastSegment) {\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        `segments must neatly join together - ${lastSegment\n          .getEnd()\n          .toString()} !== ${segment.getStart().toString()}`,\n      );\n    }\n    this.segments.push(segment);\n    return this;\n  }\n\n  addSegments(...segments: PathSegment[]): this {\n    segments.forEach(segment => this.addSegment(segment));\n    return this;\n  }\n\n  autoRound(radius: number): this {\n    const newSegments = this.segments.map((segment, i): PathSegment | null => {\n      const lastSegment = i === 0 ? null : this.segments[i - 1];\n      if (!lastSegment) {\n        if (segment instanceof StraightPathSegment) return null;\n        return segment;\n      }\n\n      if (!(segment instanceof StraightPathSegment)) return segment;\n      if (!(lastSegment instanceof StraightPathSegment)) return null;\n\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        'segments must join',\n      );\n\n      const entryAngle = lastSegment.angle;\n      const exitAngle = segment.angle;\n      const usableRadius = Math.min(\n        radius,\n        lastSegment.getLength() / 2,\n        segment.getLength() / 2,\n      );\n\n      const containingCircle = new Circle(\n        segment.getStart().x,\n        segment.getStart().y,\n        usableRadius,\n      );\n\n      return Path.segmentAcrossCircle(containingCircle, entryAngle, exitAngle);\n    });\n\n    const compacted = compact(newSegments);\n\n    const start = this.getStart();\n    const end = this.getEnd();\n    let lastPoint = start;\n    this.segments = [];\n\n    compacted.forEach(segment => {\n      if (segment.getStart().equals(lastPoint)) {\n        this.addSegment(segment);\n      } else {\n        this.addSegment(new StraightPathSegment(lastPoint, segment.getStart()));\n        this.addSegment(segment);\n      }\n\n      lastPoint = segment.getEnd();\n    });\n\n    if (!lastPoint.equals(end)) {\n      this.addSegment(new StraightPathSegment(lastPoint, end));\n    }\n\n    return this;\n  }\n}\n","// @flow\nimport { compact } from '../lib/utils';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Scene from '../lib/scene/Scene';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\nimport Path from '../lib/geom/Path';\nimport Road from './Road';\nimport Intersection from './networkNodes/Intersection';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class Junction extends SceneObject {\n  _circle: Circle;\n  _intersectionsByAngle: { [angleString: string]: Intersection } = {};\n  _incomingIntersections: Set<Intersection> = new Set();\n  _outgoingIntersections: Set<Intersection> = new Set();\n  _roads: Road[] = [];\n\n  constructor(x: number, y: number, radius: number) {\n    super();\n    this._circle = new Circle(x, y, radius);\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    this._roads.forEach(road => scene.addChild(road));\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._circle.pointOnCircumference(radians);\n  }\n\n  connectToRoadAtAngle(\n    road: Road,\n    angle: number,\n    direction: ConnectionDirection,\n  ): Intersection {\n    const intersection = this._intersectionAtAngle(angle);\n    intersection.connectTo(road, direction);\n\n    const isIncoming =\n      direction === ConnectionDirection.IN ||\n      this._incomingIntersections.has(intersection);\n\n    const isOutgoing =\n      direction === ConnectionDirection.OUT ||\n      this._outgoingIntersections.has(intersection);\n\n    if (isIncoming) this._incomingIntersections.add(intersection);\n    if (isOutgoing) this._outgoingIntersections.add(intersection);\n\n    this._intersections.forEach(other => {\n      if (other === intersection) return;\n\n      if (isIncoming && this._outgoingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(intersection.position).angle,\n            other.position.sub(this._circle.center).angle,\n          ),\n        );\n\n        this._addRoad(new Road(intersection, other, { path }));\n      }\n\n      if (isOutgoing && this._incomingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(other.position).angle,\n            intersection.position.sub(this._circle.center).angle,\n          ),\n        );\n        this._addRoad(new Road(other, intersection, { path }));\n      }\n    });\n\n    return intersection;\n  }\n\n  _intersectionAtAngle(angle: number): Intersection {\n    const angleStr = angle.toString();\n    if (this._intersectionsByAngle[angleStr]) {\n      return this._intersectionsByAngle[angleStr];\n    }\n\n    const intersection = this._createIntersectionAtAngle(angle);\n    this._intersectionsByAngle[angleStr] = intersection;\n    return intersection;\n  }\n\n  _createIntersectionAtAngle(angle: number): Intersection {\n    const position = this.getVisualConnectionPointAtAngle(angle);\n    return new Intersection(position.x, position.y);\n  }\n\n  get _intersections(): Intersection[] {\n    return compact(\n      Object.keys(this._intersectionsByAngle).map(\n        angle => this._intersectionsByAngle[angle],\n      ),\n    );\n  }\n\n  _addRoad(road: Road) {\n    this._roads.push(road);\n    if (this.hasScene()) {\n      this.getScene().addChild(road);\n    }\n  }\n}\n","// @flow\nimport SceneObject from '../lib/scene/SceneObject';\nimport Path from '../lib/geom/Path';\nimport StraightPathSegment from '../lib/geom/StraightPathSegment';\nimport Vector2 from '../lib/geom/Vector2';\nimport * as ShapeHelpers from '../lib/canvasShapeHelpers';\nimport { YELLOW } from './colors';\nimport ConnectionDirection from './ConnectionDirection';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Junction from './Junction';\nimport Traveller from './Traveller';\n\n// const ROAD_OUTER_COLOR = BLUE;\n// const ROAD_INNER_COLOR = LIGHT_BG;\nconst ROAD_DASH_COLOR = YELLOW.darken(0.2);\n// const ROAD_OUTER_WIDTH = 12;\n// const ROAD_INNER_WIDTH = 13;\nconst ROAD_DASH_WIDTH = 3;\nconst ROAD_IDEAL_DASH = [5, 10];\nconst ROAD_IDEAL_DASH_LENGTH = ROAD_IDEAL_DASH.reduce((a, b) => a + b, 0);\nconst ROAD_DASH_SPEED = 0.05;\n\nexport type RoadOptions = {\n  autoRound?: number;\n  points?: Array<Vector2>;\n  path?: Path;\n};\n\nexport default class Road extends SceneObject {\n  isNode = false;\n  from: NetworkNode;\n  to: NetworkNode;\n  _path: Path;\n  _currentTravellers: Traveller[] = [];\n\n  constructor(\n    from: NetworkNode | Junction,\n    to: NetworkNode | Junction,\n    { points, autoRound, path }: RoadOptions = {},\n  ) {\n    super();\n\n    const angleFrom = points\n      ? from.position.angleTo(points[0])\n      : from.position.angleTo(to.position);\n\n    const angleTo = points\n      ? to.position.angleTo(points[points.length - 1])\n      : to.position.angleTo(from.position);\n\n    if (path) {\n      this._path = path;\n    } else if (points) {\n      this._path = Path.straightThroughPoints(\n        from.getVisualConnectionPointAtAngle(angleFrom),\n        ...points,\n        to.getVisualConnectionPointAtAngle(angleTo),\n      );\n    } else {\n      this._path = new Path().addSegment(\n        new StraightPathSegment(\n          from.getVisualConnectionPointAtAngle(angleFrom),\n          to.getVisualConnectionPointAtAngle(angleTo),\n        ),\n      );\n    }\n\n    if (autoRound != null) {\n      this._path.autoRound(autoRound);\n    }\n\n    if (from instanceof Junction) {\n      this.from = from.connectToRoadAtAngle(\n        this,\n        angleFrom,\n        ConnectionDirection.OUT,\n      );\n    } else {\n      this.from = from;\n      from.connectTo(this, ConnectionDirection.OUT);\n    }\n\n    if (to instanceof Junction) {\n      this.to = to.connectToRoadAtAngle(this, angleTo, ConnectionDirection.IN);\n    } else {\n      this.to = to;\n      to.connectTo(this, ConnectionDirection.IN);\n    }\n  }\n\n  get length(): number {\n    return this._path.getLength();\n  }\n\n  get start(): Vector2 {\n    return this._path.getStart();\n  }\n\n  get end(): Vector2 {\n    return this._path.getEnd();\n  }\n\n  get expectedTimeFromStartToEnd(): number {\n    if (this._currentTravellers.length) {\n      const avgSpeed =\n        this._currentTravellers.reduce(\n          (sum, traveller) => sum + traveller.speed,\n          0,\n        ) / this._currentTravellers.length;\n      return this.length / avgSpeed;\n    }\n\n    return this.length / (Traveller.MAX_SPEED * 0.7);\n  }\n\n  canAddTravellerAtStart(): boolean {\n    const nextTraveller = this.getTravellerAfterPosition(0);\n    if (!nextTraveller) return true;\n    return (\n      nextTraveller.positionOnCurrentRoad > nextTraveller.comfortableRadius\n    );\n  }\n\n  addTravellerAtStart(traveller: Traveller) {\n    this._currentTravellers.push(traveller);\n    traveller.onAddedToRoad(this);\n  }\n\n  removeTraveller(traveller: Traveller): boolean {\n    const index = this._currentTravellers.indexOf(traveller);\n    if (index === -1) return false;\n    this.removeTravellerAtIndex(index);\n    return true;\n  }\n\n  removeTravellerAtIndex(index: number): Traveller {\n    const traveller = this._currentTravellers[index];\n    this._currentTravellers.splice(index, 1);\n    traveller.onRemovedFromRoad();\n    return traveller;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    const nodes = [] as Array<NetworkNode>;\n    if (visited.has(this.to)) return nodes;\n    return [...this.to.getAllReachableNodes(visited), this.to];\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    return this._path.getPointAtPosition(position);\n  }\n\n  getAngleAtPosition(position: number): number {\n    return this._path.getAngleAtPosition(position);\n  }\n\n  getTravellerAfterPosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = traveller.positionOnCurrentRoad - position;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getTravellerBeforePosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = position - traveller.positionOnCurrentRoad;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, time: number) {\n    ctx.beginPath();\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ShapeHelpers.path(ctx, this._path);\n\n    // ctx.strokeStyle = ROAD_OUTER_COLOR.toString();\n    // ctx.lineWidth = ROAD_OUTER_WIDTH;\n    // ctx.stroke();\n\n    // ctx.strokeStyle = ROAD_INNER_COLOR.toString();\n    // ctx.lineWidth = ROAD_INNER_WIDTH;\n    // ctx.stroke();\n\n    const dashScale = this._getLineDashScale();\n    const dashLength = ROAD_IDEAL_DASH_LENGTH * dashScale;\n    ctx.setLineDash(ROAD_IDEAL_DASH.map(length => length * dashScale));\n    ctx.strokeStyle = ROAD_DASH_COLOR.toString();\n    ctx.lineDashOffset = (-time * ROAD_DASH_SPEED * dashScale) % dashLength;\n    ctx.lineWidth = ROAD_DASH_WIDTH;\n    // ctx.strokeStyle = 'black';\n    // ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  _getLineDashScale(): number {\n    const wholeDashCount = Math.floor(this.length / ROAD_IDEAL_DASH_LENGTH);\n    const wholeDashLength = wholeDashCount * ROAD_IDEAL_DASH_LENGTH;\n\n    const roundDownLength = this.length - wholeDashLength;\n    const roundUpLength =\n      wholeDashLength + ROAD_IDEAL_DASH_LENGTH - this.length;\n\n    const dashScale =\n      roundDownLength < roundUpLength\n        ? this.length / wholeDashLength\n        : this.length / (wholeDashLength + ROAD_IDEAL_DASH_LENGTH);\n\n    return dashScale;\n  }\n}\n","// @flow\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { outSine } from '../../lib/easings';\nimport { mapRange, constrain, flatten, uniq } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { TEAL } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Traveller from '../Traveller';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 500;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst CLOCK_RADIUS = RADIUS * 0.7;\nconst PULSE_RADIUS = 35;\n\nconst PULSE_DURATION = 500;\nconst CLOCK_FADE_DURATION = 150;\n\nconst MAIN_COLOR = TEAL.lighten(0.1);\nconst CLOCK_COLOR = TEAL.darken(0.1);\nconst PULSE_COLOR = TEAL.lighten(0.2).fade(0.1);\n\nexport default class Producer extends SceneObject implements NetworkNode {\n  isDestination = false;\n  canConsumeTraveller = false;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n    this._timer = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()) {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  consumeTraveller() {\n    throw new Error('producer cannot consume traveller');\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n    if (this._timer >= this._cooldown) {\n      this._onTimerEnd();\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ctx.arc(\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n      -Math.PI / 2,\n      progress * 2 * Math.PI - Math.PI / 2,\n      false,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = MAIN_COLOR.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      CLOCK_RADIUS,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _onTimerEnd() {\n    const didEmitTraveller = this._attemptEmitTraveller();\n    if (didEmitTraveller) {\n      this._pulse();\n      this._resetTimer();\n    }\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        startRadius: RADIUS,\n        endRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: outSine,\n        removeOnComplete: true,\n      }),\n    );\n  }\n\n  _attemptEmitTraveller(): boolean {\n    const road = this._connectionSet.sampleOutgoing();\n    if (!(road instanceof Road)) return false;\n\n    if (road.canAddTravellerAtStart()) {\n      const traveller = new Traveller();\n      road.addTravellerAtStart(traveller);\n      this.getScene().addChild(traveller);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Scene from '../lib/scene/Scene';\nimport Consumer from './networkNodes/Consumer';\nimport Producer from './networkNodes/Producer';\nimport Road from './Road';\nimport Junction from './Junction';\n// import DebugOverlay from \"./systems/DebugOverlay\";\nimport TravellerFinder from './TravellerFinder';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst ROUND = 50;\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nconst root = document.getElementById('root');\nassert(root, '#root must be present');\nscene.appendTo(root);\n\n// scene.addSystem(new DebugOverlay());\nscene.addSystem(new TravellerFinder());\n\nscenario3();\n\nscene.start();\n\nfunction scenario1() {\n  const producer1 = new Producer(100, 100, 500);\n  // const producer2 = new Consumer(100, 300, 2500);\n  const consumer1 = new Consumer(400, 200, 1500);\n  const consumer2 = new Consumer(250, 200, 1500);\n  scene.addChild(producer1);\n  // scene.addChild(producer2);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n\n  const junction1 = new Junction(250, 100, ROUND);\n  scene.addChild(junction1);\n  scene.addChild(new Road(producer1, junction1));\n  scene.addChild(\n    new Road(junction1, consumer1, {\n      points: [new Vector2(400, 100)],\n      autoRound: ROUND,\n    }),\n  );\n  scene.addChild(new Road(junction1, consumer2));\n\n  // const path2 = new Path();\n  // path2.addSegments(\n  //   new StraightPathSegment(new Vector2(130, 300), new Vector2(380, 300)),\n  //   new CirclePathSegment(new Vector2(380, 280), 20, Math.PI * 0.5, 0),\n  //   new StraightPathSegment(new Vector2(400, 280), new Vector2(400, 230)),\n  // );\n  // const road2 = new Road(producer2, consumer1, path2);\n  // scene.addChild(road2);\n}\n\nfunction scenario2() {\n  const producer = new Producer(100, 300, 500);\n  const junction = new Junction(300, 300, ROUND);\n  const consumer1 = new Consumer(300, 100, 5000);\n  const consumer2 = new Consumer(500, 300, 5000);\n  const consumer3 = new Consumer(300, 500, 5000);\n\n  scene.addChild(new Road(producer, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  scene.addChild(producer);\n  scene.addChild(junction);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n}\n\nfunction scenario3() {\n  const northConsumer = new Consumer(300, 550, 1500);\n  const middleConsumer = new Consumer(100, 450, 1500);\n  const southConsumer = new Consumer(100, 250, 1500);\n  const eastProducer = new Producer(600, 150, 500);\n  const westProducer = new Producer(100, 100, 500);\n  // const westProducer = new Producer(250, 250, 100);\n\n  scene.addChild(northConsumer);\n  scene.addChild(middleConsumer);\n  scene.addChild(southConsumer);\n  scene.addChild(eastProducer);\n  scene.addChild(westProducer);\n\n  const mainJunction = new Junction(300, 150, ROUND);\n  const eastProducerSplit = new Junction(500, 370, ROUND);\n  const southConsumerJoin = new Junction(330, 400, ROUND);\n  scene.addChild(mainJunction);\n  scene.addChild(eastProducerSplit);\n  scene.addChild(southConsumerJoin);\n  scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(eastProducer, eastProducerSplit));\n  scene.addChild(new Road(eastProducerSplit, southConsumerJoin));\n  // scene.addChild(\n  //   new Road(eastProducerSplit, mainJunction, {\n  //     points: [[600, 280], [700, 50], [450, 180], [450, 100], [300, 20]],\n  //     // points: [[400, 100]],\n  //     autoRound: 50,\n  //   }),\n  // );\n  scene.addChild(\n    new Road(eastProducerSplit, mainJunction, {\n      points: [new Vector2(400, 300), new Vector2(500, 50)],\n      autoRound: ROUND,\n    }),\n  );\n\n  // scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(mainJunction, southConsumerJoin));\n  scene.addChild(new Road(southConsumerJoin, northConsumer));\n  scene.addChild(new Road(mainJunction, middleConsumer));\n  scene.addChild(new Road(mainJunction, southConsumer));\n}\n\nfunction scenario4() {\n  const producer1 = new Producer(100, 100, 1000);\n  const producer2 = new Producer(300, 200, 1000);\n  const producer3 = new Producer(100, 300, 1000);\n  // const producer4 = new Producer(400, 100, 1000);\n  const consumer1 = new Consumer(300, 100, 1000);\n  const consumer2 = new Consumer(100, 200, 1000);\n  const consumer3 = new Consumer(300, 300, 1000);\n  // const consumer4 = new Consumer(430, 300, 1000);\n  scene.addChild(producer1);\n  scene.addChild(producer2);\n  scene.addChild(producer3);\n  // scene.addChild(producer4);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n  // scene.addChild(consumer4);\n\n  const junction = new Junction(200, 200, 30);\n  scene.addChild(junction);\n\n  scene.addChild(new Road(producer1, junction));\n  scene.addChild(new Road(producer2, junction));\n  scene.addChild(new Road(producer3, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  // scene.addChild(\n  //   new Road(producer4, consumer4, {\n  //     points: [[400, 250], [415, 250], [415, 150], [430, 150]],\n  //     autoRound: 30,\n  //   }),\n  // );\n}\n\nfunction scenario6() {\n  const producer = new Producer(300, 50, 1500).addTo(scene);\n  const consumer = new Consumer(500, 50, 100).addTo(scene);\n  new Road(producer, consumer, {\n    points: [\n      new Vector2(350, 150),\n      new Vector2(150, 350),\n      new Vector2(400, 500),\n      new Vector2(650, 350),\n      new Vector2(450, 150),\n    ],\n    autoRound: 400,\n  }).addTo(scene);\n}\n"],"names":["$37d63ae0c3ce19a6$var$UnitBezier","x1","y1","x2","y2","cx","bx","cy","by","this","ax","ay","key","t","x","epsilon","i","NEWTON_METHOD_ITERATIONS","sampleCurveX","$8qLe2","approxEq","dx","sampleCurveDerivativeX","lo","hi","x21","param","DEFAULT_EPSILON","sampleCurveY","solveCurveX","ConnectionDirection","$37d63ae0c3ce19a6$export$45db2fc2f15997e7","n","$37d63ae0c3ce19a6$export$cef097a6f35c9b6a","Math","sin","PI","$37d63ae0c3ce19a6$export$e38aa6d936f277b2","s","$9ea787a7a9ba434c$export$2e2bcd8739ae039","SceneObject","y","startRadius","endRadius","duration","color","_easeRadius","easeRadius","_easeOpacity","easeOpacity","_removeOnComplete","removeOnComplete","call","_circle","$eJCSX","default","_startRadius","_endRadius","_duration","_color","_progress","deltaTime","deltaProgress","min","withRadius","lerp","getScene","removeChild","ctx","beginPath","opacity","fillStyle","fade","toString","$6IKqx","circle","center","radius","fill","$dXT6b","$d9323e005b938a8f$export$d0446fe88325854e","$parcel$interopDefault","$9AT65","$d9323e005b938a8f$export$aa201224bb439d47","$d9323e005b938a8f$export$aab610c505c06a8f","$ce41d102a41122d3$var$ConnectionDirection","$ce41d102a41122d3$export$2e2bcd8739ae039","$014487839abcbcbb$export$2e2bcd8739ae039","incoming","outgoing","target","direction","IN","addIncoming","OUT","addOutgoing","Error","concat","push","sample","$68300a675eb0d504$var$MAIN_COLOR","lighten","desaturate","$68300a675eb0d504$var$CLOCK_COLOR","darken","$68300a675eb0d504$var$PULSE_COLOR","$68300a675eb0d504$export$2e2bcd8739ae039","cooldown","isDestination","_timer","_connectionSet","_visualConnectionCircle","_cooldown","radians","pointOnCircumference","Set","add","node","$8OvEy","assert","canConsumeTraveller","_resetTimer","_pulse","delta","constrain","progress","colorMixAmount","mapRange","bgColor","mix","moveTo","easing","addChildBefore","$e9fa0217768ee50a$var$DEFAULT_NAME","$e9fa0217768ee50a$export$2e2bcd8739ae039","scene","constructor","systemName","time","$b82541a56e38f541$export$2e2bcd8739ae039","SceneSystem","apply","arguments","traveller","_quadTree","remove","prototype","$2cCmU","$71uov","fromLeftTopRightBottom","width","height","position","clear","children","forEach","child","$6bf17d2e2f71bf75$export$2e2bcd8739ae039","_this","insert","findItemsInCircle","$4fe36a3cb4d10b6c$var$PathFinder","getNextRoad","initialNode","destinationNode","remainingNodes","getAllReachableNodes","has","bestCosts","Map","prevRoads","set","size","ref","_nodeWithShortestDistance","cost","delete","_nextRoadFromRoute","_updateNeighbours","nodes","costs","bestCost","Infinity","bestNode","get","outgoingConnections","road","nextNode","to","nextNodeCost","altNextNodeCost","expectedTimeFromStartToEnd","start","finish","from","$4fe36a3cb4d10b6c$export$2e2bcd8739ae039","$146304cebc86f814$export$2e2bcd8739ae039","$39Hjj","destination","nextRoad","includes","removeFromCurrentRoad","addTravellerAtStart","visited","uniq","flatten","map","bestTraveller","shortestDistance","getTravellerAfterPosition","positionOnCurrentRoad","incomingConnections","getTravellerBeforePosition","length","distanceToEndOfCurrentRoad","StopReason","$6bf17d2e2f71bf75$var$DECELERATION","$6bf17d2e2f71bf75$var$enterEase","$6bf17d2e2f71bf75$var$exitEase","$6bf17d2e2f71bf75$var$StopReason","comfortableRadius","random","safeRadius","_currentRoad","_destination","_positionOnCurrentRoad","_speed","_age","_exitStartedAt","_stoppedTime","_forceAccelerateTimer","_stopReason","_stoppedFor","_pal","getPointAtPosition","currentRoad","stopPosition","_getPredictedStopPositionIfDecelerating","_getPredictedPointForPosition","predictedStopPoint","speed","other","_pickDestination","getSystem","removeTraveller","dtMilliseconds","_move","pal","_getPal","getComponent","$1js6q","PalAbsoluteController","setPosition","getAngleAtPosition","update","_getEnterTransitionScale","_checkAtEndOfRoad","_checkExit","elapsedTime","draw","$bADSp","addComponent","config","$cvm1i","generateRandomPalConfig","$7oj37","setAnimationController","$leuCG","$hdQD0","$da7c88ef361297ae$export$b7cfb0b946e2f4d5","timeToStop","overshoot","overshootAngle","fromPolar","end","potentialDestinations","filter","dtSeconds","_shouldDecelerate","_accelerate","predictedStopPosition","STOPPED_FOR_DESTINATION","nextTravellerOnRoad","safeStopAheadPosition","STOPPED_FOR_TRAFFIC_IN_FRONT","intersection","outgoingTraveller","getClosestOutgoingTraveller","incomingTraveller","getClosestIncomingTraveller","_shouldDecelerateForNearbyTravellers","STOPPED_FOR_TRAFFIC_NEARBY","travellerFinder","stopArea","predictedStopArea","stopPoint","nextStopPoint","potentialNextPredictedStopPoint","searchArea","nearbyTravellers","findTravellersInCircle","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","otherStopArea","otherStopPoint","intersectsCircle","otherNextStopPoint","currentStopDistance","distanceTo","approachAmount","otherApproachAmount","isStopped","_forceAcceleration","isStoppedFor","err","return","acceleration","lastSpeed","avgSpeed","_isExiting","_onReachEndOfCurrentRoad","_onExit","consumeTraveller","_onReachDestination","_exit","MAX_SPEED","$e1f78be531e9cb91$export$2e2bcd8739ae039","_len","segments","Array","_key","addSegments","$8TSCy","toConsumableArray","getStart","getEnd","reduce","segment","getLength","constrained","soFar","lastSegment","equals","addSegment","newSegments","$6SQqk","entryAngle","angle","exitAngle","usableRadius","containingCircle","segmentAcrossCircle","compacted","compact","lastPoint","_this1","points","_points","toArray","remainingPoints","slice","path","point","entryPoint","exitPoint","entryLineNormal","$eYUEV","perpendicularLineThroughPoint","exitLineNormal","isParallelTo","roadCircleCenter","pointAtIntersectionWith","roadCircleRadius","$7Tktm","sub","$9193cc27414d964c$export$2e2bcd8739ae039","_intersectionsByAngle","_incomingIntersections","_outgoingIntersections","_roads","addChild","_intersectionAtAngle","connectTo","isIncoming","isOutgoing","_intersections","_addRoad","$b656cfa00f913cfd$export$2e2bcd8739ae039","path1","angleStr","_createIntersectionAtAngle","getVisualConnectionPointAtAngle","Object","keys","hasScene","$b656cfa00f913cfd$var$ROAD_DASH_COLOR","$b656cfa00f913cfd$var$ROAD_IDEAL_DASH","$b656cfa00f913cfd$var$ROAD_IDEAL_DASH_LENGTH","a","b","_Path","autoRound","isNode","_currentTravellers","angleFrom","angleTo","_path","straightThroughPoints","connectToRoadAtAngle","assertThisInitialized","sum","nextTraveller","onAddedToRoad","index","indexOf","removeTravellerAtIndex","splice","onRemovedFromRoad","bestDistance","distance","lineCap","lineJoin","dashScale","_getLineDashScale","dashLength","setLineDash","strokeStyle","lineDashOffset","lineWidth","stroke","wholeDashLength","floor","$78c1eec4f05c28aa$var$MAIN_COLOR","$78c1eec4f05c28aa$var$CLOCK_COLOR","$78c1eec4f05c28aa$var$PULSE_COLOR","$78c1eec4f05c28aa$export$2e2bcd8739ae039","_onTimerEnd","arc","$78c1eec4f05c28aa$var$RADIUS","_attemptEmitTraveller","sampleOutgoing","canAddTravellerAtStart","$46b0dccb79779987$var$ROUND","$46b0dccb79779987$var$scene","$dLeLC","window","devicePixelRatio","$46b0dccb79779987$var$root","document","getElementById","appendTo","addSystem","northConsumer","middleConsumer","southConsumer","eastProducer","westProducer","mainJunction","eastProducerSplit","southConsumerJoin","$46b0dccb79779987$var$scenario3"],"version":3,"file":"index.0c3c1f76.js.map"}