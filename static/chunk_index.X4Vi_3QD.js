var fe=Object.defineProperty;var he=(e,t,r)=>t in e?fe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var a=(e,t,r)=>he(e,typeof t!="symbol"?t+"":t,r);import{R as T,r as k}from"./chunk_index.C5eOxiyT.js";import{c as m}from"./chunk__commonjsHelpers.Cpj98o6Y.js";const j="__TLDRAW_LIBRARY_VERSIONS__";function de(){if(globalThis[j])return globalThis[j];const e={versions:[],didWarn:!1,scheduledNotice:null};return Object.defineProperty(globalThis,j,{value:e,writable:!1,configurable:!1,enumerable:!1}),e}function I(e,t,r){if(!e||!t||!r)throw new Error("Missing name/version/module system in built version of tldraw library");const n=de();if(n.versions.push({name:e,version:t,modules:r}),!n.scheduledNotice)try{n.scheduledNotice=setTimeout(()=>{n.scheduledNotice=null,B(n)},100)}catch{B(n)}}function B(e){if(!e.versions.length||e.didWarn)return;const t=e.versions.sort((o,f)=>U(o.version,f.version)),r=t[t.length-1].version,n=new Set,s=new Map;for(const o of t){if(s.has(o.name)){n.delete(o.name),x(s,o.name,new Set).add(o.version);continue}o.version===r?n.add(o.name):(n.delete(o.name),x(s,o.name,new Set).add(o.version))}if(s.size>0){const o=[`${p("[tldraw]",["bold","bgRed","textWhite"])} ${p("You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.",["textRed","bold"])}`,"",`The latest version you have installed is ${p(`v${r}`,["bold","textBlue"])}. The following libraries are on the latest version:`,...Array.from(n,f=>`  • ✅ ${p(f,["bold"])}`),"","The following libraries are not on the latest version, or have multiple versions installed:",...Array.from(s,([f,d])=>{const _=Array.from(d).sort(U).map(g=>p(`v${g}`,g===r?["textGreen"]:["textRed"]));return`  • ❌ ${p(f,["bold"])} (${_.join(", ")})`})];console.log(o.join(`
`)),e.didWarn=!0;return}const i=new Map;for(const o of t)x(i,o.name,{version:o.version,modules:[]}).modules.push(o.modules);const u=new Map;for(const[o,f]of i)f.modules.length>1&&u.set(o,f);if(u.size>0){const o=[`${p("[tldraw]",["bold","bgRed","textWhite"])} ${p("You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ",["textRed","bold"])}`,"","This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.","","The following libraries have been imported multiple times:",...Array.from(u,([f,d])=>{const _=d.modules.map((g,E)=>g==="esm"?`      ${E+1}. ES Modules`:`      ${E+1}. CommonJS`).join(`
`);return`  • ❌ ${p(f,["bold"])} v${d.version}: 
${_}`}),"","You should configure your bundler to only import one version of each library."];console.log(o.join(`
`)),e.didWarn=!0;return}}function U(e,t){const r=e.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/),n=t.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);return!r||!n?e.localeCompare(t):r[1]!==n[1]?Number(r[1])-Number(n[1]):r[2]!==n[2]?Number(r[2])-Number(n[2]):r[3]!==n[3]?Number(r[3])-Number(n[3]):r[4]&&n[4]?r[4].localeCompare(n[4]):r[4]?1:n[4]?-1:0}const ge={bold:"1",textBlue:"94",textRed:"31",textGreen:"32",bgRed:"41",textWhite:"97"};function p(e,t=[]){return`\x1B[${t.map(r=>ge[r]).join(";")}m${e}\x1B[m`}function x(e,t,r){return e.has(t)?e.get(t):(e.set(t,r),r)}var pe=typeof m=="object"&&m&&m.Object===Object&&m,me=typeof self=="object"&&self&&self.Object===Object&&self;pe||me||Function("return this")();var ye=1/0,be="[object Function]",_e="[object GeneratorFunction]",Ee=/[\\^$.*+?()[\]{}|]/g,we=/^\[object .+?Constructor\]$/,ve=typeof m=="object"&&m&&m.Object===Object&&m,Se=typeof self=="object"&&self&&self.Object===Object&&self,L=ve||Se||Function("return this")();function Te(e,t){return e==null?void 0:e[t]}function Re(e){var t=!1;if(e!=null&&typeof e.toString!="function")try{t=!!(e+"")}catch{}return t}function Ae(e){var t=-1,r=Array(e.size);return e.forEach(function(n){r[++t]=n}),r}var Ce=Function.prototype,H=Object.prototype,P=L["__core-js_shared__"],F=function(){var e=/[^.]+$/.exec(P&&P.keys&&P.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),K=Ce.toString,Oe=H.hasOwnProperty,ke=H.toString,je=RegExp("^"+K.call(Oe).replace(Ee,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");V(L,"Map");var D=V(L,"Set");V(Object,"create");function xe(e){if(!J(e)||Pe(e))return!1;var t=$e(e)||Re(e)?je:we;return t.test(De(e))}D&&1/Ae(new D([,-0]))[1]==ye;function V(e,t){var r=Te(e,t);return xe(r)?r:void 0}function Pe(e){return!!F&&F in e}function De(e){if(e!=null){try{return K.call(e)}catch{}try{return e+""}catch{}}return""}function $e(e){var t=J(e)?ke.call(e):"";return t==be||t==_e}function J(e){var t=typeof e;return!!e&&(t=="object"||t=="function")}function Ie(){}function Le(e){const t=(...r)=>{try{return e(...r)}catch(n){throw n instanceof Error&&Error.captureStackTrace&&Error.captureStackTrace(n,t),n}};return t}const pt={ok(e){return{ok:!0,value:e}},err(e){return{ok:!1,error:e}}};function mt(e,t){const r=e;throw new Error(`Unknown switch case ${r}`)}const Ve=Le((e,t)=>{if(!e)throw new Error(t||"Assertion Error")}),ze=Object.freeze(["image/svg+xml"]),Me=Object.freeze(["image/jpeg","image/png","image/webp"]),Ne=Object.freeze(["image/gif","image/apng","image/avif"]),Be=Object.freeze([...Me,...ze,...Ne]),Ue=Object.freeze(["video/mp4","video/webm","video/quicktime"]),Fe=Object.freeze([...Be,...Ue]);Fe.join(",");function We(){return typeof globalThis<"u"&&globalThis.structuredClone?[globalThis.structuredClone,!0]:typeof global<"u"&&global.structuredClone?[global.structuredClone,!0]:typeof window<"u"&&window.structuredClone?[window.structuredClone,!0]:[e=>e&&JSON.parse(JSON.stringify(e)),!1]}const Z=We(),Ye=Z[0];Z[1];Object.getPrototypeOf(Ye({}));I("@tldraw/utils","3.13.3","esm");function Q(e){return e&&typeof e=="object"&&"parents"in e}function X(e){for(let t=0,r=e.parents.length;t<r;t++)if(e.parents[t].__unsafe__getWithoutCapture(!0),e.parents[t].lastChangedEpoch!==e.parentEpochs[t])return!0;return!1}function R(e,t){if(e.children.remove(t)&&e.children.isEmpty&&Q(e))for(let r=0,n=e.parents.length;r<n;r++)R(e.parents[r],e)}function z(e,t){if(e.children.add(t)&&Q(e))for(let r=0,n=e.parents.length;r<n;r++)z(e.parents[r],e)}function ee(e,t){return e===t||Object.is(e,t)||!!(e&&t&&typeof e.equals=="function"&&e.equals(t))}function b(e,t){const r=Symbol.for(`com.tldraw.state/${e}`),n=globalThis;return n[r]??(n[r]=t()),n[r]}const te=b("empty_array",()=>Object.freeze([])),W=8;class A{constructor(){a(this,"arraySize",0);a(this,"array",Array(W));a(this,"set",null)}get isEmpty(){if(this.array)return this.arraySize===0;if(this.set)return this.set.size===0;throw new Error("no set or array")}add(t){if(this.array)return this.array.indexOf(t)!==-1?!1:this.arraySize<W?(this.array[this.arraySize]=t,this.arraySize++,!0):(this.set=new Set(this.array),this.array=null,this.set.add(t),!0);if(this.set)return this.set.has(t)?!1:(this.set.add(t),!0);throw new Error("no set or array")}remove(t){if(this.array){const r=this.array.indexOf(t);return r===-1?!1:(this.array[r]=void 0,this.arraySize--,r!==this.arraySize&&(this.array[r]=this.array[this.arraySize],this.array[this.arraySize]=void 0),!0)}if(this.set)return this.set.has(t)?(this.set.delete(t),!0):!1;throw new Error("no set or array")}visit(t){if(this.array){for(let r=0;r<this.arraySize;r++){const n=this.array[r];typeof n<"u"&&t(n)}return}if(this.set){this.set.forEach(t);return}throw new Error("no set or array")}*[Symbol.iterator](){if(this.array)for(let t=0;t<this.arraySize;t++){const r=this.array[t];typeof r<"u"&&(yield r)}else if(this.set)yield*this.set;else throw new Error("no set or array")}has(t){return this.array?this.array.indexOf(t)!==-1:this.set.has(t)}clear(){this.set?this.set.clear():(this.arraySize=0,this.array=[])}size(){return this.set?this.set.size:this.arraySize}}const w=Symbol.for("com.tldraw.state/RESET_VALUE");class re{constructor(t){a(this,"index",0);a(this,"buffer");this.capacity=t,this.buffer=new Array(t)}pushEntry(t,r,n){if(n!==void 0){if(n===w){this.clear();return}this.buffer[this.index]=[t,r,n],this.index=(this.index+1)%this.capacity}}clear(){this.index=0,this.buffer.fill(void 0)}getChangesSince(t){const{index:r,capacity:n,buffer:s}=this;for(let i=0;i<n;i++){const u=(r-1+n-i)%n,o=s[u];if(!o)return w;const[f,d]=o;if(i===0&&t>=d)return[];if(f<=t&&t<d){const _=i+1,g=new Array(_);for(let E=0;E<_;E++)g[E]=s[(u+E)%n][2];return g}}return w}}const y=-1;class Ge{constructor(t,r,n){a(this,"_isActivelyListening",!1);a(this,"lastTraversedEpoch",y);a(this,"lastReactedEpoch",y);a(this,"_scheduleCount",0);a(this,"__debug_ancestor_epochs__",null);a(this,"parentSet",new A);a(this,"parentEpochs",[]);a(this,"parents",[]);a(this,"_scheduleEffect");a(this,"maybeExecute",()=>{this._isActivelyListening&&this.execute()});this.name=t,this.runEffect=r,this._scheduleEffect=n==null?void 0:n.scheduleEffect}get isActivelyListening(){return this._isActivelyListening}get scheduleCount(){return this._scheduleCount}maybeScheduleEffect(){if(this._isActivelyListening&&this.lastReactedEpoch!==h()){if(this.parents.length&&!X(this)){this.lastReactedEpoch=h();return}this.scheduleEffect()}}scheduleEffect(){this._scheduleCount++,this._scheduleEffect?this._scheduleEffect(this.maybeExecute):this.execute()}attach(){this._isActivelyListening=!0;for(let t=0,r=this.parents.length;t<r;t++)z(this.parents[t],this)}detach(){this._isActivelyListening=!1;for(let t=0,r=this.parents.length;t<r;t++)R(this.parents[t],this)}execute(){try{ae(this);const t=h(),r=this.runEffect(this.lastReactedEpoch);return this.lastReactedEpoch=t,r}finally{oe()}}}const O=b("EffectScheduler",()=>Ge);function yt(e,t,r){const n=new O(e,t,r);return n.attach(),n.scheduleEffect(),()=>{n.detach()}}function bt(e,t,r){const n=new O(e,t,r);return{scheduler:n,start:s=>{const i=(s==null?void 0:s.force)??!1;n.attach(),i?n.scheduleEffect():n.maybeScheduleEffect()},stop:()=>{n.detach()}}}class qe{constructor(t){a(this,"initialAtomValues",new Map);this.parent=t}get isRoot(){return this.parent===null}commit(){if(c.globalIsReacting)for(const t of this.initialAtomValues.keys())se(t);else this.isRoot?ne(this.initialAtomValues.keys()):this.initialAtomValues.forEach((t,r)=>{this.parent.initialAtomValues.has(r)||this.parent.initialAtomValues.set(r,t)})}abort(){c.globalEpoch++,this.initialAtomValues.forEach((t,r)=>{var n;r.set(t),(n=r.historyBuffer)==null||n.clear()}),this.commit()}}const c=b("transactions",()=>({globalEpoch:y+1,globalIsReacting:!1,currentTransaction:null,cleanupReactors:null,reactionEpoch:y+1}));function He(){return c.reactionEpoch}function h(){return c.globalEpoch}function Ke(){return c.globalIsReacting}function M(e,t){t.lastTraversedEpoch!==c.globalEpoch&&(t.lastTraversedEpoch=c.globalEpoch,t instanceof O?e.add(t):t.children.visit(r=>M(e,r)))}function ne(e){var r;if(c.globalIsReacting)throw new Error("flushChanges cannot be called during a reaction");const t=c.currentTransaction;try{c.currentTransaction=null,c.globalIsReacting=!0,c.reactionEpoch=c.globalEpoch;const n=new Set;for(const i of e)i.children.visit(u=>M(n,u));for(const i of n)i.maybeScheduleEffect();let s=0;for(;(r=c.cleanupReactors)!=null&&r.size;){if(s++>1e3)throw new Error("Reaction update depth limit exceeded");const i=c.cleanupReactors;c.cleanupReactors=null;for(const u of i)u.maybeScheduleEffect()}}finally{c.cleanupReactors=null,c.globalIsReacting=!1,c.currentTransaction=t}}function Je(e,t){c.currentTransaction?c.currentTransaction.initialAtomValues.has(e)||c.currentTransaction.initialAtomValues.set(e,t):c.globalIsReacting?se(e):ne([e])}function se(e){const t=c.cleanupReactors??(c.cleanupReactors=new Set);e.children.visit(r=>M(t,r))}function Ze(){c.globalEpoch++}function Qe(e){const t=new qe(c.currentTransaction);c.currentTransaction=t;try{let r,n=!1;try{r=e(()=>n=!0)}catch(s){throw t.abort(),s}return n?t.abort():t.commit(),r}finally{c.currentTransaction=c.currentTransaction.parent}}function _t(e){return c.currentTransaction?e():Qe(e)}let Y=!1;function Xe(){Y||(Y=!0,console.warn(`Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`))}const v=Symbol.for("com.tldraw.state/UNINITIALIZED");function Et(e){return e===v}const $=b("WithDiff",()=>class{constructor(t,r){this.value=t,this.diff=r}});function vt(e,t){return new $(e,t)}class et{constructor(t,r,n){a(this,"lastChangedEpoch",y);a(this,"lastTraversedEpoch",y);a(this,"__debug_ancestor_epochs__",null);a(this,"lastCheckedEpoch",y);a(this,"parentSet",new A);a(this,"parents",[]);a(this,"parentEpochs",[]);a(this,"children",new A);a(this,"historyBuffer");a(this,"state",v);a(this,"error",null);a(this,"computeDiff");a(this,"isEqual");this.name=t,this.derive=r,n!=null&&n.historyLength&&(this.historyBuffer=new re(n.historyLength)),this.computeDiff=n==null?void 0:n.computeDiff,this.isEqual=(n==null?void 0:n.isEqual)??ee}get isActivelyListening(){return!this.children.isEmpty}__unsafe__getWithoutCapture(t){var s;const r=this.lastChangedEpoch===y,n=h();if(!r&&(this.lastCheckedEpoch===n||this.isActivelyListening&&Ke()&&this.lastTraversedEpoch<He()||!X(this)))if(this.lastCheckedEpoch=n,this.error){if(t)return this.state;throw this.error.thrownValue}else return this.state;try{ae(this);const i=this.derive(this.state,this.lastCheckedEpoch),u=i instanceof $?i.value:i,o=this.state===v;if(o||!this.isEqual(u,this.state)){if(this.historyBuffer&&!o){const f=i instanceof $?i.diff:void 0;this.historyBuffer.pushEntry(this.lastChangedEpoch,h(),f??((s=this.computeDiff)==null?void 0:s.call(this,this.state,u,this.lastCheckedEpoch,h()))??w)}this.lastChangedEpoch=h(),this.state=u}return this.error=null,this.lastCheckedEpoch=h(),this.state}catch(i){if(this.state!==v&&(this.state=v,this.lastChangedEpoch=h()),this.lastCheckedEpoch=h(),this.historyBuffer&&this.historyBuffer.clear(),this.error={thrownValue:i},!t)throw i;return this.state}finally{oe()}}get(){try{return this.__unsafe__getWithoutCapture()}finally{C(this)}}getDiffSince(t){var r;return this.__unsafe__getWithoutCapture(!0),C(this),t>=this.lastChangedEpoch?te:((r=this.historyBuffer)==null?void 0:r.getChangesSince(t))??w}}const S=b("Computed",()=>et);function tt(e={},t,r,n){const s=n.value,i=Symbol.for("__@tldraw/state__computed__"+r);return n.value=function(){let u=this[i];return u||(u=new S(r,s.bind(this),e),Object.defineProperty(this,i,{enumerable:!1,configurable:!1,writable:!1,value:u})),u.get()},n.value[ie]=!0,n}function rt(e={},t,r,n){const s=n.get,i=Symbol.for("__@tldraw/state__computed__"+r);return n.get=function(){let u=this[i];return u||(u=new S(r,s.bind(this),e),Object.defineProperty(this,i,{enumerable:!1,configurable:!1,writable:!1,value:u})),u.get()},n}function nt(e,t,r){Ve(r.kind==="method","@computed can only be used on methods");const n=Symbol.for("__@tldraw/state__computed__"+String(r.name)),s=function(){let i=this[n];return i||(i=new S(String(r.name),t.bind(this),e),Object.defineProperty(this,n,{enumerable:!1,configurable:!1,writable:!1,value:i})),i.get()};return s[ie]=!0,s}function G(e={},t){if(t.length===2){const[r,n]=t;return nt(e,r,n)}else{const[r,n,s]=t;return s.get?(Xe(),rt(e,r,n,s)):tt(e,r,n,s)}}const ie="@@__isComputedMethod__@@";function St(){if(arguments.length===1){const e=arguments[0];return(...t)=>G(e,t)}else return typeof arguments[0]=="string"?new S(arguments[0],arguments[1],arguments[2]):G(void 0,arguments)}function N(e){return e&&e instanceof S}class st{constructor(t,r){a(this,"offset",0);a(this,"maybeRemoved");this.below=t,this.child=r}}const l=b("capture",()=>({stack:null}));function ae(e){if(l.stack=new st(l.stack,e),e.__debug_ancestor_epochs__){const t=e.__debug_ancestor_epochs__;e.__debug_ancestor_epochs__=null;for(const r of e.parents)r.__unsafe__getWithoutCapture(!0);it(e,t)}e.parentSet.clear()}function oe(){const e=l.stack;if(l.stack=e.below,e.offset<e.child.parents.length){for(let t=e.offset;t<e.child.parents.length;t++){const r=e.child.parents[t];e.child.parentSet.has(r)||R(r,e.child)}e.child.parents.length=e.offset,e.child.parentEpochs.length=e.offset}if(e.maybeRemoved)for(let t=0;t<e.maybeRemoved.length;t++){const r=e.maybeRemoved[t];e.child.parentSet.has(r)||R(r,e.child)}e.child.__debug_ancestor_epochs__&&ce(e.child,e.child.__debug_ancestor_epochs__)}function C(e){if(l.stack){if(l.stack.child.parentSet.has(e))return;if(l.stack.child.parentSet.add(e),l.stack.child.isActivelyListening&&z(e,l.stack.child),l.stack.offset<l.stack.child.parents.length){const r=l.stack.child.parents[l.stack.offset];r!==e&&(l.stack.maybeRemoved?l.stack.maybeRemoved.push(r):l.stack.maybeRemoved=[r])}l.stack.child.parents[l.stack.offset]=e,l.stack.child.parentEpochs[l.stack.offset]=e.lastChangedEpoch,l.stack.offset++}}function ce(e,t){for(let r=0;r<e.parents.length;r++){const n=e.parents[r],s=e.parentEpochs[r];t.set(n,s),N(n)&&ce(n,t)}return t}function ue(e,t){const r={};for(let n=0;n<e.parents.length;n++){const s=e.parents[n];if(!t.has(s))continue;const i=t.get(s);s.lastChangedEpoch!==i&&(N(s)?r[s.name]=ue(s,t):r[s.name]=null)}return r}function it(e,t){const r=ue(e,t);if(Object.keys(r).length===0){console.log(`Effect(${e.name}) was executed manually.`);return}let n=N(e)?`Computed(${e.name}) is recomputing because:`:`Effect(${e.name}) is executing because:`;function s(i,u){const o=`
`+" ".repeat(u)+"↳ ";for(const[f,d]of Object.entries(i))d?(n+=`${o}Computed(${f}) changed`,s(d,u+2)):n+=`${o}Atom(${f}) changed`}s(r,1),console.log(n)}class at{constructor(t,r,n){a(this,"isEqual");a(this,"computeDiff");a(this,"lastChangedEpoch",h());a(this,"children",new A);a(this,"historyBuffer");this.name=t,this.current=r,this.isEqual=(n==null?void 0:n.isEqual)??null,n&&(n.historyLength&&(this.historyBuffer=new re(n.historyLength)),this.computeDiff=n.computeDiff)}__unsafe__getWithoutCapture(t){return this.current}get(){return C(this),this.current}set(t,r){var s,i;if(((s=this.isEqual)==null?void 0:s.call(this,this.current,t))??ee(this.current,t))return this.current;Ze(),this.historyBuffer&&this.historyBuffer.pushEntry(this.lastChangedEpoch,h(),r??((i=this.computeDiff)==null?void 0:i.call(this,this.current,t,this.lastChangedEpoch,h()))??w),this.lastChangedEpoch=h();const n=this.current;return this.current=t,Je(this,n),t}update(t){return this.set(t(this.current))}getDiffSince(t){var r;return C(this),t>=this.lastChangedEpoch?te:((r=this.historyBuffer)==null?void 0:r.getChangesSince(t))??w}}const ot=b("Atom",()=>at);function Tt(e,t,r){return new ot(e,t,r)}const le=1,ct=b("apiVersion",()=>le);if(ct!==le)throw new Error("You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.");I("@tldraw/state","3.13.3","esm");function ut(e,t,r=[]){const n=T.useRef(t);n.current=t;const[s,i,u]=T.useMemo(()=>{let o=null;const f=g=>(o=g,()=>{o=null}),d=new O(`useStateTracking(${e})`,()=>{var g;return(g=n.current)==null?void 0:g.call(n)},{scheduleEffect(){o==null||o()}});return[d,f,()=>d.scheduleCount]},[e,...r]);return T.useSyncExternalStore(i,u,u),T.useEffect(()=>(s.attach(),s.maybeScheduleEffect(),()=>{s.detach()}),[s]),s.execute()}const q={apply(e,t,r){return ut(e.displayName??e.name??"tracked(???)",()=>e.apply(t,r))}},lt=Symbol.for("react.memo"),ft=Symbol.for("react.forward_ref");function Rt(e){let t=null;const r=e.$$typeof;return r===lt&&(e=e.type,t=e.compare),r===ft?k.memo(k.forwardRef(new Proxy(e.render,q))):k.memo(new Proxy(e,q),t)}I("@tldraw/state-react","3.13.3","esm");export{te as E,w as R,v as U,Tt as a,_t as b,St as c,Ve as d,bt as e,pt as f,mt as g,I as h,Et as i,yt as r,Ye as s,Rt as t,vt as w};
