import{a as u}from"./chunk_assert.pxkjFBOg.js";import{C as P}from"./chunk_Circle.DdRZmdDC.js";import{S as h,C as L}from"./chunk_StraightPathSegment.B29HarXU.js";import{L as d}from"./chunk_Line2.BnGSeyu4.js";import{S as w}from"./chunk_svgPathBuilder.tqI_yD_n.js";import{E as l,v as E}from"./chunk_utils.CSiPn6yw.js";class c{constructor(...e){this.segments=[],this.addSegments(...e)}static segmentToSvgPath(e){const t=new w;return e.appendToSvgPathBuilder(t),t.toString()}static straightThroughPoints(...e){let[t,...r]=e;const n=new c;for(const o of r)n.addSegment(new h(t,o)),t=o;return n}static segmentAcrossCircle(e,t,r){t=t+Math.PI;const n=e.pointOnCircumference(t),o=e.pointOnCircumference(r),i=new d(e.center,n).perpendicularLineThroughPoint(n),s=new d(e.center,o).perpendicularLineThroughPoint(o);if(i.isParallelTo(s))return new h(n,o);const a=i.pointAtIntersectionWith(s),g=n.distanceTo(a);return new L(a,g,n.sub(a).angle(),o.sub(a).angle())}getStart(){return this.segments[0].getStart()}getEnd(){return this.segments[this.segments.length-1].getEnd()}getLength(){return this.segments.reduce((e,t)=>e+t.getLength(),0)}appendToSvgPathBuilder(e){for(const t of this.segments)t.appendToSvgPathBuilder(e)}getPointAtPosition(e){const t=l(0,this.getLength(),e);let r=0;for(const n of this.segments){if(t<=r+n.getLength())return n.getPointAtPosition(t-r);r+=n.getLength()}throw new Error("this is supposed to be unreachable oops")}getAngleAtPosition(e){const t=l(0,this.getLength(),e);let r=0;for(const n of this.segments){if(t<=r+n.getLength())return n.getAngleAtPosition(t-r);r+=n.getLength()}throw new Error("this is supposed to be unreachable oops")}addSegment(e){const t=this.segments[this.segments.length-1];return t&&u(t.getEnd().equals(e.getStart()),`segments must neatly join together - ${t.getEnd().toString()} !== ${e.getStart().toString()}`),this.segments.push(e),this}addSegments(...e){return e.forEach(t=>this.addSegment(t)),this}autoRound(e){const t=this.segments.map((s,a)=>{const g=a===0?null:this.segments[a-1];if(!g)return s instanceof h?null:s;if(!(s instanceof h))return s;if(!(g instanceof h))return null;u(g.getEnd().equals(s.getStart()),"segments must join");const m=g.angle(),S=s.angle(),p=Math.min(e,g.getLength()/2,s.getLength()/2),f=P.create(s.getStart().x,s.getStart().y,p);return c.segmentAcrossCircle(f,m,S)}),r=E(t),n=this.getStart(),o=this.getEnd();let i=n;return this.segments=[],r.forEach(s=>{s.getStart().equals(i)?this.addSegment(s):(this.addSegment(new h(i,s.getStart())),this.addSegment(s)),i=s.getEnd()}),i.equals(o)||this.addSegment(new h(i,o)),this}}export{c as P};
