import{A as x,O as v,a as p,B as w,k as z,S as g,V as M,h as $,e as R,n as T,j as E,m as j,G as A}from"./chunk_utils.ferkvykK.js";const o={ok:u=>new U(u),error:u=>new P(u),collect:u=>{const r=[];for(const e of u)if(e.ok)r.push(e.value);else return e;return o.ok(r)},collectObject:u=>{const r={};for(const[e,t]of x(u))if(t.ok)r[e]=t.value;else return t;return o.ok(r)},fromFn:u=>{try{return o.ok(u())}catch(r){return o.error(r)}},fromPromise:u=>u.then(o.ok).catch(o.error),fromAsyncFn:async u=>{try{return o.ok(await u())}catch(r){return o.error(r)}}};class O{constructor(){}}class U extends O{constructor(r){super(),this.value=r,this.ok=!0}unwrap(){return this.value}unwrapError(r){v(`${r??"expected error"}: ${String(this.value)}`)}map(r){return o.ok(r(this.value))}mapErr(r){return this}andThen(r){return r(this.value)}}class P extends O{constructor(r){super(),this.error=r,this.ok=!1}unwrap(r){if(this.error instanceof Error)throw this.error;v(`${r??"expected value"}: ${String(this.error)}`)}unwrapError(r){return this.error}map(r){return this}mapErr(r){return o.error(r(this.error))}andThen(r){return this}}class l{constructor(r,e=[]){this.message=r,this.path=e}formatPath(){if(!this.path.length)return null;let r="";for(const e of this.path)typeof e=="number"?r+=`.${e}`:e.startsWith("(")?r.endsWith(")")?r=`${r.slice(0,-1)}, ${e.slice(1)}`:r+=e:r+=`.${e}`;return r}toString(){const r=this.formatPath(),e=this.message.split(`
`).map((t,n)=>n===0?t:`  ${t}`).join(`
`);return r?`At ${r}: ${e}`:e}}function y(u,...r){return new l(u.message,[...r,...u.path])}function f(u){if(u===null)return"null";if(Array.isArray(u))return"an array";const r=typeof u;switch(r){case"bigint":case"boolean":case"function":case"number":case"string":case"symbol":return`a ${r}`;case"object":return`an ${r}`;case"undefined":return"undefined";default:R(r)}}const h=class h{constructor(r,e,t){this.parse=r,this._validate=e,this.serialize=t}validate(r){const e=this._validate(r);return e.ok&&p(Object.is(e.value,r),"Assertion Error: Object.is(result.value, input)"),e}transform(r,e,t){return new h(n=>this.parse(n).andThen(r),n=>this.validate(n).andThen(e),n=>this.serialize(t(n)))}instance(r,e,t){return this.transform(e,n=>n instanceof r?o.ok(n):o.error(new l(`Expected instance of ${r.name}, got ${f(n)}`)),t)}nullable(){return new h(r=>r==null?o.ok(null):this.parse(r),r=>r===null?o.ok(null):this.validate(r),r=>r===null?null:this.serialize(r))}optional(){return new h(r=>r==null?o.ok(void 0):this.parse(r),r=>r===void 0?o.ok(void 0):this.validate(r),r=>{if(r!=null)return this.serialize(r)})}parseUnwrap(r){return this.parse(r).unwrap()}validateUnwrap(r){return this.validate(r).unwrap()}asValidator(){return{validate:r=>this.validateUnwrap(r)}}static typeof(r){const e=t=>typeof t===r?o.ok(t):o.error(new l(`Expected ${r}, got ${f(t)}`,[]));return new h(e,e,w)}static value(r){return new q(r)}static valueUnion(...r){const e=t=>r.includes(t)?o.ok(t):o.error(new l(`Expected one of ${r.join(" or ")}, got ${f(t)}`));return new h(e,e,w)}static arrayOf(r){return new h(e=>Array.isArray(e)?o.collect(e.map((t,n)=>r.parse(t).mapErr(s=>y(s,n)))):o.error(new l(`Expected an array, got ${f(e)}`,[])),e=>{if(!Array.isArray(e))return o.error(new l(`Expected an array, got ${f(e)}`,[]));for(let t=0;t<e.length;t++){const n=e[t],s=r.validate(n);if(!s.ok)return s.mapErr(i=>y(i,t))}return o.ok(e)},e=>e.map(t=>r.serialize(t)))}static object(r){return new B(r)}static objectMap(r,e){return new h(t=>typeof t!="object"||t===null?o.error(new l(`Expected object, got ${f(t)}`,[])):o.collect(z(t).map(n=>r.parse(n).andThen(s=>e.parse(g(t,s)).map(i=>[s,i])).mapErr(s=>y(s,n)))).map(n=>Object.fromEntries(n)),t=>{if(typeof t!="object"||t===null)return o.error(new l(`Expected object, got ${f(t)}`,[]));for(const[n,s]of x(t)){const i=r.validate(n);if(!i.ok)return i.mapErr(d=>y(d,n));const c=e.validate(s);if(!c.ok)return c.mapErr(d=>y(d,n))}return o.ok(t)},t=>{const n={};for(const[s,i]of x(t)){if(i===void 0)continue;const c=r.serialize(s);p(typeof c=="string"||typeof c=="number",'Assertion Error: typeof serializedKey === "string" || typeof serializedKey === "number"'),n[c]=e.serialize(i)}return n})}static enum(r){const e=new Set(Array.isArray(r)?r:M(r)),t=n=>{if(e.has(n))return o.ok(n);{const s=typeof n=="string"?`"${n}"`:typeof n=="boolean"||typeof n=="number"?String(n):f(n),i=Array.from(e,c=>typeof c=="string"?`"${c}"`:String(c)).join(" or ");return o.error(new l(`Expected ${i}, got ${s}`))}};return new h(t,t,w)}static union(r,e){return new J(r,e)}static indexedUnion(r,e){return new N(r,e)}static cannotValidate(r){return e=>{v(`Cannot validate ${r}, only parse/serialize available.`)}}};h.unknown=new h(r=>o.ok(r),r=>o.ok(r),w),h.never=new h(()=>o.error(new l("Cannot parse never schema")),()=>o.error(new l("Cannot validate never schema")),()=>{v("Cannot serialize never schema")}),h.string=h.typeof("string"),h.number=h.typeof("number"),h.bigint=h.typeof("bigint"),h.boolean=h.typeof("boolean"),h.null=new h(r=>r==null?o.ok(null):o.error(new l(`Expected null or undefined, got ${f(r)}`)),r=>r===null?o.ok(null):o.error(new l(`Expected null, got ${f(r)}`)),()=>null);let m=h;class q extends m{constructor(r){const e=t=>t===r?o.ok(r):o.error(new l(`Expected ${typeof r=="string"?`"${r}"`:String(r)}, got ${f(t)}`));super(e,e,w),this.value=r}}class B extends m{constructor(r){super(e=>typeof e!="object"||e===null?o.error(new l(`Expected object, got ${f(e)}`,[])):o.collect(x(this.config).map(([t,n])=>n.parse(g(e,t)).map(s=>[t,s]).mapErr(s=>y(s,t)))).map(t=>Object.fromEntries(t)),e=>{if(typeof e!="object"||e===null)return o.error(new l(`Expected object, got ${f(e)}`,[]));const t=new Set(z(e));for(const[n,s]of x(this.config)){t.delete(n);const i=g(e,n),c=s.validate(i);if(!c.ok)return c.mapErr(d=>y(d,n))}return t.size?o.error(new l(`Unknown properties: ${Array.from(t).map(n=>JSON.stringify(n)).join(", ")}`)):o.ok(e)},e=>{const t={};for(const[n,s]of x(this.config))t[n]=s.serialize(g(e,n));return t}),this.config=r}indexed(r){return new I(this,r)}}class I extends m{constructor(r,e){const t=[];for(const[n,s]of x(e))p(t[s]===void 0,`Duplicate index ${s} for keys "${n}" & "${t[s]}"`),t[s]=n;for(let n=0;n<t.length;n++)t[n]===void 0&&(t[n]=void 0);super(n=>typeof n!="object"||n===null?o.error(new l(`Expected an object or an array, got ${f(n)}`)):Array.isArray(n)?o.collect(x(r.config).map(([s,i])=>{const c=e[s];return i.parse(n[c]).map(d=>[s,d]).mapErr(d=>y(d,s,`(${c})`))})).map(s=>Object.fromEntries(s)):this.objectSchema.parse(n),n=>this.objectSchema.validate(n),n=>{const s=r.serialize(n);return p(typeof s=="object"&&s!==null,'Assertion Error: typeof serialized === "object" && serialized !== null'),this.keyByIndex.map(i=>i===void 0?null:g(s,i))}),this.objectSchema=r,this.indexByKey=e,this.keyByIndex=t}}class J extends m{constructor(r,e){const t=n=>{if(typeof n!="object"||n===null)return o.error(new l(`Expected an object, got ${f(n)}`,[]));const s=g(n,r);if(typeof s!="string")return o.error(new l(`Expected a string for key "${r}", got ${f(s)}`,[]));const i=$(e,s)?e[s]:void 0;return i===void 0?o.error(new l(`Expected one of ${Object.keys(this.config).map(c=>JSON.stringify(c)).join(" or ")}, got ${f(s)}`,[r])):o.ok({schema:i,variant:s})};super(n=>{const s=t(n);if(!s.ok)return s;const{schema:i,variant:c}=s.value;return i.parse(n).mapErr(d=>y(d,`(${r} = ${c})`))},n=>{const s=t(n);if(!s.ok)return s;const{schema:i,variant:c}=s.value;return i.validate(n).mapErr(d=>y(d,`(${r} = ${c})`))},n=>{const s=n[r],i=$(e,s)?this.config[s]:null;return p(i,`schema type ${String(s)} must exist`),i.serialize(n)}),this.key=r,this.config=e}}class N extends m{constructor(r,e){for(const[t,n]of x(e))p(n.keyByIndex[0]===r,`Variant ${t} must have ${r} at index 0`);super(t=>{if(typeof t!="object"||t===null)return o.error(new l(`Expected an object or an array, got ${f(t)}`,[]));const n=Array.isArray(t);let s=Array.isArray(t)?t[0]:g(t,r);if(typeof s=="number"&&(s=String(s)),typeof s!="string")return o.error(new l(`Expected a string, got ${f(s)}`,[n?0:r]));const i=$(e,s)?e[s]:void 0;return i===void 0?o.error(new l(`Expected one of ${Object.keys(this.config).map(c=>JSON.stringify(c)).join(" or ")}, got ${f(s)}`,[n?0:r])):i.parse(t).mapErr(c=>y(c,`(${r} = ${String(s)})`))},t=>{if(typeof t!="object"||t===null)return o.error(new l(`Expected an object, got ${f(t)}`,[]));const n=g(t,r);if(typeof n!="string")return o.error(new l(`Expected a string for key "${r}", got ${f(n)}`,[]));const s=$(e,n)?e[n]:void 0;return s===void 0?o.error(new l(`Expected one of ${Object.keys(this.config).map(i=>JSON.stringify(i)).join(" or ")}, got ${f(n)}`,[r])):s.validate(t).mapErr(i=>y(i,`(${r} = ${String(n)})`))},t=>{const n=t[r],s=$(e,n)?this.config[n]:null;return p(s,"Assertion Error: schema"),s.serialize(t)}),this.key=r,this.config=e}}const a=class a{constructor(r,e){this.x=r,this.y=e}static fromArgs(r){if(r.length===1)return a.from(r[0]);{const[e,t]=r;return new a(e,t)}}static fromPolar(r,e){return new a(e*Math.cos(r),e*Math.sin(r))}static average(r){return r.reduce((t,n)=>t.add(n),a.ZERO).div(r.length)}static from(r){return r instanceof a?r:Array.isArray(r)?new a(r[0],r[1]):(p("x"in r&&"y"in r,'Assertion Error: "x" in vectorIsh && "y" in vectorIsh'),new a(r.x,r.y))}static fromEvent({clientX:r,clientY:e}){return new a(r,e)}toString(r){const e=r==null?this.x:this.x.toFixed(r),t=r==null?this.y:this.y.toFixed(r);return`Vector2(${e}, ${t})`}toJson(){return{x:this.x,y:this.y}}magnitudeSquared(){return this.x*this.x+this.y*this.y}magnitude(){return Math.sqrt(this.magnitudeSquared())}angle(){return Math.atan2(this.y,this.x)}isInPolygon(r){const{x:e,y:t}=this;let n=!1;for(let s=0,i=r.length-1;s<r.length;i=s++){const{x:c,y:d}=r[s],{x:S,y:b}=r[i];d>t!=b>t&&e<(S-c)*(t-d)/(b-d)+c&&(n=!n)}return n}equals(...r){const e=a.fromArgs(r);return this===e||this.x===e.x&&this.y===e.y}distanceTo(...r){const e=a.fromArgs(r);return Math.hypot(this.x-e.x,this.y-e.y)}distanceToSquared(...r){const e=a.fromArgs(r),t=this.x-e.x,n=this.y-e.y;return t*t+n*n}angleTo(...r){return a.fromArgs(r).sub(this).angle()}angleBetween(...r){const e=a.fromArgs(r);return T(Math.atan2(e.y,e.x)-Math.atan2(this.y,this.x))}dot(...r){const e=a.fromArgs(r);return this.x*e.x+this.y*e.y}div(r){return new a(this.x/r,this.y/r)}scale(r){return new a(this.x*r,this.y*r)}mul(...r){const e=a.fromArgs(r);return new a(this.x*e.x,this.y*e.y)}negate(){return this.scale(-1)}add(...r){const e=a.fromArgs(r);return new a(this.x+e.x,this.y+e.y)}sub(...r){const e=a.fromArgs(r);return new a(this.x-e.x,this.y-e.y)}floor(){return new a(Math.floor(this.x),Math.floor(this.y))}ceil(){return new a(Math.ceil(this.x),Math.ceil(this.y))}round(){return new a(Math.round(this.x),Math.round(this.y))}withMagnitude(r){return this.scale(r/this.magnitude())}normalize(){return this.withMagnitude(1)}withAngle(r){return a.fromPolar(r,this.magnitude())}rotate(r){return this.withAngle(this.angle()+r)}rotateAround(r,e){r=a.from(r);const t=Math.sin(e),n=Math.cos(e),s=this.x-r.x,i=this.y-r.y,c=s*n-i*t,d=s*t+i*n;return new a(c+r.x,d+r.y)}lerp(r,e){return r=a.from(r),new a(E(this.x,r.x,e),E(this.y,r.y,e))}moveToward(r,e){const t=a.from(r).sub(this).normalize();return this.add(t.scale(e))}perpendicular(){return new a(this.y,-this.x)}project(r,e){return a.from(r).scale(e).add(this)}mapRange(r,e){return new a(j(r.left,r.right,e.left,e.right,this.x),j(r.top,r.bottom,e.top,e.bottom,this.y))}clamp(r){return new a(A(r.left,r.right,this.x),A(r.top,r.bottom,this.y))}};a.schema=m.object({x:m.number,y:m.number}).indexed({x:0,y:1}).instance(a,({x:r,y:e})=>o.ok(new a(r,e)),({x:r,y:e})=>({x:r,y:e})),a.ZERO=new a(0,0),a.UNIT=new a(1,1),a.X=new a(1,0),a.Y=new a(0,1);let k=a;export{o as R,m as S,k as V,l as a};
