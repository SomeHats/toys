{"mappings":"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","sources":["src/lib/utils.ts","src/lib/geom/Vector2.ts","src/lib/DebugDraw.ts","src/wiggle-gradient/canvas.ts","src/lib/assert.ts","src/wiggle-gradient/wiggle-gradient-main.ts","src/lib/createTriangleGrid.ts"],"sourcesContent":["export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n","import { normalizeAngle, lerp } from '../utils';\n\nexport default class Vector2 {\n  static readonly ZERO = new Vector2(0, 0);\n\n  static fromPolar(angle: number, radius: number) {\n    return new Vector2(radius * Math.cos(angle), radius * Math.sin(angle));\n  }\n\n  static average(points: ReadonlyArray<Vector2>): Vector2 {\n    const sum = points.reduce((memo, p) => memo.add(p), Vector2.ZERO);\n    return sum.div(points.length);\n  }\n\n  static fromVectorLike({ x, y }: { x: number; y: number }): Vector2 {\n    return new Vector2(x, y);\n  }\n\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  toString(): string {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n\n  get magnitudeSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  get magnitude(): number {\n    return Math.sqrt(this.magnitudeSquared);\n  }\n\n  get angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  isInPolygon(polygon: ReadonlyArray<Vector2>): boolean {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const { x, y } = this;\n\n    let isInside = false;\n    for (\n      let currentIdx = 0, previousIdx = polygon.length - 1;\n      currentIdx < polygon.length;\n      previousIdx = currentIdx++\n    ) {\n      const { x: currentX, y: currentY } = polygon[currentIdx];\n      const { x: previousX, y: previousY } = polygon[previousIdx];\n      const doesIntersect =\n        currentY > y != previousY > y &&\n        x <\n          ((previousX - currentX) * (y - currentY)) / (previousY - currentY) +\n            currentX;\n\n      if (doesIntersect) {\n        isInside = !isInside;\n      }\n    }\n\n    return isInside;\n  }\n\n  equals(other: Vector2) {\n    return this === other || (this.x === other.x && this.y === other.y);\n  }\n\n  distanceTo({ x, y }: Vector2): number {\n    const dx = x - this.x;\n    const dy = y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angleTo(other: Vector2): number {\n    return other.sub(this).angle;\n  }\n\n  angleBetween(other: Vector2): number {\n    return normalizeAngle(\n      Math.atan2(other.y, other.x) - Math.atan2(this.y, this.x),\n    );\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  div(scale: number): Vector2 {\n    return new Vector2(this.x / scale, this.y / scale);\n  }\n\n  scale(scale: number): Vector2 {\n    return new Vector2(this.x * scale, this.y * scale);\n  }\n\n  negate(): Vector2 {\n    return this.scale(-1);\n  }\n\n  add({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x + x, this.y + y);\n  }\n\n  sub({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x - x, this.y - y);\n  }\n\n  floor(): Vector2 {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  ceil(): Vector2 {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n\n  round(): Vector2 {\n    return new Vector2(Math.round(this.x), Math.round(this.y));\n  }\n\n  withMagnitude(newMagnitude: number): Vector2 {\n    return Vector2.fromPolar(this.angle, newMagnitude);\n  }\n\n  normalize(): Vector2 {\n    return this.withMagnitude(1);\n  }\n\n  withAngle(newAngle: number): Vector2 {\n    return Vector2.fromPolar(newAngle, this.magnitude);\n  }\n\n  rotate(byAngle: number): Vector2 {\n    return this.withAngle(this.angle + byAngle);\n  }\n\n  lerp(other: Vector2, n: number): Vector2 {\n    return new Vector2(lerp(this.x, other.x, n), lerp(this.y, other.y, n));\n  }\n}\n","import AABB from './geom/AABB';\nimport Vector2 from './geom/Vector2';\n\nconst DEFAULT_DEBUG_COLOR = 'magenta';\nconst LABEL_OFFSET = new Vector2(5, 0);\nconst DEBUG_POINT_SIZE = 3;\nconst HAIRLINE = 0.5;\nconst DEBUG_ARROW_ANGLE = Math.PI * 0.75;\nconst DEBUG_ARROW_SIZE = 5;\n\nexport type StrokeOptions = {\n  strokeWidth?: number;\n  stroke?: string;\n  strokeCap?: 'butt' | 'round' | 'square';\n  strokeDash?: number[];\n  strokeDashOffset?: number;\n  strokeJoin?: 'bevel' | 'round' | 'miter';\n};\n\nexport type FillOptions = {\n  fill?: string;\n};\n\nexport type DebugOptions = {\n  color?: string;\n  label?: string;\n};\n\nexport type StrokeAndFillOptions = StrokeOptions & FillOptions;\n\nexport class DebugDraw {\n  constructor(private readonly ctx: CanvasRenderingContext2D) {}\n\n  public clear(fill?: string) {\n    if (!fill) {\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      return;\n    }\n\n    this.applyFillOptions({ fill });\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n\n  public beginPath() {\n    this.ctx.beginPath();\n  }\n\n  public moveTo({ x, y }: Vector2) {\n    this.ctx.moveTo(x, y);\n  }\n\n  public lineTo({ x, y }: Vector2) {\n    this.ctx.lineTo(x, y);\n  }\n\n  public arc(\n    { x, y }: Vector2,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean,\n  ) {\n    this.ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  public arcTo(p1: Vector2, p2: Vector2, radius: number) {\n    this.ctx.arcTo(p1.x, p1.y, p2.x, p2.y, radius);\n  }\n\n  public applyStrokeOptions({\n    strokeWidth = 1,\n    stroke = undefined,\n    strokeCap = 'butt',\n    strokeDash = [],\n    strokeDashOffset = 0,\n    strokeJoin = 'round',\n  }: StrokeOptions) {\n    if (stroke) {\n      this.ctx.lineWidth = strokeWidth;\n      this.ctx.strokeStyle = stroke;\n      this.ctx.lineCap = strokeCap;\n      this.ctx.setLineDash(strokeDash);\n      this.ctx.lineDashOffset = strokeDashOffset;\n      this.ctx.lineJoin = strokeJoin;\n    }\n  }\n\n  public stroke(options: StrokeOptions) {\n    if (options.stroke) {\n      this.applyStrokeOptions(options);\n      this.ctx.stroke();\n    }\n  }\n\n  public applyFillOptions({ fill = undefined }: FillOptions) {\n    if (fill) {\n      this.ctx.fillStyle = fill;\n    }\n  }\n\n  public fill(options: FillOptions) {\n    if (options.fill) {\n      this.applyFillOptions(options);\n      this.ctx.fill();\n    }\n  }\n\n  public applyStrokeAndFillOptions(options: StrokeAndFillOptions) {\n    this.applyFillOptions(options);\n    this.applyStrokeOptions(options);\n  }\n\n  public strokeAndFill(options: StrokeAndFillOptions) {\n    this.fill(options);\n    this.stroke(options);\n  }\n\n  public getDebugStrokeOptions(\n    color: string = DEFAULT_DEBUG_COLOR,\n  ): StrokeOptions {\n    return { stroke: color, strokeWidth: HAIRLINE };\n  }\n\n  public debugStroke(color: string = DEFAULT_DEBUG_COLOR) {\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n\n  public fillText(text: string, position: Vector2, options: FillOptions = {}) {\n    this.applyFillOptions(options);\n    this.ctx.fillText(text, position.x, position.y);\n  }\n\n  public circle(\n    center: Vector2,\n    radius: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.arc(center, radius, 0, 2 * Math.PI);\n    this.strokeAndFill(options);\n  }\n\n  public ellipse(\n    center: Vector2,\n    radiusX: number,\n    radiusY: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.ctx.ellipse(center.x, center.y, radiusX, radiusY, 0, 0, Math.PI * 2);\n    this.strokeAndFill(options);\n  }\n\n  public debugLabel(\n    label: string | undefined,\n    position: Vector2,\n    color: string,\n  ) {\n    if (label) {\n      this.applyFillOptions({ fill: color });\n      this.fillText(label, position.add(LABEL_OFFSET));\n    }\n  }\n\n  public debugPointX(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.beginPath();\n    this.ctx.moveTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.ctx.moveTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugPointO(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.circle(position, DEBUG_POINT_SIZE, {\n      strokeWidth: HAIRLINE,\n      stroke: color,\n    });\n  }\n\n  public debugArrow(\n    start: Vector2,\n    end: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, Vector2.average([start, end]), color);\n\n    this.ctx.beginPath();\n    this.moveTo(start);\n    this.lineTo(end);\n\n    const vector = end.sub(start);\n    const arrowLeftPoint = vector\n      .rotate(-DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n    const arrowRightPoint = vector\n      .rotate(+DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n\n    this.moveTo(arrowLeftPoint);\n    this.lineTo(end);\n    this.lineTo(arrowRightPoint);\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugVectorAtPoint(\n    vector: Vector2,\n    base: Vector2,\n    options?: DebugOptions,\n  ) {\n    this.debugArrow(base, base.add(vector), options);\n  }\n\n  public polygon(\n    polygon: ReadonlyArray<Vector2>,\n    options: StrokeAndFillOptions = {},\n  ) {\n    this.beginPath();\n    this.moveTo(polygon[polygon.length - 1]);\n    for (const point of polygon) {\n      this.lineTo(point);\n    }\n    this.strokeAndFill(options);\n  }\n\n  public polyLine(points: ReadonlyArray<Vector2>, options: StrokeOptions = {}) {\n    this.beginPath();\n    this.moveTo(points[0]);\n    for (let i = 1; i < points.length; i++) {\n      this.lineTo(points[i]);\n    }\n    this.stroke(options);\n  }\n\n  public debugPolygon(\n    polygon: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polygon[0], color);\n    this.polygon(polygon, this.getDebugStrokeOptions(color));\n  }\n\n  public debugPolyLine(\n    polyLine: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polyLine[0], color);\n    this.polyLine(polyLine, this.getDebugStrokeOptions(color));\n  }\n\n  public aabb(\n    aabb: AABB,\n    opts: StrokeAndFillOptions & { debug?: DebugOptions },\n  ) {\n    if (opts.debug) {\n      this.debugLabel(\n        opts.debug.label,\n        aabb.origin,\n        opts.debug.color || DEFAULT_DEBUG_COLOR,\n      );\n    }\n    this.ctx.beginPath();\n    this.ctx.rect(aabb.left, aabb.top, aabb.width, aabb.height);\n    this.strokeAndFill(opts);\n  }\n}\n","import { DebugDraw } from '../lib/DebugDraw';\n\nexport const canvasEl = document.createElement('canvas');\nexport const ctx = canvasEl.getContext('2d')!;\nexport const width = document.body.clientWidth;\nexport const height = document.body.clientHeight;\nexport const scale = window.devicePixelRatio;\n\ncanvasEl.width = width * scale;\ncanvasEl.height = height * scale;\ncanvasEl.style.width = `${width}px`;\ncanvasEl.style.height = `${height}px`;\nctx.scale(scale, scale);\nexport const canvas = new DebugDraw(ctx);\ndocument.body.appendChild(canvasEl);\n","export function fail(message: string): never {\n  throw new Error(message);\n}\n\nexport function assert(value: unknown, message?: string): asserts value {\n  if (!value) {\n    fail(message || 'Assertion Error');\n  }\n}\n","import { canvas, width, height } from './canvas';\nimport Vector2 from '../lib/geom/Vector2';\nimport {\n  sample,\n  times,\n  randomInt,\n  frameLoop,\n  uniq,\n  random,\n  lerp,\n  mapRange,\n} from '../lib/utils';\nimport createTriangleGrid, { Triangle } from '../lib/createTriangleGrid';\nimport { assert } from '../lib/assert';\n\nconst TILE_SIZE = 15;\nconst ARC_LENGTH = (Math.PI * TILE_SIZE) / 6;\n\nconst trianglesById = createTriangleGrid(TILE_SIZE, width, height);\n\nconst occupied = new Set<Triangle>();\ntype Snake = {\n  triangles: Array<Triangle>;\n};\n\nconst makeSnake = () => {\n  const triangles: Array<Triangle> = [];\n  let triangle = sample(\n    [...trianglesById.values()].filter(t => !occupied.has(t)),\n  );\n  // if (!triangle) return;\n\n  // const targetLength = mapRange(\n  //   Math.min(width, height) * 0.4,\n  //   0,\n  //   2,\n  //   35,\n  //   triangle.center.distanceTo(new Vector2(width / 2, height / 2)),\n  // );\n  const targetLength = 40;\n  let neighbours = [...trianglesById.values()];\n  for (let i = 0; i < targetLength; i++) {\n    triangles.push(triangle);\n    occupied.add(triangle);\n    neighbours = triangle.neighbours.map(n => n.triangle);\n\n    const availableNeighbours = neighbours.filter(\n      neighbour => !occupied.has(neighbour),\n    );\n    if (!availableNeighbours.length) break;\n    triangle = sample(availableNeighbours);\n  }\n\n  // if (triangles.length < 2) continue;\n  return {\n    triangles,\n  };\n};\nconst snakes: Snake[] = [];\n\nconst snakeCount = (width / TILE_SIZE) * (height / TILE_SIZE) * 0.01;\nconsole.log({ snakeCount });\nfor (let si = 0; si < snakeCount; si++) {\n  snakes.push(makeSnake());\n}\n\ncanvas.clear('black');\n\nfor (const { triangles } of snakes) {\n  canvas.beginPath();\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const last: Triangle | undefined = triangles[i - 1];\n    const next: Triangle | undefined = triangles[i + 1];\n\n    if (!last) {\n      canvas.moveTo(triangle.center);\n    } else if (!next) {\n      assert(last);\n      // canvas.moveTo(Vector2.average(getSharedPoints(triangle, last)));\n      canvas.lineTo(triangle.center);\n    } else {\n      // canvas.moveTo(Vector2.average(getSharedPoints(triangle, last)));\n      canvas.arcTo(triangle.center, next.center, TILE_SIZE / 2 - 0.5);\n    }\n  }\n  canvas.stroke({\n    strokeWidth: TILE_SIZE / 3 - 0.5,\n    stroke: 'white',\n    strokeCap: 'round',\n  });\n}\n","import Vector2 from '../lib/geom/Vector2';\nimport { getId, compact, intersection } from '../lib/utils';\nimport Intersection from '../network/networkNodes/Intersection';\n\ntype TriangleGeom = [Vector2, Vector2, Vector2];\ntype IntermediateTriangle = {\n  id: string;\n  points: TriangleGeom;\n};\n\nexport type TriangleNeighbour = {\n  triangle: Triangle;\n  sharedPoints: [Vector2, Vector2];\n};\nexport type Triangle = {\n  id: string;\n  center: Vector2;\n  points: TriangleGeom;\n  neighbours: TriangleNeighbour[];\n  ix: number;\n  iy: number;\n};\n\nexport default function createTriangleGrid(\n  tileSize: number,\n  width: number,\n  height: number,\n): Map<string, Triangle> {\n  const tileHeight = (tileSize * Math.sqrt(3)) / 2;\n  const points: Vector2[][] = [];\n  const trianglePoints: IntermediateTriangle[][] = [];\n  for (let iy = 0; iy * tileHeight < height + tileHeight; iy++) {\n    const pointRow: Vector2[] = [];\n    points.push(pointRow);\n    const triangleRow: IntermediateTriangle[] = [];\n    trianglePoints.push(triangleRow);\n    for (let ix = 0; ix * tileSize < width + tileSize; ix++) {\n      const xOffset = iy % 2 === 0 ? -tileSize / 2 : 0;\n      const point = new Vector2(ix * tileSize + xOffset, iy * tileHeight);\n      pointRow.push(point);\n\n      if (iy !== 0 && ix !== 0) {\n        if (iy % 2 === 0) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix - 1]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix - 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        } else if (points[iy - 1][ix + 1]) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix + 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        }\n      }\n    }\n  }\n\n  const trianglesById = new Map<string, Triangle>();\n  for (let iy = 0; iy < trianglePoints.length; iy++) {\n    for (let ix = 0; ix < trianglePoints[iy].length; ix++) {\n      const triangle = trianglePoints[iy][ix];\n      const center = Vector2.average(triangle.points);\n\n      const neighbours = compact(\n        ix % 2 === 0\n          ? iy % 2 === 0\n            ? [\n                // 2,2\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix - 1],\n              ]\n            : [\n                // 2,3\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix + 1],\n              ]\n          : iy % 2 === 0\n          ? [\n              // 3,2\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix - 1],\n            ]\n          : [\n              //3,3\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix + 1],\n            ],\n      );\n\n      const fullTriangle = triangle as Triangle;\n      fullTriangle.center = center;\n      fullTriangle.neighbours = neighbours.map(neighbourTriangle => ({\n        triangle: neighbourTriangle,\n        sharedPoints: intersection(triangle.points, neighbourTriangle.points),\n      })) as TriangleNeighbour[];\n      fullTriangle.ix = ix;\n      fullTriangle.iy = iy;\n\n      trianglesById.set(fullTriangle.id, fullTriangle);\n    }\n  }\n\n  return trianglesById;\n}\n"],"names":["$15a201ffde8bbde4$export$3a89f8d6f6bf6c9f","a","b","n","$15a201ffde8bbde4$export$4385e60b38654f68","Math","random","$15a201ffde8bbde4$export$4812e460280c6ef2","arr","floor","length","$15a201ffde8bbde4$export$bc86dfbf7795668c","a1","a2","a1Items","Set","result","item","has","add","Array","from","$15a201ffde8bbde4$export$218c8c3169c024d2","prefix","toString","slice","$db8edb9c8035529a$export$2e2bcd8739ae039","angle","radius","cos","sin","points","reduce","memo","p","ZERO","div","x","y","this","magnitudeSquared","magnitude","sqrt","atan2","isInPolygon","polygon","isInside","currentIdx","previousIdx","currentX","currentY","previousX","previousY","equals","other","distanceTo","x1","y1","dx","dy","angleTo","other1","sub","angleBetween","other2","min","max","size","$15a201ffde8bbde4$export$9013bf5175691fac","PI","dot","other3","scale","scale1","negate","x2","y2","x3","y3","ceil","round","withMagnitude","newMagnitude","fromPolar","normalize","withAngle","newAngle","rotate","byAngle","lerp","other4","x4","y4","$870293e39def1396$var$LABEL_OFFSET","$870293e39def1396$var$DEBUG_ARROW_ANGLE","$62d7d4a770b84d11$export$38c8a1558598a89e","document","createElement","$62d7d4a770b84d11$export$39f92e86d1722f3a","getContext","$62d7d4a770b84d11$export$7e3df82ee760448c","body","clientWidth","$62d7d4a770b84d11$export$ac607276a8fe9f0a","clientHeight","$62d7d4a770b84d11$export$dcdf75081b88279d","window","devicePixelRatio","width","height","style","$62d7d4a770b84d11$export$67ea982130081db","clear","fill","applyFillOptions","ctx","fillRect","canvas","clearRect","beginPath","moveTo","lineTo","arc","startAngle","endAngle","anticlockwise","arcTo","p1","p2","radius1","applyStrokeOptions","strokeWidth","stroke","strokeCap","strokeDash","strokeDashOffset","strokeJoin","lineWidth","strokeStyle","lineCap","setLineDash","lineDashOffset","lineJoin","options","fill1","fillStyle","options1","applyStrokeAndFillOptions","options2","strokeAndFill","options3","getDebugStrokeOptions","color","debugStroke","color1","fillText","text","position","options4","circle","center","radius2","options5","ellipse","center1","radiusX","radiusY","options6","debugLabel","label","position1","color2","debugPointX","position2","color3","label1","debugPointO","position3","color4","label2","debugArrow","start","end","color5","label3","average","vector","arrowLeftPoint","arrowRightPoint","debugVectorAtPoint","base","options7","options8","point","polyLine","options9","i","debugPolygon","polygon1","color6","label4","debugPolyLine","color7","label5","aabb","opts","debug","origin","rect","left","top","$90518cd969dab22c$export$a7a9523472993e97","value","message","Error","$90518cd969dab22c$export$2b62a06a9fee979c","appendChild","$c021df05886090e0$var$trianglesById","tileSize","tileHeight","trianglePoints","iy","pointRow","push","triangleRow","ix","triangle1","id","triangle2","trianglesById","Map","iy1","ref","ref1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","ref10","ref11","triangle","neighbours","filter","fullTriangle","map","neighbourTriangle","sharedPoints","set","$dd4ecc289fc2ac4a$export$2e2bcd8739ae039","$c021df05886090e0$var$occupied","$c021df05886090e0$var$makeSnake","triangles","values","t","availableNeighbours","neighbour","$c021df05886090e0$var$snakes","$c021df05886090e0$var$snakeCount","console","log","si","triangles1","last","next","$c021df05886090e0$var$TILE_SIZE"],"version":3,"file":"index.424d4085.js.map"}