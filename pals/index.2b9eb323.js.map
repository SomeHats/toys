{"mappings":"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","sources":["src/lib/scene/SceneObject.ts","src/lib/scene/SortOrderProvider.ts","src/pals/pals-main.ts","src/lib/scene/Scene.ts","src/lib/scene/Entity.ts"],"sourcesContent":["import { assert } from '../assert';\nimport Scene from './Scene';\n\nconst constructorIdCounts = {} as Record<string, number>;\n\nconst getNextCount = (name: string): string => {\n  if (!constructorIdCounts[name]) constructorIdCounts[name] = 0;\n  return `${name}@${constructorIdCounts[name]++}`;\n};\n\nexport default abstract class SceneObject {\n  id: string = getNextCount(this.constructor.name);\n  private scene: Scene | null = null;\n\n  hasScene(): boolean {\n    return this.scene !== null;\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene must be present');\n    return this.scene;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {}\n  update(delta: number): void {}\n\n  addTo(scene: Scene): this {\n    scene.addChild(this);\n    return this;\n  }\n\n  onAddedToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  onRemovedFromScene() {\n    this.scene = null;\n  }\n\n  getSortOrder(): number {\n    return 0;\n  }\n}\n","import Component from './Component';\nimport Entity from './Entity';\n\nexport default class SortOrderProvider extends Component {\n  constructor(\n    entity: Entity,\n    private getSortOrderFn: (entity: Entity) => number,\n  ) {\n    super(entity);\n  }\n\n  getSortOrder(): number {\n    return this.getSortOrderFn(this.entity);\n  }\n}\n","import Scene from '../lib/scene/Scene';\nimport { assert } from '../lib/assert';\nimport Vector2 from '../lib/geom/Vector2';\nimport Entity from '../lib/scene/Entity';\nimport { PalTargetController } from './PalController';\nimport PalGeom from './PalGeom';\nimport PalRenderer from './PalRenderer';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport { generateRandomPalConfig } from './PalConfig';\n\nconst root = document.getElementById('root');\nassert(root);\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nscene.appendTo(root);\n\n// const pal = new Pal(100, 50);\nconst pal = new Entity();\npal.addComponent(PalTargetController, new Vector2(100, 50));\nconst config = generateRandomPalConfig();\nconst geom = pal.addComponent(PalGeom, config);\ngeom.setAnimationController(new PalWalkAnimationController(config));\npal.addComponent(PalRenderer, config);\nscene.addChild(pal);\n\nroot.addEventListener('mousemove', e => {\n  const x = e.clientX - scene.canvas.offsetLeft;\n  const y = e.clientY - scene.canvas.offsetTop;\n  pal.getComponent(PalTargetController).setTarget(new Vector2(x - 50, y));\n});\n\nscene.start();\n\n// const scenario5 = () => {\n//   const pal = new Pal(100, 50);\n//   scene.addChild(pal);\n\n//   const root = document.getElementById('root');\n//   invariant(root, '#root must be present');\n\n//   root.addEventListener('mousemove', e => {\n//     pal.setTarget(e.offsetX / scene.scaleFactor, e.offsetY / scene.scaleFactor);\n//   });\n// };\n\n// const go = () => {\n//   if (window.scene) return;\n//   scene = new Scene(800, 600, window.devicePixelRatio);\n//   window.scene = scene;\n//   const root = document.getElementById('root');\n//   invariant(root, '#root must be present');\n//   scene.appendTo(root);\n\n//   scene.addSystem(new DebugOverlay());\n//   scene.addSystem(new TravellerFinder());\n\n//   scenario3();\n\n//   scene.start();\n// };\n","import { assert } from '../assert';\nimport SceneObject from './SceneObject';\nimport SceneSystem from './SceneSystem';\n\nconst speed = 1;\nconst scale = 1;\nconst repeatUpdate = 1;\n\ntype SystemClass<T extends SceneSystem = SceneSystem> = {\n  systemName: string;\n  new (): T;\n};\n\nexport default class Scene {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  private _scaleFactor: number;\n  private _children: SceneObject[] = [];\n  private _isPlaying: boolean = false;\n  private frameHandle: number | null = null;\n  private lastElapsedTime: number | null = null;\n  private systemsByClass = new Map<SystemClass<SceneSystem>, SceneSystem>();\n\n  constructor(width: number, height: number, scaleFactor: number = 1) {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = width * scaleFactor;\n    this.canvas.height = height * scaleFactor;\n    this.canvas.style.width = `${width}px`;\n    this.canvas.style.height = `${height}px`;\n    const ctx = this.canvas.getContext('2d');\n    assert(ctx, 'ctx');\n    this.ctx = ctx;\n    this._scaleFactor = scaleFactor * scale;\n\n    this._setupVisiblityChange();\n  }\n\n  get width(): number {\n    return this.canvas.width / this._scaleFactor;\n  }\n\n  get height(): number {\n    return this.canvas.height / this._scaleFactor;\n  }\n\n  get scaleFactor(): number {\n    return this._scaleFactor;\n  }\n\n  get isPlaying(): boolean {\n    return this.frameHandle !== null && this._isPlaying;\n  }\n\n  set isPlaying(newValue: boolean) {\n    assert(\n      this.frameHandle !== null,\n      'cannot set isPlaying without calling start',\n    );\n    this._isPlaying = newValue;\n  }\n\n  get children(): SceneObject[] {\n    return this._children;\n  }\n\n  appendTo(element: HTMLElement) {\n    element.appendChild(this.canvas);\n  }\n\n  hasSystem(systemType: SystemClass): boolean {\n    return this.systemsByClass.has(systemType);\n  }\n\n  getSystem<T extends SceneSystem>(systemType: SystemClass<T>): T {\n    const system = this.systemsByClass.get(systemType);\n    assert(system, `system, ${systemType.systemName} not found`);\n    assert(system instanceof systemType, 'system is wrong instance type');\n    return system;\n  }\n\n  addSystem(system: SceneSystem) {\n    assert(\n      !this.hasSystem(system.constructor as any),\n      'only one system of each type allowed',\n    );\n    this.systemsByClass.set(system.constructor as any, system);\n    system.afterAddToScene(this);\n  }\n\n  removeSystem(systemType: SystemClass) {\n    const system = this.getSystem(systemType);\n    system.beforeRemoveFromScene(this);\n    this.systemsByClass.delete(systemType);\n  }\n\n  addChild(child: SceneObject) {\n    this._children.push(child);\n    child.onAddedToScene(this);\n  }\n\n  addChildBefore(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index, newChild);\n  }\n\n  addChildAfter(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index + 1, newChild);\n  }\n\n  addChildAtIndex(index: number, child: SceneObject) {\n    this._children.splice(index, 0, child);\n    child.onAddedToScene(this);\n  }\n\n  removeChild(child: SceneObject): boolean {\n    const index = this._children.indexOf(child);\n    if (index === -1) return false;\n\n    this.removeChildAtIndex(index);\n    return true;\n  }\n\n  removeChildAtIndex(index: number): SceneObject {\n    const child = this._children[index];\n    this._children.splice(index, 1);\n    child.onRemovedFromScene();\n    return child;\n  }\n\n  update(delta: number) {\n    for (let i = 0; i < repeatUpdate; i++) {\n      for (const system of this.systemsByClass.values()) {\n        system.beforeUpdate(delta);\n      }\n      this._children.forEach((child) => child.update(delta));\n      for (const system of this.systemsByClass.values()) {\n        system.afterUpdate(delta);\n      }\n    }\n  }\n\n  draw(elapsedTime: number) {\n    this.ctx.save();\n    this.ctx.scale(this._scaleFactor, this._scaleFactor);\n    this.ctx.clearRect(0, 0, this.width, this.height);\n\n    for (const system of this.systemsByClass.values()) {\n      system.beforeDraw(this.ctx, elapsedTime);\n    }\n    this._children\n      .sort((a, b) => a.getSortOrder() - b.getSortOrder())\n      .forEach((child) => child.draw(this.ctx, elapsedTime));\n    for (const system of this.systemsByClass.values()) {\n      system.afterDraw(this.ctx, elapsedTime);\n    }\n\n    this.ctx.restore();\n  }\n\n  start() {\n    this._isPlaying = true;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  }\n\n  stop() {\n    if (this.frameHandle !== null) {\n      window.cancelAnimationFrame(this.frameHandle);\n      this.frameHandle = null;\n    }\n    this._isPlaying = false;\n    this.lastElapsedTime = null;\n  }\n\n  _tick = (elapsedTime: number) => {\n    elapsedTime = elapsedTime * speed;\n    const lastElapsedTime = this.lastElapsedTime;\n    if (lastElapsedTime !== null) {\n      const deltaTime = elapsedTime - lastElapsedTime;\n      if (this.isPlaying) {\n        this.update(deltaTime);\n        this.draw(elapsedTime);\n      }\n    }\n\n    this.lastElapsedTime = elapsedTime;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  };\n\n  _setupVisiblityChange() {\n    let playOnVisible = false;\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.isPlaying) {\n        playOnVisible = true;\n        this.stop();\n      }\n      if (playOnVisible && !document.hidden) {\n        playOnVisible = false;\n        this.start();\n      }\n    });\n  }\n}\n","import SceneObject from './SceneObject';\nimport Component from './Component';\nimport { assert } from '../assert';\nimport SortOrderProvider from './SortOrderProvider';\nimport Scene from './Scene';\n\ntype ComponentClass<T extends Component, Args extends unknown[]> = {\n  name: string;\n  new (entity: Entity, ...args: Args): T;\n};\n\nexport default class Entity extends SceneObject {\n  private componentInstances = new Map<\n    ComponentClass<Component, any>,\n    Component\n  >();\n\n  addComponent<T extends Component, Args extends unknown[]>(\n    component: ComponentClass<T, Args>,\n    ...args: Args\n  ): T {\n    assert(\n      !this.componentInstances.has(component),\n      `component instance ${component.name} already exists`,\n    );\n    const instance = new component(this, ...args);\n    this.componentInstances.set(component, instance);\n    return instance;\n  }\n\n  hasComponent<T extends Component>(\n    component: ComponentClass<T, any[]>,\n  ): boolean {\n    return this.componentInstances.has(component);\n  }\n\n  getComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.componentInstances.get(component);\n    assert(instance, `no instance for ${component.name} exists`);\n    assert(instance instanceof component, 'wrong instance type');\n    return instance;\n  }\n\n  removeComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.getComponent(component);\n    this.componentInstances.delete(component);\n    instance.onRemove();\n    return instance;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeDraw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.draw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterDraw(ctx, elapsedTime);\n    }\n  }\n  update(delta: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeUpdate(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.update(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterUpdate(delta);\n    }\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    for (const component of this.componentInstances.values()) {\n      component.onAddedToScene(scene);\n    }\n  }\n\n  onRemovedFromScene() {\n    const scene = this.getScene();\n    super.onRemovedFromScene();\n    for (const component of this.componentInstances.values()) {\n      component.onRemovedFromScene(scene);\n    }\n  }\n\n  getSortOrder() {\n    if (this.hasComponent(SortOrderProvider)) {\n      return this.getComponent(SortOrderProvider).getSortOrder();\n    } else {\n      return super.getSortOrder();\n    }\n  }\n}\n"],"names":["$0590d9fc1b9817be$var$constructorIdCounts","$28c70117a47ab52b$export$2e2bcd8739ae039","$7ic2V","default","getSortOrder","this","getSortOrderFn","entity","super","$5ebfe5b610acfaad$var$root","document","getElementById","$87DYR","assert","$5ebfe5b610acfaad$var$scene","width","canvas","_scaleFactor","height","scaleFactor","isPlaying","frameHandle","_isPlaying","newValue","children","_children","appendTo","element","appendChild","hasSystem","systemType","systemsByClass","has","getSystem","systemType1","system","get","systemName","addSystem","constructor","set","afterAddToScene","removeSystem","systemType2","beforeRemoveFromScene","delete","addChild","child3","push","onAddedToScene","addChildBefore","targetChild","newChild","index","indexOf","addChildAtIndex","addChildAfter","targetChild1","newChild1","child1","splice","removeChild","child2","removeChildAtIndex","index1","child","onRemovedFromScene","update","delta","i","values","beforeUpdate","forEach","system1","afterUpdate","draw","elapsedTime1","ctx","save","scale","clearRect","beforeDraw","sort","a","b","system2","afterDraw","restore","start","window","requestAnimationFrame","_tick","stop","cancelAnimationFrame","lastElapsedTime","_setupVisiblityChange","playOnVisible","addEventListener","hidden","Map","elapsedTime","deltaTime","createElement","style","getContext","devicePixelRatio","$5ebfe5b610acfaad$var$pal","hasScene","scene","getScene","addTo","scene1","name","id","addComponent","component","args","componentInstances","instance","hasComponent","component1","getComponent","component2","removeComponent","component3","onRemove","component4","component5","component6","component7","$19ECN","PalTargetController","$6i1fg","$5ebfe5b610acfaad$var$config","$h8N2y","generateRandomPalConfig","$2dNNZ","setAnimationController","$k9rmw","$exw1r","e","x","clientX","offsetLeft","y","clientY","offsetTop","setTarget"],"version":3,"file":"index.2b9eb323.js.map"}