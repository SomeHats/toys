<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/webmidi.js - WebMidi.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://djipco.github.io/webmidi/images/webmidijs-logo-small.png" title="WebMidi.js"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.5.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/Output.html">Output</a></li>
                                <li><a href="../classes/WebMidi.html">WebMidi</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/webmidi.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(scope) {

  &quot;use strict&quot;;

  /**
   * The &#x60;WebMidi&#x60; object makes it easier to work with the Web MIDI API. Basically, it simplifies
   * two things: sending outgoing MIDI messages and reacting to incoming MIDI messages.
   *
   * Sending MIDI messages is done via an &#x60;Output&#x60; object. All available outputs can be accessed in
   * the &#x60;WebMidi.outputs&#x60; array. There is one &#x60;Output&#x60; object for each output port available on
   * your system. Similarly, reacting to MIDI messages as they are coming in is simply a matter of
   * adding a listener to an &#x60;Input&#x60; object. Similarly, all inputs can be found in the
   * &#x60;WebMidi.inputs&#x60; array.
   *
   * Please note that a single hardware device might create more than one input and/or output ports.
   *
   * #### Sending messages
   *
   * To send MIDI messages, you simply need to call the desired method (&#x60;playNote()&#x60;,
   * &#x60;sendPitchBend()&#x60;, &#x60;stopNote()&#x60;, etc.) from an &#x60;Output&#x60; object and pass in the appropriate
   * parameters. All the native MIDI communication will be handled for you. The only additional
   * thing that needs to be done is to first enable &#x60;WebMidi&#x60;. Here is an example:
   *
   *      WebMidi.enable(function(err) {
   *        if (err) console.log(&quot;An error occurred&quot;, err);
   *        WebMidi.outputs[0].playNote(&quot;C3&quot;);
   *      });
   *
   * The code above, calls the &#x60;WebMidi.enable()&#x60; method. Upon success, this method executes the
   * callback function specified as a parameter. In this case, the callback calls the &#x60;playnote()&#x60;
   * function to play a 3rd octave C on the first available output port.
   *
   * #### Receiving messages
   *
   * Receiving messages is just as easy. You simply have to set a callback function to be triggered
   * when a specific MIDI message is received. For example, here&quot;s how to listen for pitch bend
   * events on the first input port:
   *
   *      WebMidi.enable(function(err) {
   *        if (err) console.log(&quot;An error occurred&quot;, err);
   *
   *        WebMidi.inputs[0].addListener(&quot;pitchbend&quot;, &quot;all&quot;, function(e) {
   *          console.log(&quot;Pitch value: &quot; + e.value);
   *        });
   *
   *      });
   *
   * As you can see, this library is much easier to use than the native Web MIDI API. No need to
   * manually craft or decode binary MIDI messages anymore!
   *
   * @class WebMidi
   * @static
   *
   * @throws Error WebMidi is a singleton, it cannot be instantiated directly.
   *
   * @todo  Switch away from yuidoc (deprecated) to be able to serve doc over https
   * @todo  Yuidoc does not allow multiple exceptions (@throws) for a single method ?!
   *
   */
  function WebMidi() {

    // Singleton. Prevent instantiation through WebMidi.__proto__.constructor()
    if (WebMidi.prototype._singleton) {
      throw new Error(&quot;WebMidi is a singleton, it cannot be instantiated directly.&quot;);
    }
    WebMidi.prototype._singleton = this;

    // MIDI inputs and outputs
    this._inputs = [];
    this._outputs = [];

    // Object to hold all user-defined handlers for interface-wide events (connected, disconnected,
    // etc.)
    this._userHandlers = {};

    // Array of statechange events to process. These events must be parsed synchronously so they do
    // not override each other.
    this._stateChangeQueue = [];

    // Indicates whether we are currently processing a statechange event (in which case new events
    // are to be queued).
    this._processingStateChange = false;

    // Events triggered at the interface level (WebMidi)
    this._midiInterfaceEvents = [&quot;connected&quot;, &quot;disconnected&quot;];

    // the current nrpns being constructed, by channel
    this._nrpnBuffer = [[],[],[],[], [],[],[],[], [],[],[],[], [],[],[],[]];

    // Enable/Disable NRPN event dispatch
    this._nrpnEventsEnabled = true;

    // NRPN message types
    this._nrpnTypes = [&quot;entry&quot;, &quot;increment&quot;, &quot;decrement&quot;];

    // Notes and semitones for note guessing
    this._notes = [&quot;C&quot;, &quot;C#&quot;, &quot;D&quot;, &quot;D#&quot;, &quot;E&quot;, &quot;F&quot;, &quot;F#&quot;, &quot;G&quot;, &quot;G#&quot;, &quot;A&quot;, &quot;A#&quot;, &quot;B&quot;];
    this._semitones = {C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };

    // Define some &quot;static&quot; properties
    Object.defineProperties(this, {

      /**
       * [read-only] List of valid MIDI system messages and matching hexadecimal values.
       *
       * Note: values 249 and 253 are actually dispatched by the Web MIDI API but I do not know what
       * they are used for. They are not part of the online
       * [MIDI 1.0 spec](http://www.midi.org/techspecs/midimessages.php).
       *
       * @property MIDI_SYSTEM_MESSAGES
       * @type Object
       * @static
       *
       * @since 2.0.0
       */
      MIDI_SYSTEM_MESSAGES: {
        value: {

          // System common messages
          sysex: 0xF0,            // 240
          timecode: 0xF1,         // 241
          songposition: 0xF2,     // 242
          songselect: 0xF3,       // 243
          tuningrequest: 0xF6,    // 246
          sysexend: 0xF7,         // 247 (never actually received - simply ends a sysex)

          // System real-time messages
          clock: 0xF8,            // 248
          start: 0xFA,            // 250
          continue: 0xFB,         // 251
          stop: 0xFC,             // 252
          activesensing: 0xFE,    // 254
          reset: 0xFF,            // 255

          // Custom WebMidi.js messages
          midimessage: 0,
          unknownsystemmessage: -1
        },
        writable: false,
        enumerable: true,
        configurable: false
      },

      /**
       * [read-only] An object containing properties for each MIDI channel messages and their
       * associated hexadecimal value.
       *
       * @property MIDI_CHANNEL_MESSAGES
       * @type Object
       * @static
       *
       * @since 2.0.0
       */
      MIDI_CHANNEL_MESSAGES: {
        value: {
          noteoff: 0x8,           // 8
          noteon: 0x9,            // 9
          keyaftertouch: 0xA,     // 10
          controlchange: 0xB,     // 11
          channelmode: 0xB,       // 11
          nrpn: 0xB,              // 11
          programchange: 0xC,     // 12
          channelaftertouch: 0xD, // 13
          pitchbend: 0xE          // 14
        },
        writable: false,
        enumerable: true,
        configurable: false
      },

      /**
       * [read-only] An object containing properties for each registered parameters and their
       * associated pair of hexadecimal values. MIDI registered parameters extend the original list
       * of control change messages (a.k.a. CC messages). Currently, there are only a limited number
       * of them.
       *
       * @property MIDI_REGISTERED_PARAMETER
       * @type Object
       * @static
       *
       * @since 2.0.0
       */
      MIDI_REGISTERED_PARAMETER: {
        value: {
          pitchbendrange: [0x00, 0x00],
          channelfinetuning: [0x00, 0x01],
          channelcoarsetuning: [0x00, 0x02],
          tuningprogram: [0x00, 0x03],
          tuningbank: [0x00, 0x04],
          modulationrange: [0x00, 0x05],

          azimuthangle: [0x3D, 0x00],
          elevationangle: [0x3D, 0x01],
          gain: [0x3D, 0x02],
          distanceratio: [0x3D, 0x03],
          maximumdistance: [0x3D, 0x04],
          maximumdistancegain: [0x3D, 0x05],
          referencedistanceratio: [0x3D, 0x06],
          panspreadangle: [0x3D, 0x07],
          rollangle: [0x3D, 0x08]
        },
        writable: false,
        enumerable: true,
        configurable: false
      },

      /**
       * [read-only] An object containing properties for each MIDI control change messages (a.k.a.
       * CC messages) and their associated hexadecimal value.
       *
       * @property MIDI_CONTROL_CHANGE_MESSAGES
       * @type Object
       * @static
       *
       * @since 2.0.0
       */
      MIDI_CONTROL_CHANGE_MESSAGES: {
        value: {
          bankselectcoarse: 0,
          modulationwheelcoarse: 1,
          breathcontrollercoarse: 2,
          footcontrollercoarse: 4,
          portamentotimecoarse: 5,
          dataentrycoarse: 6,
          volumecoarse: 7,
          balancecoarse: 8,
          pancoarse: 10,
          expressioncoarse: 11,
          effectcontrol1coarse: 12,
          effectcontrol2coarse: 13,
          generalpurposeslider1: 16,
          generalpurposeslider2: 17,
          generalpurposeslider3: 18,
          generalpurposeslider4: 19,
          bankselectfine: 32,
          modulationwheelfine: 33,
          breathcontrollerfine: 34,
          footcontrollerfine: 36,
          portamentotimefine: 37,
          dataentryfine: 38,
          volumefine: 39,
          balancefine: 40,
          panfine: 42,
          expressionfine: 43,
          effectcontrol1fine: 44,
          effectcontrol2fine: 45,
          holdpedal: 64,
          portamento: 65,
          sustenutopedal: 66,
          softpedal: 67,
          legatopedal: 68,
          hold2pedal: 69,
          soundvariation: 70,
          resonance: 71,
          soundreleasetime: 72,
          soundattacktime: 73,
          brightness: 74,
          soundcontrol6: 75,
          soundcontrol7: 76,
          soundcontrol8: 77,
          soundcontrol9: 78,
          soundcontrol10: 79,
          generalpurposebutton1: 80,
          generalpurposebutton2: 81,
          generalpurposebutton3: 82,
          generalpurposebutton4: 83,
          reverblevel: 91,
          tremololevel: 92,
          choruslevel: 93,
          celestelevel: 94,
          phaserlevel: 95,
          databuttonincrement: 96,
          databuttondecrement: 97,
          nonregisteredparametercoarse: 98,
          nonregisteredparameterfine: 99,
          registeredparametercoarse: 100,
          registeredparameterfine: 101
        },
        writable: false,
        enumerable: true,
        configurable: false
      },

      /**
       * [read-only] An object containing properties for MIDI control change messages
       * that make up NRPN messages
       *
       * @property MIDI_NRPN_MESSAGES
       * @type Object
       * @static
       *
       * @since 2.0.0
       */
      MIDI_NRPN_MESSAGES: {
        value: {
          entrymsb: 6,
          entrylsb: 38,
          increment: 96,
          decrement: 97,
          paramlsb: 98,
          parammsb: 99,
          nullactiveparameter: 127
        },
        writable: false,
        enumerable: true,
        configurable: false
      },

      /**
       * [read-only] List of MIDI channel mode messages as defined in the official MIDI
       * specification.
       *
       * @property MIDI_CHANNEL_MODE_MESSAGES
       * @type Object
       * @static
       *
       * @since 2.0.0
       */
      MIDI_CHANNEL_MODE_MESSAGES: {
        value: {
          allsoundoff: 120,
          resetallcontrollers: 121,
          localcontrol: 122,
          allnotesoff: 123,
          omnimodeoff: 124,
          omnimodeon: 125,
          monomodeon: 126,
          polymodeon: 127
        },
        writable: false,
        enumerable: true,
        configurable: false
      },

      /**
       * An integer to offset the octave both in inbound and outbound messages. By default, middle C
       * (MIDI note number 60) is placed on the 4th octave (C4).
       *
       * If, for example, &#x60;octaveOffset&#x60; is set to 2, MIDI note number 60 will be reported as C6. If
       * &#x60;octaveOffset&#x60; is set to -1, MIDI note number 60 will be reported as C3.
       *
       * @property octaveOffset
       * @type Number
       * @static
       *
       * @since 2.1
       */
      octaveOffset: {
        value: 0,
        writable: true,
        enumerable: true,
        configurable: false
      }

    });

    // Define getters/setters
    Object.defineProperties(this, {

      /**
       * [read-only] Indicates whether the environment supports the Web MIDI API or not.
       *
       * Note: in environments that do not offer built-in MIDI support, this will report true if the
       * &#x60;navigator.requestMIDIAccess&#x60; function is available. For example, if you have installed
       * WebMIDIAPIShim but no plugin, this property will be true even though actual support might
       * not be there.
       *
       * @property supported
       * @type Boolean
       * @static
       */
      supported: {
        enumerable: true,
        get: function() {
          return &quot;requestMIDIAccess&quot; in navigator;
        }
      },

      /**
       * [read-only] Indicates whether the interface to the host&quot;s MIDI subsystem is currently
       * enabled.
       *
       * @property enabled
       * @type Boolean
       * @static
       */
      enabled: {
        enumerable: true,
        get: function() {
          return this.interface !== undefined;
        }.bind(this)
      },

      /**
       * [read-only] An array of all currently available MIDI input ports.
       *
       * @property inputs
       * @type {Array}
       * @static
       */
      inputs: {
        enumerable: true,
        get: function() {
          return this._inputs;
        }.bind(this)
      },

      /**
       * [read-only] An array of all currently available MIDI output ports.
       *
       * @property outputs
       * @type {Array}
       * @static
       */
      outputs: {
        enumerable: true,
        get: function() {
          return this._outputs;
        }.bind(this)
      },

      /**
       * [read-only] Indicates whether the interface to the host&quot;s MIDI subsystem is currently
       * active.
       *
       * @property sysexEnabled
       * @type Boolean
       * @static
       */
      sysexEnabled: {
        enumerable: true,
        get: function() {
          return !!(this.interface &amp;&amp; this.interface.sysexEnabled);
        }.bind(this)
      },

      /**
       * [read-only] Indicates whether WebMidi should dispatch Non-Registered
       * Parameter Number events (which are generally groups of CC messages)
       * If correct sequences of CC messages are received, NRPN events will
       * fire. The first out of order NRPN CC will fall through the collector
       * logic and all CC messages buffered will be discarded as incomplete.
       *
       * @property nrpnEventsEnabled
       * @type Boolean
       * @static
       */
      nrpnEventsEnabled: {
        enumerable: true,
        get: function() {
          return !!(this._nrpnEventsEnabled);
        }.bind(this),
        set: function(enabled) {
          this._nrpnEventsEnabled = enabled;
          return this._nrpnEventsEnabled;
        }
      },

      /**
       * [read-only] NRPN message types
       *
       * @property nrpnTypes
       * @type Array
       * @static
       */
      nrpnTypes: {
        enumerable: true,
        get: function() {
          return this._nrpnTypes;
        }.bind(this)
      },

      /**
       * [read-only] Current MIDI performance time in milliseconds. This can be used to queue events
       * in the future.
       *
       * @property time
       * @type DOMHighResTimeStamp
       * @static
       */
      time: {
        enumerable: true,
        get: function() {
          return performance.now();
        }
      }

    });

  }

  // WebMidi is a singleton so we instantiate it ourselves and keep it in a var for internal
  // reference.
  var wm = new WebMidi();

  /**
   * Checks if the Web MIDI API is available and then tries to connect to the host&quot;s MIDI subsystem.
   * This is an asynchronous operation. When it&quot;s done, the specified handler callback will be
   * executed. If an error occurred, the callback function will receive an &#x60;Error&#x60; object as its
   * sole parameter.
   *
   * To enable the use of system exclusive messages, the &#x60;sysex&#x60; parameter should be set to true.
   * However, under some environments (e.g. Jazz-Plugin), the sysex parameter is ignored and sysex
   * is always enabled.
   *
   * @method enable
   * @static
   *
   * @param [callback] {Function} A function to execute upon success. This function will receive an
   * &#x60;Error&#x60; object upon failure to enable the Web MIDI API.
   * @param [sysex=false] {Boolean} Whether to enable MIDI system exclusive messages or not.
   *
   * @throws Error The Web MIDI API is not supported by your browser.
   * @throws Error Jazz-Plugin must be installed to use WebMIDIAPIShim.
   */
  WebMidi.prototype.enable = function(callback, sysex) {

    // Why are you not using a Promise-based API for the enable() method?
    //
    // Short answer: because of IE.
    //
    // Long answer:
    //
    // IE 11 and below still do not support promises. Therefore, WebMIDIAPIShim has to implement a
    // simple Promise look-alike object to handle the call to requestMIDIAccess(). This look-alike
    // is not a fully-fledged Promise object. It does not support using catch() for example. This
    // means that, to provide a real Promise-based interface for the enable() method, we would need
    // to add a dependency in the form of a Promise polyfill. So, to keep things simpler, we will
    // stick to the good old callback based enable() function.

    if (this.enabled) return;

    if ( !this.supported) {

      if (typeof callback === &quot;function&quot;) {
        callback( new Error(&quot;The Web MIDI API is not supported by your browser.&quot;) );
      }

      return;

    }

    navigator.requestMIDIAccess({sysex: sysex}).then(

      function(midiAccess) {

        var events = [],
          promises = [],
          promiseTimeout;

        this.interface = midiAccess;
        this._resetInterfaceUserHandlers();

        // We setup a temporary &#x60;statechange&#x60; handler that will catch all events triggered while we
        // setup. Those events will be re-triggered after calling the user&quot;s callback. This will
        // allow the user to listen to &quot;connected&quot; events which can be very convenient.
        this.interface.onstatechange = function (e) {
          events.push(e);
        };

        // Here we manually open the inputs and outputs. Usually, this is optional. When the ports
        // are not explicitely opened, they will be opened automatically (and asynchonously) by
        // setting a listener on &#x60;midimessage&#x60; (MIDIInput) or calling &#x60;send()&#x60; (MIDIOutput).
        // However, we do not want that here. We want to be sure that &quot;connected&quot; events will be
        // available in the user&quot;s callback. So, what we do is open all input and output ports and
        // wait until all promises are resolved. Then, we re-trigger the events after the user&quot;s
        // callback has been executed. This seems like the most sensible and practical way.
        var inputs = midiAccess.inputs.values();
        for (var input = inputs.next(); input &amp;&amp; !input.done; input = inputs.next()) {
          promises.push(input.value.open());
        }

        var outputs = midiAccess.outputs.values();
        for (var output = outputs.next(); output &amp;&amp; !output.done; output = outputs.next()) {
          promises.push(output.value.open());
        }

        // Since this library might be used in environments without support for promises (such as
        // Jazz-Midi) or in environments that are not properly opening the ports (such as Web MIDI
        // Browser), we fall back to a timer-based approach if the promise-based approach fails.
        function onPortsOpen() {

          clearTimeout(promiseTimeout);

          this._updateInputsAndOutputs();
          this.interface.onstatechange = this._onInterfaceStateChange.bind(this);

          // We execute the callback and then re-trigger the statechange events.
          if (typeof callback === &quot;function&quot;) { callback.call(this); }

          events.forEach(function (event) {
            this._onInterfaceStateChange(event);
          }.bind(this));

        }

        promiseTimeout = setTimeout(onPortsOpen.bind(this), 200);

        if (Promise) {
          Promise
            .all(promises)
            .catch(function(err) { console.warn(err); })
            .then(onPortsOpen.bind(this));
        }

        // When MIDI access is requested, all input and output ports have their &quot;state&quot; set to
        // &quot;connected&quot;. However, the value of their &quot;connection&quot; property is &quot;closed&quot;.
        //
        // A &#x60;MIDIInput&#x60; becomes &#x60;open&#x60; when you explicitely call its &#x60;open()&#x60; method or when you
        // assign a listener to its &#x60;onmidimessage&#x60; property. A &#x60;MIDIOutput&#x60; becomes &#x60;open&#x60; when you
        // use the &#x60;send()&#x60; method or when you can explicitely call its &#x60;open()&#x60; method.
        //
        // Calling &#x60;_updateInputsAndOutputs()&#x60; attaches listeners to all inputs. As per the spec,
        // this triggers a &#x60;statechange&#x60; event on MIDIAccess.

      }.bind(this),

      function (err) {
        if (typeof callback === &quot;function&quot;) { callback.call(this, err); }
      }.bind(this)

    );

  };

  /**
   * Completely disables &#x60;WebMidi&#x60; by unlinking the MIDI subsystem&quot;s interface and destroying all
   * &#x60;Input&#x60; and &#x60;Output&#x60; objects that may be available. This also means that any listener that may
   * have been defined on &#x60;Input&#x60; or &#x60;Output&#x60; objects will be destroyed.
   *
   * @method disable
   * @static
   *
   * @since 2.0.0
   */
  WebMidi.prototype.disable = function() {

    if ( !this.supported ) {
      throw new Error(&quot;The Web MIDI API is not supported by your browser.&quot;);
    }

    if (this.interface) this.interface.onstatechange = undefined;
    this.interface = undefined; // also resets enabled, sysexEnabled, nrpnEventsEnabled
    this._inputs = [];
    this._outputs = [];
    this._nrpnEventsEnabled = true;
    this._resetInterfaceUserHandlers();

  };

  /**
   * Adds an event listener on the &#x60;WebMidi&#x60; object that will trigger a function callback when the
   * specified event happens.
   *
   * WebMidi must be enabled before adding event listeners.
   *
   * Currently, only one event is being dispatched by the &#x60;WebMidi&#x60; object:
   *
   *    * {{#crossLink &quot;WebMidi/statechange:event&quot;}}statechange{{/crossLink}}
   *
   * @method addListener
   * @static
   * @chainable
   *
   * @param type {String} The type of the event.
   *
   * @param listener {Function} A callback function to execute when the specified event is detected.
   * This function will receive an event parameter object. For details on this object&quot;s properties,
   * check out the documentation for the various events (links above).
   *
   * @throws {Error} WebMidi must be enabled before adding event listeners.
   * @throws {TypeError} The specified event type is not supported.
   * @throws {TypeError} The &quot;listener&quot; parameter must be a function.
   *
   * @return {WebMidi} Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  WebMidi.prototype.addListener = function(type, listener) {

    if (!this.enabled) {
      throw new Error(&quot;WebMidi must be enabled before adding event listeners.&quot;);
    }

    if (typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    if (this._midiInterfaceEvents.indexOf(type) &gt;= 0) {
      this._userHandlers[type].push(listener);
    } else {
      throw new TypeError(&quot;The specified event type is not supported.&quot;);
    }

    return this;

  };

  /**
   * Checks if the specified event type is already defined to trigger the specified listener
   * function.
   *
   * @method hasListener
   * @static
   *
   * @param {String} type The type of the event.
   * @param {Function} listener The callback function to check for.
   *
   * @throws {Error} WebMidi must be enabled before checking event listeners.
   * @throws {TypeError} The &quot;listener&quot; parameter must be a function.
   * @throws {TypeError} The specified event type is not supported.
   *
   * @return {Boolean} Boolean value indicating whether or not a callback is already defined for
   * this event type.
   */
  WebMidi.prototype.hasListener = function(type, listener) {

    if (!this.enabled) {
      throw new Error(&quot;WebMidi must be enabled before checking event listeners.&quot;);
    }

    if (typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    if (this._midiInterfaceEvents.indexOf(type) &gt;= 0) {

      for (var o = 0; o &lt; this._userHandlers[type].length; o++) {
        if (this._userHandlers[type][o] === listener) {
          return true;
        }
      }

    } else {
      throw new TypeError(&quot;The specified event type is not supported.&quot;);
    }

    return false;

  };

  /**
   * Removes the specified listener(s). If the &#x60;listener&#x60; parameter is left undefined, all listeners
   * for the specified &#x60;type&#x60; will be removed. If both the &#x60;listener&#x60; and the &#x60;type&#x60; parameters are
   * omitted, all listeners attached to the &#x60;WebMidi&#x60; object will be removed.
   *
   * @method removeListener
   * @static
   * @chainable
   *
   * @param {String} [type] The type of the event.
   * @param {Function} [listener] The callback function to check for.
   *
   * @throws {Error} WebMidi must be enabled before removing event listeners.
   * @throws {TypeError} The &quot;listener&quot; parameter must be a function.
   * @throws {TypeError} The specified event type is not supported.
   *
   * @return {WebMidi} The &#x60;WebMidi&#x60; object for easy method chaining.
   */
  WebMidi.prototype.removeListener = function(type, listener) {

    if (!this.enabled) {
      throw new Error(&quot;WebMidi must be enabled before removing event listeners.&quot;);
    }

    if (listener !== undefined &amp;&amp; typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    if (this._midiInterfaceEvents.indexOf(type) &gt;= 0) {

      if (listener) {

        for (var o = 0; o &lt; this._userHandlers[type].length; o++) {
          if (this._userHandlers[type][o] === listener) {
            this._userHandlers[type].splice(o, 1);
          }
        }

      } else {
        this._userHandlers[type] = [];
      }

    } else if (type === undefined) {

      this._resetInterfaceUserHandlers();

    } else {
      throw new TypeError(&quot;The specified event type is not supported.&quot;);
    }

    return this;

  };

  /**
   * Returns a sanitized array of valid MIDI channel numbers (1-16). The parameter should be one of
   * the following:
   *
   * * a single integer
   * * an array of integers
   * * the special value &#x60;&quot;all&quot;&#x60;
   * * the special value &#x60;&quot;none&quot;&#x60;
   *
   * Passing &#x60;&quot;all&quot;&#x60; or &#x60;undefined&#x60; as a parameter to this function results in all channels being
   * returned (1-16). Passing &#x60;&quot;none&quot;&#x60; results in no channel being returned (as an empty array).
   *
   * Note: parameters that cannot successfully be parsed to integers between 1 and 16 are silently
   * ignored.
   *
   * @method toMIDIChannels
   * @static
   *
   * @param [channel=&quot;all&quot;] {Number|Array|&quot;all&quot;|&quot;none&quot;}
   * @returns {Array} An array of 0 or more valid MIDI channel numbers
   */
  WebMidi.prototype.toMIDIChannels = function(channel) {

    var channels;

    if (channel === &quot;all&quot; || channel === undefined) {
      channels = [&quot;all&quot;];
    } else if (channel === &quot;none&quot;) {
      channels = [];
      return channels;
    } else if (!Array.isArray(channel)) {
      channels = [channel];
    } else {
      channels = channel;
    }

    // In order to preserve backwards-compatibility, we let this assignment as it is.
    if (channels.indexOf(&quot;all&quot;) &gt; -1) {
      channels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
    }

    return channels
      .map(function(ch) {
        return parseInt(ch);
      })
      .filter(function(ch) {
        return (ch &gt;= 1 &amp;&amp; ch &lt;= 16);
      });

  };

  /**
   *
   * Returns the &#x60;Input&#x60; object that matches the specified ID string or &#x60;false&#x60; if no matching input
   * is found. As per the Web MIDI API specification, IDs are strings (not integers).
   *
   * Please note that IDs change from one host to another. For example, Chrome does not use the same
   * kind of IDs as Jazz-Plugin.
   *
   * @method getInputById
   * @static
   *
   * @param id {String} The ID string of the port. IDs can be viewed by looking at the
   * &#x60;WebMidi.inputs&#x60; array.
   *
   * @returns {Input|false} A MIDIInput port matching the specified ID string. If no matching port
   * can be found, the method returns &#x60;false&#x60;.
   *
   * @throws Error WebMidi is not enabled.
   *
   * @since 2.0.0
   */
  WebMidi.prototype.getInputById = function(id) {

    if (!this.enabled) throw new Error(&quot;WebMidi is not enabled.&quot;);

    id = String(id);

    for (var i = 0; i &lt; this.inputs.length; i++) {
      if (this.inputs[i].id === id) return this.inputs[i];
    }

    return false;

  };

  /**
   * Returns the &#x60;Output&#x60; object that matches the specified ID string or &#x60;false&#x60; if no matching
   * output is found. As per the Web MIDI API specification, IDs are strings (not integers).
   *
   * Please note that IDs change from one host to another. For example, Chrome does not use the same
   * kind of IDs as Jazz-Plugin.
   *
   * @method getOutputById
   * @static
   *
   * @param id {String} The ID string of the port. IDs can be viewed by looking at the
   * &#x60;WebMidi.outputs&#x60; array.
   *
   * @returns {Output|false} A MIDIOutput port matching the specified ID string. If no matching port
   * can be found, the method returns &#x60;false&#x60;.
   *
   * @throws Error WebMidi is not enabled.
   *
   * @since 2.0.0
   */
  WebMidi.prototype.getOutputById = function(id) {

    if (!this.enabled) throw new Error(&quot;WebMidi is not enabled.&quot;);

    id = String(id);

    for (var i = 0; i &lt; this.outputs.length; i++) {
      if (this.outputs[i].id === id) return this.outputs[i];
    }

    return false;

  };

  /**
   * Returns the first MIDI &#x60;Input&#x60; whose name *contains* the specified string.
   *
   * Please note that the port names change from one host to another. For example, Chrome does
   * not report port names in the same way as the Jazz-Plugin does.
   *
   * @method getInputByName
   * @static
   *
   * @param name {String} The name of a MIDI input port such as those visible in the
   * &#x60;WebMidi.inputs&#x60; array.
   *
   * @returns {Input|False} The &#x60;Input&#x60; that was found or &#x60;false&#x60; if no input matched the specified
   * name.
   *
   * @throws Error WebMidi is not enabled.
   * @throws TypeError The name must be a string.
   *
   * @since 2.0.0
   */
  WebMidi.prototype.getInputByName = function(name) {

    if (!this.enabled) {
      throw new Error(&quot;WebMidi is not enabled.&quot;);
    }

    for (var i = 0; i &lt; this.inputs.length; i++) {
      if (~this.inputs[i].name.indexOf(name)) { return this.inputs[i]; }
    }

    return false;

  };

  /**
   * Returns the octave number for the specified MIDI note number (0-127). By default, the value is
   * based on middle C (note number 60) being placed on the 4th octave (C4). However, by using the
   * &lt;a href=&quot;#property_octaveOffset&quot;&gt;octaveOffset&lt;/a&gt; property, you can offset the result as much
   * as you want.
   *
   * @method getOctave
   * @static
   *
   * @param number {Number} An integer representing a valid MIDI note number (between 0 and 127).
   *
   * @returns {Number} The octave (as a signed integer) or &#x60;undefined&#x60;.
   *
   * @since 2.0.0-rc.6
   */
  WebMidi.prototype.getOctave = function(number) {

    if (number != null &amp;&amp; number &gt;= 0 &amp;&amp; number &lt;= 127) {
      return Math.floor(Math.floor(number) / 12 - 1) + Math.floor(wm.octaveOffset);
    }

  };

  /**
   * Returns the first MIDI &#x60;Output&#x60; that matches the specified name.
   *
   * Please note that the port names change from one host to another. For example, Chrome does
   * not report port names in the same way as the Jazz-Plugin does.
   *
   * @method getOutputByName
   * @static
   *
   * @param name {String} The name of a MIDI output port such as those visible in the
   * &#x60;WebMidi.outputs&#x60; array.
   *
   * @returns {Output|False} The &#x60;Output&#x60; that was found or &#x60;false&#x60; if no output matched the
   * specified name.
   *
   * @throws Error WebMidi is not enabled.
   *
   * @since 2.0.0
   */
  WebMidi.prototype.getOutputByName = function(name) {

    if (!this.enabled) {
      throw new Error(&quot;WebMidi is not enabled.&quot;);
    }

    for (var i = 0; i &lt; this.outputs.length; i++) {
      if (~this.outputs[i].name.indexOf(name)) { return this.outputs[i]; }
    }

    return false;

  };

  /**
   * Returns a valid MIDI note number (0-127) given the specified input. The input usually is a note
   * name (C3, F#4, D-2, G8, etc.). If an integer between 0 and 127, it will simply be returned as
   * is.
   *
   * @method guessNoteNumber
   * @static
   *
   * @param input {Number|String} A string to extract the note number from. An integer can also be
   * used, in which case it will simply be returned (if between 0 and 127).
   * @throws {Error} Invalid input value
   * @returns {Number} A valid MIDI note number (0-127).
   */
  WebMidi.prototype.guessNoteNumber = function(input) {

    var output = false;

    if (input &amp;&amp; input.toFixed &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 127) {         // uint
      output = Math.round(input);
    } else if (parseInt(input) &gt;= 0 &amp;&amp; parseInt(input) &lt;= 127) {        // uint as string
      output = parseInt(input);
    } else if (typeof input === &quot;string&quot; || input instanceof String) {  // string
      output = this.noteNameToNumber(input);
    }

    if (output === false) throw new Error(&quot;Invalid input value (&quot; + input + &quot;).&quot;);
    return output;

  };

  /**
   * Returns a MIDI note number matching the note name passed in the form of a string parameter. The
   * note name must include the octave number. The name can also optionally include a sharp (#),
   * a double sharp (##), a flat (b) or a double flat (bb) symbol: C5, G4, D#-1, F0, Gb7, Eb-1,
   * Abb4, B##6, etc.
   *
   * Note that, in converting note names to numbers, C4 is considered to be middle C (MIDI note
   * number 60) as per the scientific pitch notation standard.
   *
   * Also note that the resulting note number is offset by the &#x60;octaveOffset&#x60; value (if not zero).
   * For example, if you pass in &quot;C4&quot; and the &#x60;octaveOffset&#x60; value is 2 the resulting MIDI note
   * number will be 36.
   *
   * @method noteNameToNumber
   * @static
   *
   * @param name {String} The name of the note in the form of a letter, followed by an optional &quot;#&quot;,
   * &quot;##&quot;, &quot;b&quot; or &quot;bb&quot; followed by the octave number.
   *
   * @throws {RangeError} Invalid note name.
   * @throws {RangeError} Invalid note name or note outside valid range.
   * @return {Number} The MIDI note number (between 0 and 127)
   */
  WebMidi.prototype.noteNameToNumber = function(name) {

    if (typeof name !== &quot;string&quot;) name = &quot;&quot;;

    var matches = name.match(/([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)/i);
    if(!matches) throw new RangeError(&quot;Invalid note name.&quot;);

    var semitones = wm._semitones[matches[1].toUpperCase()];
    var octave = parseInt(matches[3]);
    var result = ((octave + 1 - Math.floor(wm.octaveOffset)) * 12) + semitones;


    if (matches[2].toLowerCase().indexOf(&quot;b&quot;) &gt; -1) {
      result -= matches[2].length;
    } else if (matches[2].toLowerCase().indexOf(&quot;#&quot;) &gt; -1) {
      result += matches[2].length;
    }

    if (result &lt; 0 || result &gt; 127) {
      throw new RangeError(&quot;Invalid note name or note outside valid range.&quot;);
    }

    return result;

  };

  /**
   * @method _updateInputsAndOutputs
   * @static
   * @protected
   */
  WebMidi.prototype._updateInputsAndOutputs = function() {
    this._updateInputs();
    this._updateOutputs();
  };

  /**
   * @method _updateInputs
   * @static
   * @protected
   */
  WebMidi.prototype._updateInputs = function() {

    // Check for items to remove from the existing array (because they are no longer being reported
    // by the MIDI back-end).
    for (var i = 0; i &lt; this._inputs.length; i++) {

      var remove = true;

      var updated = this.interface.inputs.values();
      for (var input = updated.next(); input &amp;&amp; !input.done; input = updated.next()) {
        if (this._inputs[i]._midiInput === input.value) {
          remove = false;
          break;
        }
      }

      if (remove) {
        this._inputs.splice(i, 1);
      }

    }

    // Check for items to add in the existing inputs array because they just appeared in the MIDI
    // back-end inputs list. We must check for the existence of this.interface because it might
    // have been closed via WebMidi.disable().
    this.interface &amp;&amp; this.interface.inputs.forEach(function (nInput) {

      var add = true;

      for (var j = 0; j &lt; this._inputs.length; j++) {
        if (this._inputs[j]._midiInput === nInput) {
          add = false;
        }
      }

      if (add) {
        this._inputs.push( new Input(nInput) );
      }

    }.bind(this));

  };

  /**
   * @method _updateOutputs
   * @static
   * @protected
   */
  WebMidi.prototype._updateOutputs = function() {

    // Check for items to remove from the existing array (because they are no longer being reported
    // by the MIDI back-end).
    for (var i = 0; i &lt; this._outputs.length; i++) {

      var remove = true;

      var updated = this.interface.outputs.values();
      for (var output = updated.next(); output &amp;&amp; !output.done; output = updated.next()) {
        if (this._outputs[i]._midiOutput === output.value) {
          remove = false;
          break;
        }
      }

      if (remove) {
        this._outputs.splice(i, 1);
      }

    }

    // Check for items to add in the existing inputs array because they just appeared in the MIDI
    // back-end outputs list. We must check for the existence of this.interface because it might
    // have been closed via WebMidi.disable().
    this.interface &amp;&amp; this.interface.outputs.forEach(function (nOutput) {

      var add = true;

      for (var j = 0; j &lt; this._outputs.length; j++) {
        if (this._outputs[j]._midiOutput === nOutput) {
          add = false;
        }
      }

      if (add) {
        this._outputs.push( new Output(nOutput) );
      }

    }.bind(this));

  };

  /**
   * @method _onInterfaceStateChange
   * @static
   * @protected
   */
  WebMidi.prototype._onInterfaceStateChange = function(e) {

    this._updateInputsAndOutputs();

    /**
     * Event emitted when a MIDI port becomes available. This event is typically fired whenever a
     * MIDI device is plugged in. Please note that it may fire several times if a device possesses
     * multiple input/output ports.
     *
     * @event connected
     * @param {Object} event
     * @param {Number} event.timestamp The timestamp when the event occurred (in milliseconds since
     * the epoch).
     * @param {String} event.type The type of event that occurred.
     * @param {String} event.port The actual &#x60;Input&#x60; or &#x60;Output&#x60; object associated to the event.
     */

    /**
     * Event emitted when a MIDI port becomes unavailable. This event is typically fired whenever a
     * MIDI device is unplugged. Please note that it may fire several times if a device possesses
     * multiple input/output ports.
     *
     * @event disconnected
     * @param {Object} event
     * @param {Number} event.timestamp The timestamp when the event occurred (in milliseconds since
     * the epoch).
     * @param {String} event.type The type of event that occurred.
     * @param {String} event.port An generic object containing details about the port that triggered
     * the event.
     */
    var event = {
      timestamp: e.timeStamp,
      type: e.port.state
    };

    if (this.interface &amp;&amp; e.port.state === &quot;connected&quot;) {

      if (e.port.type === &quot;output&quot;) {
        event.port = this.getOutputById(e.port.id);
      } else if (e.port.type === &quot;input&quot;) {
        event.port = this.getInputById(e.port.id);
      }

    } else {

      event.port = {
        connection: &quot;closed&quot;,
        id: e.port.id,
        manufacturer: e.port.manufacturer,
        name: e.port.name,
        state: e.port.state,
        type: e.port.type
      };

    }

    this._userHandlers[e.port.state].forEach(function (handler) {
      handler(event);
    });

  };

  /**
   * @method _resetInterfaceUserHandlers
   * @static
   * @protected
   */
  WebMidi.prototype._resetInterfaceUserHandlers = function() {

    for (var i = 0; i &lt; this._midiInterfaceEvents.length; i++) {
      this._userHandlers[this._midiInterfaceEvents[i]] = [];
    }

  };

  /**
   * The &#x60;Input&#x60; object represents a MIDI input port on the host system. This object is created by
   * the MIDI subsystem and cannot be instantiated directly.
   *
   * You will find all available &#x60;Input&#x60; objects in the &#x60;WebMidi.inputs&#x60; array.
   *
   * @class Input
   * @param {MIDIInput} midiInput &#x60;MIDIInput&#x60; object
   */
  function Input(midiInput) {

    var that = this;

    // User-defined handlers list
    this._userHandlers = { channel: {}, system: {} };

    // Reference to the actual MIDIInput object
    this._midiInput = midiInput;

    Object.defineProperties(this, {

      /**
       * [read-only] Status of the MIDI port&quot;s connection (&#x60;pending&#x60;, &#x60;open&#x60; or &#x60;closed&#x60;)
       *
       * @property connection
       * @type String
       */
      connection: {
        enumerable: true,
        get: function () {
          return that._midiInput.connection;
        }
      },

      /**
       * [read-only] ID string of the MIDI port. The ID is host-specific. Do not expect the same ID
       * on different platforms. For example, Google Chrome and the Jazz-Plugin report completely
       * different IDs for the same port.
       *
       * @property id
       * @type String
       */
      id: {
        enumerable: true,
        get: function () {
          return that._midiInput.id;
        }
      },

      /**
       * [read-only] Name of the manufacturer of the device that makes this port available.
       *
       * @property manufacturer
       * @type String
       */
      manufacturer: {
        enumerable: true,
        get: function () {
          return that._midiInput.manufacturer;
        }
      },

      /**
       * [read-only] Name of the MIDI port
       *
       * @property name
       * @type String
       */
      name: {
        enumerable: true,
        get: function () {
          return that._midiInput.name;
        }
      },

      /**
       * [read-only] State of the MIDI port (&#x60;connected&#x60; or &#x60;disconnected&#x60;)
       *
       * @property state
       * @type String
       */
      state: {
        enumerable: true,
        get: function () {
          return that._midiInput.state;
        }
      },

      /**
       * [read-only] Type of the MIDI port (&#x60;input&#x60;)
       *
       * @property type
       * @type String
       */
      type: {
        enumerable: true,
        get: function () {
          return that._midiInput.type;
        }
      }

    });

    this._initializeUserHandlers();
    this._midiInput.onmidimessage = this._onMidiMessage.bind(this);

  }

  /**
   * Adds an event listener to the &#x60;Input&#x60; that will trigger a function callback when the specified
   * event happens. The events that are dispatched can be channel-specific or Input-wide.
   *
   * Here is a list of events that are dispatched by &#x60;Input&#x60; objects and that can be listened to.
   *
   * Channel-specific MIDI events:
   *
   *    * {{#crossLink &quot;Input/noteoff:event&quot;}}noteoff{{/crossLink}}
   *    * {{#crossLink &quot;Input/noteon:event&quot;}}noteon{{/crossLink}}
   *    * {{#crossLink &quot;Input/keyaftertouch:event&quot;}}keyaftertouch{{/crossLink}}
   *    * {{#crossLink &quot;Input/controlchange:event&quot;}}controlchange{{/crossLink}}
   *    * {{#crossLink &quot;Input/nrpn:event&quot;}}pitchbend{{/crossLink}}
   *    * {{#crossLink &quot;Input/channelmode:event&quot;}}channelmode{{/crossLink}}
   *    * {{#crossLink &quot;Input/programchange:event&quot;}}programchange{{/crossLink}}
   *    * {{#crossLink &quot;Input/channelaftertouch:event&quot;}}channelaftertouch{{/crossLink}}
   *    * {{#crossLink &quot;Input/pitchbend:event&quot;}}pitchbend{{/crossLink}}
   *
   * Input-wide MIDI events:
   *
   *    * {{#crossLink &quot;Input/sysex:event&quot;}}sysex{{/crossLink}}
   *    * {{#crossLink &quot;Input/timecode:event&quot;}}timecode{{/crossLink}}
   *    * {{#crossLink &quot;Input/songposition:event&quot;}}songposition{{/crossLink}}
   *    * {{#crossLink &quot;Input/songselect:event&quot;}}songselect{{/crossLink}}
   *    * {{#crossLink &quot;Input/tuningrequest:event&quot;}}tuningrequest{{/crossLink}}
   *    * {{#crossLink &quot;Input/clock:event&quot;}}clock{{/crossLink}}
   *    * {{#crossLink &quot;Input/start:event&quot;}}start{{/crossLink}}
   *    * {{#crossLink &quot;Input/continue:event&quot;}}continue{{/crossLink}}
   *    * {{#crossLink &quot;Input/stop:event&quot;}}stop{{/crossLink}}
   *    * {{#crossLink &quot;Input/activesensing:event&quot;}}activesensing{{/crossLink}}
   *    * {{#crossLink &quot;Input/reset:event&quot;}}reset{{/crossLink}}
   *    * {{#crossLink &quot;Input/midimessage:event&quot;}}midimessage{{/crossLink}}
   *    * {{#crossLink &quot;Input/unknownsystemmessage:event&quot;}}unknownsystemmessage{{/crossLink}}
   *
   * For device-wide events, the &#x60;channel&#x60; parameter will be silently ignored. You can simply use
   * &#x60;undefined&#x60; in that case.
   *
   * If you want to view all incoming MIDI traffic, you can listen to the input-wide &#x60;midimessage&#x60;
   * event. This event is dispatched for every single message that is received on that input.
   *
   * @method addListener
   * @chainable
   *
   * @param type {String} The type of the event.
   *
   * @param channel {Number|Array|String} The MIDI channel to listen on (integer between 1 and 16).
   * You can also specify an array of channel numbers or the value &quot;all&quot; (or leave it undefined for
   * input-wide events).
   *
   * @param listener {Function} A callback function to execute when the specified event is detected.
   * This function will receive an event parameter object. For details on this object&quot;s properties,
   * check out the documentation for the various events (links above).
   *
   * @throws {RangeError} The &quot;channel&quot; parameter is invalid.
   * @throws {TypeError} The &quot;listener&quot; parameter must be a function.
   * @throws {TypeError} The specified event type is not supported.
   *
   * @return {WebMidi} Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  Input.prototype.addListener = function(type, channel, listener) {

    var that = this;

    if (channel === undefined) { channel = &quot;all&quot;; }
    if (!Array.isArray(channel)) { channel = [channel]; }

    // Check if channel entries are valid
    channel.forEach(function(item){
      if (item !== &quot;all&quot; &amp;&amp; !(item &gt;= 1 &amp;&amp; item &lt;= 16)) {
        throw new RangeError(
          &quot;The &#x27;channel&#x27; parameter is invalid.&quot;
        );
      }
    });

    if (typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    if (wm.MIDI_SYSTEM_MESSAGES[type] !== undefined) {

      if (!this._userHandlers.system[type]) this._userHandlers.system[type] = [];
      this._userHandlers.system[type].push(listener);

    } else if (wm.MIDI_CHANNEL_MESSAGES[type] !== undefined) {

      // If &quot;all&quot; is present anywhere in the channel array, use all 16 channels
      if (channel.indexOf(&quot;all&quot;) &gt; -1) {
        channel = [];
        for (var j = 1; j &lt;= 16; j++) { channel.push(j); }
      }

      if (!this._userHandlers.channel[type]) { this._userHandlers.channel[type] = []; }

      // Push all channel listeners in the array
      channel.forEach(function(ch){

        if (!that._userHandlers.channel[type][ch]) {
          that._userHandlers.channel[type][ch] = [];
        }

        that._userHandlers.channel[type][ch].push(listener);

      });

    } else {
      throw new TypeError(&quot;The specified event type is not supported.&quot;);
    }

    return this;

  };

  /**
   * This is an alias to the {{#crossLink &quot;Input/addListener&quot;}}Input.addListener(){{/crossLink}}
   * function.
   *
   * @method on
   * @since 2.0.0
   */
  Input.prototype.on = Input.prototype.addListener;

  /**
   * Checks if the specified event type is already defined to trigger the listener function on the
   * specified channel(s). If more than one channel is specified, the function will return &#x60;true&#x60;
   * only if all channels have the listener defined.
   *
   * For device-wide events (&#x60;sysex&#x60;, &#x60;start&#x60;, etc.), the &#x60;channel&#x60; parameter is silently ignored.
   * We suggest you use &#x60;undefined&#x60; in such cases.
   *
   * @method hasListener
   *
   * @param type {String} The type of the event.
   * @param channel {Number|Array|String} The MIDI channel to check on (between 1 and 16). You
   * can also specify an array of channel numbers or the string &quot;all&quot;.
   * @param listener {Function} The callback function to check for.
   *
   * @throws {TypeError} The &quot;listener&quot; parameter must be a function.
   *
   * @return {Boolean} Boolean value indicating whether or not the channel(s) already have this
   * listener defined.
   */
  Input.prototype.hasListener = function(type, channel, listener) {

    var that = this;

    if (typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    if (channel === undefined) { channel = &quot;all&quot;; }
    if (channel.constructor !== Array) { channel = [channel]; }

    if (wm.MIDI_SYSTEM_MESSAGES[type] !== undefined) {

      for (var o = 0; o &lt; this._userHandlers.system[type].length; o++) {
        if (this._userHandlers.system[type][o] === listener) { return true; }
      }

    } else if (wm.MIDI_CHANNEL_MESSAGES[type] !== undefined) {

      // If &quot;all&quot; is present anywhere in the channel array, use all 16 channels
      if (channel.indexOf(&quot;all&quot;) &gt; -1) {
        channel = [];
        for (var j = 1; j &lt;= 16; j++) { channel.push(j); }
      }

      if (!this._userHandlers.channel[type]) { return false; }

      // Go through all specified channels
      return channel.every(function(chNum) {
        var listeners = that._userHandlers.channel[type][chNum];
        return listeners &amp;&amp; listeners.indexOf(listener) &gt; -1;
      });

    }

    return false;

  };

  /**
   * Removes the specified listener from the specified channel(s). If the &#x60;listener&#x60; parameter is
   * left undefined, all listeners for the specified &#x60;type&#x60; will be removed from all channels. If
   * the &#x60;channel&#x60; is also omitted, all listeners of the specified type will be removed from all
   * channels. If no parameters are defined, all listeners attached to any channel of the &#x60;Input&#x60;
   * will be removed.
   *
   * For device-wide events (&#x60;sysex&#x60;, &#x60;start&#x60;, etc.), the &#x60;channel&#x60; parameter is silently ignored.
   * You can use &#x60;undefined&#x60; in such cases.
   *
   * @method removeListener
   * @chainable
   *
   * @param [type] {String} The type of the event.
   * @param [channel] {Number|String|Array} The MIDI channel(s) to check on. It can be a uint
   * (between 1 and 16) an array of channel numbers or the special value &quot;all&quot;.
   * @param [listener] {Function} The callback function to check for.
   *
   * @throws {TypeError} The specified event type is not supported.
   * @throws {TypeError} The &quot;listener&quot; parameter must be a function..
   *
   * @return {Input} The &#x60;Input&#x60; object for easy method chaining.
   */
  Input.prototype.removeListener = function(type, channel, listener) {

    var that = this;

    if (listener !== undefined &amp;&amp; typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    if (channel === undefined) { channel = &quot;all&quot;; }
    if (channel.constructor !== Array) { channel = [channel]; }

    if (wm.MIDI_SYSTEM_MESSAGES[type] !== undefined) {

      if (listener === undefined) {

        this._userHandlers.system[type] = [];

      } else {

        for (var o = 0; o &lt; this._userHandlers.system[type].length; o++) {
          if (this._userHandlers.system[type][o] === listener) {
            this._userHandlers.system[type].splice(o, 1);
          }
        }

      }

    } else if (wm.MIDI_CHANNEL_MESSAGES[type] !== undefined) {

      // If &quot;all&quot; is present anywhere in the channel array, use all 16 channels
      if (channel.indexOf(&quot;all&quot;) &gt; -1) {
        channel = [];
        for (var j = 1; j &lt;= 16; j++) { channel.push(j); }
      }

      if (!this._userHandlers.channel[type]) { return this; }

      // Go through all specified channels
      channel.forEach(function(chNum) {
        var listeners = that._userHandlers.channel[type][chNum];
        if (!listeners) { return; }

        if (listener === undefined) {
          that._userHandlers.channel[type][chNum] = [];
        } else {
          for (var l = 0; l &lt; listeners.length; l++) {
            if (listeners[l] === listener) { listeners.splice(l, 1); }
          }
        }

      });

    } else if (type === undefined) {
      this._initializeUserHandlers();
    } else {
      throw new TypeError(&quot;The specified event type is not supported.&quot;);
    }

    return this;

  };

  /**
   * @method _initializeUserHandlers
   * @protected
   */
  Input.prototype._initializeUserHandlers = function() {

    for (var prop1 in wm.MIDI_CHANNEL_MESSAGES) {
      if (wm.MIDI_CHANNEL_MESSAGES.hasOwnProperty(prop1)) {
        this._userHandlers.channel[prop1] = {};
      }
    }

    for (var prop2 in wm.MIDI_SYSTEM_MESSAGES) {
      if (wm.MIDI_SYSTEM_MESSAGES.hasOwnProperty(prop2)) {
        this._userHandlers.system[prop2] = [];
      }
    }

  };

  /**
   * @method _onMidiMessage
   * @protected
   */
  Input.prototype._onMidiMessage = function(e) {

    // Execute &quot;midimessage&quot; listeners (if any)
    if (this._userHandlers.system[&quot;midimessage&quot;].length &gt; 0) {

      var event = {
        target: this,
        data: e.data,
        timestamp: e.timeStamp,
        type: &quot;midimessage&quot;
      };

      /**
       * Event emitted when a MIDI message is received. This should be used primarily for debugging
       * purposes.
       *
       * @event midimessage
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {uint} event.timestamp The timestamp when the event occurred (in milliseconds since
       * the [Unix Epoch](https://en.wikipedia.org/wiki/Unix_time)).
       * @param {String} event.type The type of event that occurred.
       * @since 2.1
       */
      this._userHandlers.system[&quot;midimessage&quot;].forEach(
        function(callback) { callback(event); }
      );

    }

    if (e.data[0] &lt; 240) {          // channel-specific message
      this._parseChannelEvent(e);
      this._parseNrpnEvent(e);
    } else if (e.data[0] &lt;= 255) {  // system message
      this._parseSystemEvent(e);
    }

  };

  /**
   * Parses channel events and constructs NRPN message parts in valid sequences.
   * Keeps a separate NRPN buffer for each channel.
   * Emits an event after it receives the final CC parts msb 127 lsb 127.
   * If a message is incomplete and other messages are received before
   * the final 127 bytes, the incomplete message is cleared.
   * @method _parseNrpnEvent
   * @param e Event
   * @protected
   */
  Input.prototype._parseNrpnEvent = function(e) {

    var command = e.data[0] &gt;&gt; 4;
    var channelBufferIndex = (e.data[0] &amp; 0xf); // use this for index of channel in _nrpnBuffer
    var channel = channelBufferIndex + 1;
    var data1, data2;

    if (e.data.length &gt; 1) {
      data1 = e.data[1];
      data2 = e.data.length &gt; 2 ? e.data[2] : undefined;
    }

    // nrpn disabled
    if(!wm.nrpnEventsEnabled) {
      return;
    }
    
    // nrpn enabled, message not valid for nrpn
    if(
      !(
        command === wm.MIDI_CHANNEL_MESSAGES.controlchange &amp;&amp;
        (
          (data1 &gt;= wm.MIDI_NRPN_MESSAGES.increment &amp;&amp; data1 &lt;= wm.MIDI_NRPN_MESSAGES.parammsb) ||
          data1 === wm.MIDI_NRPN_MESSAGES.entrymsb ||
          data1 === wm.MIDI_NRPN_MESSAGES.entrylsb
        )
      )
    ) {
      return;
    }

    // set up a CC event to parse as NRPN part
    var ccEvent = {
      target: this,
      type: &quot;controlchange&quot;,
      data: e.data,
      timestamp: e.timeStamp,
      channel: channel,
      controller: {
        number: data1,
        name: this.getCcNameByNumber(data1)
      },
      value: data2
    };
    if(
      // if we get a starting MSB(CC99 - 0-126) vs an end MSB(CC99 - 127)
      // destroy inclomplete NRPN and begin building again
      ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.parammsb &amp;&amp;
      ccEvent.value != wm.MIDI_NRPN_MESSAGES.nullactiveparameter
    ) {
      wm._nrpnBuffer[channelBufferIndex] = [];
      wm._nrpnBuffer[channelBufferIndex][0] = ccEvent;
    } else if(
      // add the param LSB
      wm._nrpnBuffer[channelBufferIndex].length === 1 &amp;&amp;
        ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.paramlsb
    ) {
      wm._nrpnBuffer[channelBufferIndex].push(ccEvent);

    } else if(
      // add data inc/dec or value MSB for 14bit
      wm._nrpnBuffer[channelBufferIndex].length === 2 &amp;&amp;
        (ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.increment ||
         ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.decrement ||
         ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.entrymsb)
    ) {
      wm._nrpnBuffer[channelBufferIndex].push(ccEvent);

    } else if(
      // if we have a value MSB, only add an LSB to pair with that
      wm._nrpnBuffer[channelBufferIndex].length === 3 &amp;&amp;
        wm._nrpnBuffer[channelBufferIndex][2].number === wm.MIDI_NRPN_MESSAGES.entrymsb &amp;&amp;
        ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.entrylsb
    ) {
      wm._nrpnBuffer[channelBufferIndex].push(ccEvent);

    } else if(
      // add an end MSB(CC99 - 127)
      wm._nrpnBuffer[channelBufferIndex].length &gt;= 3 &amp;&amp;
      wm._nrpnBuffer[channelBufferIndex].length &lt;= 4 &amp;&amp;
        ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.parammsb &amp;&amp;
        ccEvent.value === wm.MIDI_NRPN_MESSAGES.nullactiveparameter
    ) {
      wm._nrpnBuffer[channelBufferIndex].push(ccEvent);

    } else if(
      // add an end LSB(CC99 - 127)
      wm._nrpnBuffer[channelBufferIndex].length &gt;= 4 &amp;&amp;
      wm._nrpnBuffer[channelBufferIndex].length &lt;= 5 &amp;&amp;
        ccEvent.controller.number === wm.MIDI_NRPN_MESSAGES.paramlsb &amp;&amp;
        ccEvent.value === wm.MIDI_NRPN_MESSAGES.nullactiveparameter
    ) {
      wm._nrpnBuffer[channelBufferIndex].push(ccEvent);
      // now we have a full inc or dec NRPN message, lets create that event!

      var rawData = [];

      wm._nrpnBuffer[channelBufferIndex].forEach(function(ev) {
        rawData.push(ev.data);
      });

      var nrpnNumber = (wm._nrpnBuffer[channelBufferIndex][0].value&lt;&lt;7) |
        (wm._nrpnBuffer[channelBufferIndex][1].value);
      var nrpnValue = wm._nrpnBuffer[channelBufferIndex][2].value;
      if(wm._nrpnBuffer[channelBufferIndex].length === 6) {
        nrpnValue = (wm._nrpnBuffer[channelBufferIndex][2].value&lt;&lt;7) |
          (wm._nrpnBuffer[channelBufferIndex][3].value);
      }
      var nrpnControllerType = &quot;&quot;;
      switch (wm._nrpnBuffer[channelBufferIndex][2].controller.number) {
      case wm.MIDI_NRPN_MESSAGES.entrymsb:
        nrpnControllerType = wm._nrpnTypes[0];
        break;
      case wm.MIDI_NRPN_MESSAGES.increment:
        nrpnControllerType = wm._nrpnTypes[1];
        break;
      case wm.MIDI_NRPN_MESSAGES.decrement:
        nrpnControllerType = wm._nrpnTypes[2];
        break;
      default:
        throw new Error(&quot;The NPRN type was unidentifiable.&quot;);
      }

      /**
       * Event emitted when a valid NRPN message sequence has been received on a specific device and
       * channel.
       *
       * @event nrpn
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Array} event.data The raw MIDI message as arrays of 8 bit values( Uint8Array ).
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Object} event.controller
       * @param {uint} event.controller.number The number of the NRPN.
       * @param {String} event.controller.name The usual name or function of the controller.
       * @param {uint} event.value The value received (between 0 and 65535).
       */

      var nrpnEvent = {
        timestamp: ccEvent.timestamp,
        channel: ccEvent.channel,
        type: &quot;nrpn&quot;,
        data: rawData,
        controller: {
          number: nrpnNumber,
          type: nrpnControllerType,
          name: &quot;Non-Registered Parameter &quot; + nrpnNumber
        },
        value: nrpnValue
      };
      
      // now we are done building an NRPN, so clear the NRPN buffer for this channel
      wm._nrpnBuffer[channelBufferIndex] = [];
      // If some callbacks have been defined for this event, on that device and channel, execute
      // them.
      if (
        this._userHandlers.channel[nrpnEvent.type] &amp;&amp;
        this._userHandlers.channel[nrpnEvent.type][nrpnEvent.channel]
      ) {
        this._userHandlers.channel[nrpnEvent.type][nrpnEvent.channel].forEach(
          function(callback) { callback(nrpnEvent); }
        );
      }
    } else {
      // something didn&#x27;t match, clear the incomplete NRPN message by
      wm._nrpnBuffer[channelBufferIndex] = [];
    }
  };

  /**
   * @method _parseChannelEvent
   * @param e Event
   * @protected
   */
  Input.prototype._parseChannelEvent = function(e) {

    var command = e.data[0] &gt;&gt; 4;
    var channel = (e.data[0] &amp; 0xf) + 1;
    var data1, data2;

    if (e.data.length &gt; 1) {
      data1 = e.data[1];
      data2 = e.data.length &gt; 2 ? e.data[2] : undefined;
    }

    // Returned event
    var event = {
      target: this,
      data: e.data,
      timestamp: e.timeStamp,
      channel: channel
    };

    if (
      command === wm.MIDI_CHANNEL_MESSAGES.noteoff ||
      (command === wm.MIDI_CHANNEL_MESSAGES.noteon &amp;&amp; data2 === 0)
    ) {

      /**
       * Event emitted when a note off MIDI message has been received on a specific device and
       * channel.
       *
       * @event noteoff
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Object} event.note
       * @param {uint} event.note.number The MIDI note number.
       * @param {String} event.note.name The usual note name (C, C#, D, D#, etc.).
       * @param {uint} event.note.octave The octave (between -2 and 8).
       * @param {Number} event.velocity The release velocity (between 0 and 1).
       * @param {Number} event.rawVelocity The attack velocity expressed as a 7-bit integer (between
       * 0 and 127).
       */
      event.type = &quot;noteoff&quot;;
      event.note = {
        number: data1,
        name: wm._notes[data1 % 12],
        octave: wm.getOctave(data1)
      };
      event.velocity = data2 / 127;
      event.rawVelocity = data2;

    } else if (command === wm.MIDI_CHANNEL_MESSAGES.noteon) {

      /**
       * Event emitted when a note on MIDI message has been received on a specific device and
       * channel.
       *
       * @event noteon
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Object} event.note
       * @param {uint} event.note.number The MIDI note number.
       * @param {String} event.note.name The usual note name (C, C#, D, D#, etc.).
       * @param {uint} event.note.octave The octave (between -2 and 8).
       * @param {Number} event.velocity The attack velocity (between 0 and 1).
       * @param {Number} event.rawVelocity The attack velocity expressed as a 7-bit integer (between
       * 0 and 127).
       */
      event.type = &quot;noteon&quot;;
      event.note = {
        number: data1,
        name: wm._notes[data1 % 12],
        octave: wm.getOctave(data1)
      };
      event.velocity = data2 / 127;
      event.rawVelocity = data2;

    } else if (command === wm.MIDI_CHANNEL_MESSAGES.keyaftertouch) {

      /**
       * Event emitted when a key-specific aftertouch MIDI message has been received on a specific
       * device and channel.
       *
       * @event keyaftertouch
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Object} event.note
       * @param {uint} event.note.number The MIDI note number.
       * @param {String} event.note.name The usual note name (C, C#, D, D#, etc.).
       * @param {uint} event.note.octave The octave (between -2 and 8).
       * @param {Number} event.value The aftertouch amount (between 0 and 1).
       */
      event.type = &quot;keyaftertouch&quot;;
      event.note = {
        number: data1,
        name: wm._notes[data1 % 12],
        octave: wm.getOctave(data1)
      };
      event.value = data2 / 127;

    } else if (
      command === wm.MIDI_CHANNEL_MESSAGES.controlchange &amp;&amp;
      data1 &gt;= 0 &amp;&amp; data1 &lt;= 119
    ) {

      /**
       * Event emitted when a control change MIDI message has been received on a specific device and
       * channel.
       *
       * @event controlchange
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Object} event.controller
       * @param {uint} event.controller.number The number of the controller.
       * @param {String} event.controller.name The usual name or function of the controller.
       * @param {uint} event.value The value received (between 0 and 127).
       */
      event.type = &quot;controlchange&quot;;
      event.controller = {
        number: data1,
        name: this.getCcNameByNumber(data1)
      };
      event.value = data2;

    } else if (
      command === wm.MIDI_CHANNEL_MESSAGES.channelmode &amp;&amp;
      data1 &gt;= 120 &amp;&amp; data1 &lt;= 127
    ) {

      /**
       * Event emitted when a channel mode MIDI message has been received on a specific device and
       * channel.
       *
       * @event channelmode
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Object} event.controller
       * @param {uint} event.controller.number The number of the controller.
       * @param {String} event.controller.name The usual name or function of the controller.
       * @param {uint} event.value The value received (between 0 and 127).
       */
      event.type = &quot;channelmode&quot;;
      event.controller = {
        number: data1,
        name: this.getChannelModeByNumber(data1)
      };
      event.value = data2;

    } else if (command === wm.MIDI_CHANNEL_MESSAGES.programchange) {

      /**
       * Event emitted when a program change MIDI message has been received on a specific device and
       * channel.
       *
       * @event programchange
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {uint} event.value The value received (between 0 and 127).
       */
      event.type = &quot;programchange&quot;;
      event.value = data1;

    } else if (command === wm.MIDI_CHANNEL_MESSAGES.channelaftertouch) {

      /**
       * Event emitted when a channel-wide aftertouch MIDI message has been received on a specific
       * device and channel.
       *
       * @event channelaftertouch
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Number} event.value The aftertouch value received (between 0 and 1).
       */
      event.type = &quot;channelaftertouch&quot;;
      event.value = data1 / 127;

    } else if (command === wm.MIDI_CHANNEL_MESSAGES.pitchbend) {

      /**
       * Event emitted when a pitch bend MIDI message has been received on a specific device and
       * channel.
       *
       * @event pitchbend
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {uint} event.channel The channel where the event occurred (between 1 and 16).
       * @param {String} event.type The type of event that occurred.
       * @param {Number} event.value The pitch bend value received (between -1 and 1).
       */
      event.type = &quot;pitchbend&quot;;
      event.value = ((data2 &lt;&lt; 7) + data1 - 8192) / 8192;
    } else {
      event.type = &quot;unknownchannelmessage&quot;;
    }

    // If some callbacks have been defined for this event, on that device and channel, execute them.
    if (
      this._userHandlers.channel[event.type] &amp;&amp;
      this._userHandlers.channel[event.type][channel]
    ) {

      this._userHandlers.channel[event.type][channel].forEach(
        function(callback) { callback(event); }
      );
    }

  };

  /**
   * Returns the name of a control change message matching the specified number. If no match is
   * found, the function returns &#x60;undefined&#x60;.
   *
   * @method getCcNameByNumber
   *
   * @param number {Number} The number of the control change message.
   * @returns {String|undefined} The matching control change name or &#x60;undefined&#x60;.
   *
   * @throws RangeError The control change number must be between 0 and 119.
   *
   * @since 2.0.0
   */
  Input.prototype.getCcNameByNumber = function(number) {

    number = Math.floor(number);

    if ( !(number &gt;= 0 &amp;&amp; number &lt;= 119) ) {
      throw new RangeError(&quot;The control change number must be between 0 and 119.&quot;);
    }

    for (var cc in wm.MIDI_CONTROL_CHANGE_MESSAGES) {

      if (
        wm.MIDI_CONTROL_CHANGE_MESSAGES.hasOwnProperty(cc) &amp;&amp;
        number === wm.MIDI_CONTROL_CHANGE_MESSAGES[cc]
      ) {
        return cc;
      }

    }

    return undefined;

  };

  /**
   * Returns the channel mode name matching the specified number. If no match is found, the function
   * returns &#x60;undefined&#x60;.
   *
   * @method getChannelModeByNumber
   *
   * @param number {Number} The number of the channel mode message.
   * @returns {String|undefined} The matching channel mode message&quot;s name or &#x60;undefined&#x60;;
   *
   * @throws RangeError The channel mode number must be between 120 and 127.
   *
   * @since 2.0.0
   */
  Input.prototype.getChannelModeByNumber = function(number) {

    number = Math.floor(number);

    if ( !(number &gt;= 120 &amp;&amp; status &lt;= 127) ) {
      throw new RangeError(&quot;The control change number must be between 120 and 127.&quot;);
    }

    for (var cm in wm.MIDI_CHANNEL_MODE_MESSAGES) {

      if (
        wm.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(cm) &amp;&amp;
        number === wm.MIDI_CHANNEL_MODE_MESSAGES[cm]
      ) {
        return cm;
      }

    }

  };

  /**
   * @method _parseSystemEvent
   * @protected
   */
  Input.prototype._parseSystemEvent = function(e) {

    var command = e.data[0];

    // Returned event
    var event = {
      target: this,
      data: e.data,
      timestamp: e.timeStamp
    };

    if (command === wm.MIDI_SYSTEM_MESSAGES.sysex) {

      /**
       * Event emitted when a system exclusive MIDI message has been received. You should note that,
       * to receive &#x60;sysex&#x60; events, you must call the &#x60;WebMidi.enable()&#x60; method with a second
       * parameter set to &#x60;true&#x60;:
       *
       *     WebMidi.enable(function(err) {
       *
       *        if (err) {
       *          console.log(&quot;WebMidi could not be enabled.&quot;);
       *        }
       *
       *        var input = WebMidi.inputs[0];
       *
       *        input.addListener(&quot;sysex&quot;, &quot;all&quot;, function (e) {
       *          console.log(e);
       *        });
       *
       *     }, true);
       *
       * @event sysex
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type The type of event that occurred.
       *
       */
      event.type = &quot;sysex&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.timecode) {

      /**
       * Event emitted when a system MIDI time code quarter frame message has been received.
       *
       * @event timecode
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type The type of event that occurred.
       */
      event.type = &quot;timecode&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.songposition) {

      /**
       * Event emitted when a system song position pointer MIDI message has been received.
       *
       * @event songposition
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type The type of event that occurred.
       */
      event.type = &quot;songposition&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.songselect) {

      /**
       * Event emitted when a system song select MIDI message has been received.
       *
       * @event songselect
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type The type of event that occurred.
       * @param {String} event.song Song (or sequence) number to select.
       */
      event.type = &quot;songselect&quot;;
      event.song = e.data[1];

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.tuningrequest) {

      /**
       * Event emitted when a system tune request MIDI message has been received.
       *
       * @event tuningrequest
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &quot;tuningrequest&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.clock) {

      /**
       * Event emitted when a system timing clock MIDI message has been received.
       *
       * @event clock
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &quot;clock&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.start) {

      /**
       * Event emitted when a system start MIDI message has been received.
       *
       * @event start
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &quot;start&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.continue) {

      /**
       * Event emitted when a system continue MIDI message has been received.
       *
       * @event continue
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &quot;continue&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.stop) {

      /**
       * Event emitted when a system stop MIDI message has been received.
       *
       * @event stop
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &quot;stop&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.activesensing) {

      /**
       * Event emitted when a system active sensing MIDI message has been received.
       *
       * @event activesensing
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &quot;activesensing&quot;;

    } else if (command === wm.MIDI_SYSTEM_MESSAGES.reset) {

      /**
       * Event emitted when a system reset MIDI message has been received.
       *
       * @event reset
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &quot;reset&quot;;

    } else {

      /**
       * Event emitted when an unknown system MIDI message has been received. It could be, for
       * example, one of the undefined/reserved messages.
       *
       * @event unknownsystemmessage
       *
       * @param {Object} event
       * @param {Input} event.target The &#x60;Input&#x60; that triggered the event.
       * @param {Uint8Array} event.data The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.timestamp The time when the event occurred (in milliseconds)
       * @param {String} event.type The type of event that occurred.
       */
      event.type = &quot;unknownsystemmessage&quot;;

    }

    // If some callbacks have been defined for this event, execute them.
    if (this._userHandlers.system[event.type]) {
      this._userHandlers.system[event.type].forEach(
        function(callback) { callback(event); }
      );
    }

  };

  /**
   * The &#x60;Output&#x60; object represents a MIDI output port on the host system. This object is created by
   * the MIDI subsystem and cannot be instantiated directly.
   *
   * You will find all available &#x60;Output&#x60; objects in the &#x60;WebMidi.outputs&#x60; array.
   *
   * @class Output
   * @param {MIDIOutput} midiOutput Actual &#x60;MIDIOutput&#x60; object as defined by the MIDI subsystem
   */
  function Output(midiOutput) {

    var that = this;

    this._midiOutput = midiOutput;

    Object.defineProperties(this, {

      /**
       * [read-only] Status of the MIDI port&quot;s connection
       *
       * @property connection
       * @type String
       */
      connection: {
        enumerable: true,
        get: function () {
          return that._midiOutput.connection;
        }
      },

      /**
       * [read-only] ID string of the MIDI port
       *
       * @property id
       * @type String
       */
      id: {
        enumerable: true,
        get: function () {
          return that._midiOutput.id;
        }
      },

      /**
       * [read-only] Manufacturer of the device to which this port belongs
       *
       * @property manufacturer
       * @type String
       */
      manufacturer: {
        enumerable: true,
        get: function () {
          return that._midiOutput.manufacturer;
        }
      },

      /**
       * [read-only] Name of the MIDI port
       *
       * @property name
       * @type String
       */
      name: {
        enumerable: true,
        get: function () {
          return that._midiOutput.name;
        }
      },

      /**
       * [read-only] State of the MIDI port
       *
       * @property state
       * @type String
       */
      state: {
        enumerable: true,
        get: function () {
          return that._midiOutput.state;
        }
      },

      /**
       * [read-only] Type of the MIDI port (&#x60;output&#x60;)
       *
       * @property state
       * @type String
       */
      type: {
        enumerable: true,
        get: function () {
          return that._midiOutput.type;
        }
      }

    });

  }

  /**
   * Sends a MIDI message on the MIDI output port, at the scheduled timestamp.
   *
   * Unless, you are familiar with the details of the MIDI message format, you should not use this
   * method directly. Instead, use one of the simpler helper methods: &#x60;playNote()&#x60;, &#x60;stopNote()&#x60;,
   * &#x60;sendControlChange()&#x60;, &#x60;sendSystemMessage()&#x60;, etc.
   *
   * Details on the format of MIDI messages are available in the
   * &lt;a href=&quot;http://www.midi.org/techspecs/midimessages.php&quot;&gt;summary of MIDI messages&lt;/a&gt; of the
   * MIDI Manufacturers Association.
   *
   * @method send
   * @chainable
   *
   * @param status {Number} The MIDI status byte of the message (128-255).
   *
   * @param [data=[]] {Array} An array of uints for the message. The number of data bytes varies
   * depending on the status byte. It is perfectly legal to send no data for some message types (use
   * undefined or an empty array in this case). Each byte must be between 0 and 255.
   *
   * @param [timestamp=0] {DOMHighResTimeStamp} The timestamp at which to send the message. You can
   * use &#x60;WebMidi.time&#x60; to retrieve the current timestamp. To send immediately, leave blank or use
   * 0.
   *
   * @throws {RangeError} The status byte must be an integer between 128 (0x80) and 255 (0xFF).
   * @throws {RangeError} Data bytes must be integers between 0 (0x00) and 255 (0x7F).
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.send = function(status, data, timestamp) {

    if ( !(status &gt;= 128 &amp;&amp; status &lt;= 255) ) {
      throw new RangeError(&quot;The status byte must be an integer between 128 (0x80) and 255 (0xFF).&quot;);
    }

    if (data === undefined) data = [];
    if ( !Array.isArray(data) ) data = [data];

    var message = [];

    data.forEach(function(item){

      var parsed = Math.floor(item); // mandatory because of &quot;null&quot;

      if (parsed &gt;= 0 &amp;&amp; parsed &lt;= 255) {
        message.push(parsed);
      } else {
        throw new RangeError(&quot;Data bytes must be integers between 0 (0x00) and 255 (0xFF).&quot;);
      }

    });

    this._midiOutput.send([status].concat(message), parseFloat(timestamp) || 0);

    return this;

  };

  /**
   * Sends a MIDI *system exclusive* (sysex) message. The generated message will automatically be
   * prepended with the *sysex* byte (0xF0) and terminated with the *end of sysex* byte (0xF7).
   *
   * To use the &#x60;sendSysex()&#x60; method, system exclusive message support must have been enabled. To
   * do so, you must pass &#x60;true&#x60; as the second parameter to &#x60;WebMidi.enable()&#x60;:
   *
   *     WebMidi.enable(function (err) {
   *         if (err) {
   *             console.warn(err);
   *         } else {
   *             console.log(&quot;Sysex is enabled!&quot;);
   *         }
   *     }, true);
   *
   * Note that, depending on browser, version and platform, it may be necessary to serve the page
   * over HTTPS to enable sysex support.
   *
   * #### Examples
   *
   * If you want to send a sysex message to a Korg device connected to the first output, you would
   * use the following code:
   *
   *     WebMidi.outputs[0].sendSysex(0x42, [0x1, 0x2, 0x3, 0x4, 0x5]);
   *
   * The parameters can be specified using any number notation (decimal, hex, binary, etc.).
   * Therefore, the code below is equivalent to the code above:
   *
   *     WebMidi.outputs[0].sendSysex(66, [1, 2, 3, 4, 5]);
   *
   * The above code sends the byte values 1, 2, 3, 4 and 5 to Korg devices (hex 42 is the same as
   * decimal 66).
   *
   * Some manufacturers are identified using 3 bytes. In this case, you would use a 3-position array
   * as the first parameter. For example, to send the same sysex message to a
   * *Native Instruments* device:
   *
   *     WebMidi.outputs[0].sendSysex([0x00, 0x21, 0x09], [0x1, 0x2, 0x3, 0x4, 0x5]);
   *
   * There is no limit for the length of the data array. However, it is generally suggested to keep
   * system exclusive messages to 64Kb or less.
   *
   * @method sendSysex
   * @chainable
   *
   * @param manufacturer {Number|Array} An unsigned integer or an array of three unsigned integers
   * between 0 and 127 that identify the targeted manufacturer. The *MIDI Manufacturers Association*
   * maintains a full list of
   * [Manufacturer ID Numbers](https://www.midi.org/specifications/item/manufacturer-id-numbers).
   *
   * @param [data=[]] {Array} An array of uints between 0 and 127. This is the data you wish to
   * transfer.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throw Sysex message support must first be activated.
   * @throw The data bytes of a sysex message must be integers between 0 (0x00) and 127 (0x7F).
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendSysex = function(manufacturer, data, options) {

    if (!wm.sysexEnabled) {
      throw new Error(&quot;Sysex message support must first be activated.&quot;);
    }

    options = options || {};

    manufacturer = [].concat(manufacturer);

    data.forEach(function(item){
      if (item &lt; 0 || item &gt; 127) {
        throw new RangeError(
          &quot;The data bytes of a sysex message must be integers between 0 (0x00) and 127 (0x7F).&quot;
        );
      }
    });

    data = manufacturer.concat(data, wm.MIDI_SYSTEM_MESSAGES.sysexend);
    this.send(wm.MIDI_SYSTEM_MESSAGES.sysex, data, this._parseTimeParameter(options.time));

    return this;

  };

  /**
   * Sends a *MIDI Timecode Quarter Frame* message. Please note that no processing is being done on
   * the data. It is up to the developer to format the data according to the
   * [MIDI Timecode](https://en.wikipedia.org/wiki/MIDI_timecode) format.
   *
   * @method sendTimecodeQuarterFrame
   * @chainable
   *
   * @param value {Number} The quarter frame message content (integer between 0 and 127).
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendTimecodeQuarterFrame = function(value, options) {
    options = options || {};
    this.send(wm.MIDI_SYSTEM_MESSAGES.timecode, value, this._parseTimeParameter(options.time));
    return this;
  };

  /**
   * Sends a *Song Position* MIDI message. The value is expressed in MIDI beats (between 0 and
   * 16383) which are 16th note. Position 0 is always the start of the song.
   *
   * @method sendSongPosition
   * @chainable
   *
   * @param [value=0] {Number} The MIDI beat to cue to (int between 0 and 16383).
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendSongPosition = function(value, options) {

    value = Math.floor(value) || 0;

    options = options || {};

    var msb = (value &gt;&gt; 7) &amp; 0x7F;
    var lsb = value &amp; 0x7F;

    this.send(
      wm.MIDI_SYSTEM_MESSAGES.songposition,
      [msb, lsb],
      this._parseTimeParameter(options.time)
    );
    return this;

  };

  /**
   * Sends a *Song Select* MIDI message. Beware that some devices will display position 0 as
   * position 1 for user-friendlyness.
   *
   * @method sendSongSelect
   * @chainable
   *
   * @param value {Number} The number of the song to select (integer between 0 and 127).
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws The song number must be between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendSongSelect = function(value, options) {

    value = Math.floor(value);

    options = options || {};

    if ( !(value &gt;= 0 &amp;&amp; value &lt;= 127) ) {
      throw new RangeError(&quot;The song number must be between 0 and 127.&quot;);
    }

    this.send(wm.MIDI_SYSTEM_MESSAGES.songselect, [value], this._parseTimeParameter(options.time));

    return this;

  };

  /**
   * Sends a *MIDI tuning request* real-time message.
   *
   * Note: there is currently a bug in Chrome&quot;s MIDI implementation. If you try to use this
   * function, Chrome will actually throw a &quot;Message is incomplete&quot; error. The bug is
   * [scheduled to be fixed](https://bugs.chromium.org/p/chromium/issues/detail?id=610116).
   *
   * @method sendTuningRequest
   * @chainable
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendTuningRequest = function(options) {
    options = options || {};
    this.send(
      wm.MIDI_SYSTEM_MESSAGES.tuningrequest,
      undefined,
      this._parseTimeParameter(options.time)
    );
    return this;
  };

  /**
   * Sends a *MIDI Clock* real-time message. According to the standard, there are 24 MIDI Clocks
   * for every quarter note.
   *
   * @method sendClock
   * @chainable
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendClock = function(options) {
    options = options || {};
    this.send(wm.MIDI_SYSTEM_MESSAGES.clock, undefined, this._parseTimeParameter(options.time));
    return this;
  };

  /**
   * Sends a *Start* real-time message. A MIDI Start message starts the playback of the current
   * song at beat 0. To start playback elsewhere in the song, use the &#x60;sendContinue()&#x60; function.
   *
   * @method sendStart
   * @chainable
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendStart = function(options) {
    options = options || {};
    this.send(wm.MIDI_SYSTEM_MESSAGES.start, undefined, this._parseTimeParameter(options.time));
    return this;
  };

  /**
   * Sends a *Continue* real-time message. This resumes song playback where it was previously
   * stopped or where it was last cued with a song position message. To start playback from the
   * start, use the &#x60;sendStart()&#x60; function.
   *
   * @method sendContinue
   * @chainable
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {WebMidi} Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  Output.prototype.sendContinue = function(options) {
    options = options || {};
    this.send(wm.MIDI_SYSTEM_MESSAGES.continue, undefined, this._parseTimeParameter(options.time));
    return this;
  };

  /**
   * Sends a *Stop* real-time message. This tells the device connected to this port to stop playback
   * immediately (or at the scheduled time).
   *
   * @method sendStop
   * @chainable
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendStop = function(options) {
    options = options || {};
    this.send(wm.MIDI_SYSTEM_MESSAGES.stop, undefined, this._parseTimeParameter(options.time));
    return this;
  };

  /**
   * Sends an *Active Sensing* real-time message. This tells the device connected to this port that
   * the connection is still good. Active sensing messages should be sent every 300 ms if there was
   * no other activity on the MIDI port.
   *
   * @method sendActiveSensing
   * @chainable
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendActiveSensing = function(options) {
    options = options || {};
    this.send(
      wm.MIDI_SYSTEM_MESSAGES.activesensing,
      [],
      this._parseTimeParameter(options.time)
    );
    return this;
  };

  /**
   * Sends *Reset* real-time message. This tells the device connected to this port that is should
   * reset itself to a default state.
   *
   * @method sendReset
   * @chainable
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendReset = function(options) {
    options = options || {};
    this.send(wm.MIDI_SYSTEM_MESSAGES.reset, undefined, this._parseTimeParameter(options.time));
    return this;
  };

  /**
   * Sends a MIDI **note off** message to the specified channel(s) for a single note or multiple
   * simultaneous notes (chord). You can delay the execution of the **note off** command by using
   * the &#x60;time&#x60; property of the &#x60;options&#x60; parameter (in milliseconds).
   *
   * @method stopNote
   * @chainable
   *
   * @param note {Number|Array|String}  The note(s) you wish to stop. The notes can be specified in
   * one of three ways. The first way is by using the MIDI note number (an integer between &#x60;0&#x60; and
   * &#x60;127&#x60;). The second way is by using the note name followed by the octave (C3, G#4, F-1, Db7).
   * The octave range should be between -2 and 8. The lowest note is C-2 (MIDI note number 0) and
   * the highest note is G8 (MIDI note number 127). It is also possible to specify an array of note
   * numbers and/or names. The final way is to use the special value &#x60;all&#x60; to send an &quot;allnotesoff&quot;
   * channel message.
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between &#x60;1&#x60; and &#x60;16&#x60;) or an
   * array of channel numbers. If the special value &#x60;all&#x60; is used (default), the message will be
   * sent to all 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {Boolean} [options.rawVelocity=false] Controls whether the release velocity is set using
   * an integer between &#x60;0&#x60; and &#x60;127&#x60; (&#x60;true&#x60;) or a decimal number between &#x60;0&#x60; and &#x60;1&#x60; (&#x60;false&#x60;,
   * default).
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @param {Number} [options.velocity=0.5] The velocity at which to release the note (between &#x60;0&#x60;
   * and &#x60;1&#x60;). If the &#x60;rawVelocity&#x60; option is &#x60;true&#x60;, the value should be specified as an integer
   * between &#x60;0&#x60; and &#x60;127&#x60;. An invalid velocity value will silently trigger the default of &#x60;0.5&#x60;.
   * Note that when the first parameter to &#x60;stopNote()&#x60; is &#x60;all&#x60;, the release velocity is silently
   * ignored.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.stopNote = function(note, channel, options) {

    if (note === &quot;all&quot;) {
      return this.sendChannelMode(&quot;allnotesoff&quot;, 0, channel, options);
    }

    var nVelocity = 64;

    options = options || {};

    if (options.rawVelocity) {

      if (!isNaN(options.velocity) &amp;&amp; options.velocity &gt;= 0 &amp;&amp; options.velocity &lt;= 127) {
        nVelocity = options.velocity;
      }

    } else {

      if (!isNaN(options.velocity) &amp;&amp; options.velocity &gt;= 0 &amp;&amp; options.velocity &lt;= 1) {
        nVelocity = options.velocity * 127;
      }

    }

    // Send note off messages
    this._convertNoteToArray(note).forEach(function(item) {

      wm.toMIDIChannels(channel).forEach(function(ch) {

        this.send(
          (wm.MIDI_CHANNEL_MESSAGES.noteoff &lt;&lt; 4) + (ch - 1),
          [item, Math.round(nVelocity)],
          this._parseTimeParameter(options.time)
        );

      }.bind(this));

    }.bind(this));

    return this;

  };

  /**
   * Requests the playback of a single note or multiple notes on the specified channel(s). You can
   * delay the execution of the **note on** command by using the &#x60;time&#x60; property of the &#x60;options&#x60;
   * parameter (milliseconds).
   *
   * If no duration is specified in the &#x60;options&#x60;, the note will play until a matching **note off**
   * is sent. If a duration is specified, a **note off** will be automatically sent after said
   * duration.
   *
   * Note: As per the MIDI standard, a **note on** event with a velocity of &#x60;0&#x60; is considered to be
   * a **note off**.
   *
   * @method playNote
   * @chainable
   *
   * @param note {Number|String|Array}  The note(s) you wish to play. The notes can be specified in
   * one of two ways. The first way is by using the MIDI note number (an integer between 0 and 127).
   * The second way is by using the note name followed by the octave (C3, G#4, F-1, Db7). The octave
   * range should be between -2 and 8. The lowest note is C-2 (MIDI note number 0) and the highest
   * note is G8 (MIDI note number 127). It is also possible to specify an array of note numbers
   * and/or names.
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between &#x60;1&#x60; and &#x60;16&#x60;) or an
   * array of channel numbers. If the special value **all** is used (default), the message will be
   * sent to all 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {Number} [options.duration=undefined] The number of milliseconds (integer) to wait
   * before sending a matching **note off** event. If left undefined, only a **note on** message is
   * sent.
   *
   * @param {Boolean} [options.rawVelocity=false] Controls whether the attack and release velocities
   * are set using integers between &#x60;0&#x60; and &#x60;127&#x60; (&#x60;true&#x60;) or a decimal number between &#x60;0&#x60; and &#x60;1&#x60;
   * (&#x60;false&#x60;, default).
   *
   * @param {Number} [options.release=0.5] The velocity at which to release the note (between &#x60;0&#x60;
   * and &#x60;1&#x60;). If the &#x60;rawVelocity&#x60; option is &#x60;true&#x60;, the value should be specified as an integer
   * between &#x60;0&#x60; and &#x60;127&#x60;. An invalid velocity value will silently trigger the default of &#x60;0.5&#x60;.
   * This is only used with the **note off** event triggered when &#x60;options.duration&#x60; is set.
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @param {Number} [options.velocity=0.5] The velocity at which to play the note (between &#x60;0&#x60; and
   * &#x60;1&#x60;). If the &#x60;rawVelocity&#x60; option is &#x60;true&#x60;, the value should be specified as an integer
   * between &#x60;0&#x60; and &#x60;127&#x60;. An invalid velocity value will silently trigger the default of &#x60;0.5&#x60;.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.playNote = function(note, channel, options) {

    var time,
      nVelocity = 64;

    options = options || {};

    if (options.rawVelocity) {

      if (!isNaN(options.velocity) &amp;&amp; options.velocity &gt;= 0 &amp;&amp; options.velocity &lt;= 127) {
        nVelocity = options.velocity;
      }

    } else {

      if (!isNaN(options.velocity) &amp;&amp; options.velocity &gt;= 0 &amp;&amp; options.velocity &lt;= 1) {
        nVelocity = options.velocity * 127;
      }

    }

    time = this._parseTimeParameter(options.time);

    // Send note on messages
    this._convertNoteToArray(note).forEach(function(item) {

      wm.toMIDIChannels(channel).forEach(function(ch) {
        this.send(
          (wm.MIDI_CHANNEL_MESSAGES.noteon &lt;&lt; 4) + (ch - 1),
          [item, Math.round(nVelocity)],
          time
        );
      }.bind(this));

    }.bind(this));


    // Send note off messages (only if a valid duration has been defined)
    if (!isNaN(options.duration)) {

      if (options.duration &lt;= 0) { options.duration = 0; }

      var nRelease = 64;

      if (options.rawVelocity) {

        if (!isNaN(options.release) &amp;&amp; options.release &gt;= 0 &amp;&amp; options.release &lt;= 127) {
          nRelease = options.release;
        }

      } else {

        if (!isNaN(options.release) &amp;&amp; options.release &gt;= 0 &amp;&amp; options.release &lt;= 1) {
          nRelease = options.release * 127;
        }

      }

      this._convertNoteToArray(note).forEach(function(item) {

        wm.toMIDIChannels(channel).forEach(function(ch) {

          this.send(
            (wm.MIDI_CHANNEL_MESSAGES.noteoff &lt;&lt; 4) + (ch - 1),
            [item, Math.round(nRelease)],
            (time || wm.time) + options.duration
          );
        }.bind(this));

      }.bind(this));

    }

    return this;

  };

  /**
   * Sends a MIDI &#x60;key aftertouch&#x60; message to the specified channel(s) at the scheduled time. This
   * is a key-specific aftertouch. For a channel-wide aftertouch message, use
   * {{#crossLink &quot;WebMidi/sendChannelAftertouch:method&quot;}}sendChannelAftertouch(){{/crossLink}}.
   *
   * @method sendKeyAftertouch
   * @chainable
   *
   * @param note {Number|String|Array}  The note for which you are sending an aftertouch value. The
   * notes can be specified in one of two ways. The first way is by using the MIDI note number (an
   * integer between 0 and 127). The second way is by using the note name followed by the octave
   * (C3, G#4, F-1, Db7). The octave range should be between -2 and 8. The lowest note is C-2 (MIDI
   * note number 0) and the highest note is G8 (MIDI note number 127). It is also possible to use
   * an array of note names and/or numbers.
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Number} [pressure=0.5] The pressure level to send (between 0 and 1).
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} The channel must be between 1 and 16.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendKeyAftertouch = function(note, channel, pressure, options) {

    var that = this;

    options = options || {};

    if (channel &lt; 1 || channel &gt; 16) {
      throw new RangeError(&quot;The channel must be between 1 and 16.&quot;);
    }

    if (isNaN(pressure) || pressure &lt; 0 || pressure &gt; 1) {
      pressure = 0.5;
    }

    var nPressure = Math.round(pressure * 127);

    this._convertNoteToArray(note).forEach(function(item) {

      wm.toMIDIChannels(channel).forEach(function(ch) {
        that.send(
          (wm.MIDI_CHANNEL_MESSAGES.keyaftertouch &lt;&lt; 4) + (ch - 1),
          [item, nPressure],
          that._parseTimeParameter(options.time)
        );
      });

    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;control change&#x60; message (a.k.a. CC message) to the specified channel(s) at the
   * scheduled time. The control change message to send can be specified numerically or by using one
   * of the following common names:
   *
   *  * &#x60;bankselectcoarse&#x60; (#0)
   *  * &#x60;modulationwheelcoarse&#x60; (#1)
   *  * &#x60;breathcontrollercoarse&#x60; (#2)
   *  * &#x60;footcontrollercoarse&#x60; (#4)
   *  * &#x60;portamentotimecoarse&#x60; (#5)
   *  * &#x60;dataentrycoarse&#x60; (#6)
   *  * &#x60;volumecoarse&#x60; (#7)
   *  * &#x60;balancecoarse&#x60; (#8)
   *  * &#x60;pancoarse&#x60; (#10)
   *  * &#x60;expressioncoarse&#x60; (#11)
   *  * &#x60;effectcontrol1coarse&#x60; (#12)
   *  * &#x60;effectcontrol2coarse&#x60; (#13)
   *  * &#x60;generalpurposeslider1&#x60; (#16)
   *  * &#x60;generalpurposeslider2&#x60; (#17)
   *  * &#x60;generalpurposeslider3&#x60; (#18)
   *  * &#x60;generalpurposeslider4&#x60; (#19)
   *  * &#x60;bankselectfine&#x60; (#32)
   *  * &#x60;modulationwheelfine&#x60; (#33)
   *  * &#x60;breathcontrollerfine&#x60; (#34)
   *  * &#x60;footcontrollerfine&#x60; (#36)
   *  * &#x60;portamentotimefine&#x60; (#37)
   *  * &#x60;dataentryfine&#x60; (#38)
   *  * &#x60;volumefine&#x60; (#39)
   *  * &#x60;balancefine&#x60; (#40)
   *  * &#x60;panfine&#x60; (#42)
   *  * &#x60;expressionfine&#x60; (#43)
   *  * &#x60;effectcontrol1fine&#x60; (#44)
   *  * &#x60;effectcontrol2fine&#x60; (#45)
   *  * &#x60;holdpedal&#x60; (#64)
   *  * &#x60;portamento&#x60; (#65)
   *  * &#x60;sustenutopedal&#x60; (#66)
   *  * &#x60;softpedal&#x60; (#67)
   *  * &#x60;legatopedal&#x60; (#68)
   *  * &#x60;hold2pedal&#x60; (#69)
   *  * &#x60;soundvariation&#x60; (#70)
   *  * &#x60;resonance&#x60; (#71)
   *  * &#x60;soundreleasetime&#x60; (#72)
   *  * &#x60;soundattacktime&#x60; (#73)
   *  * &#x60;brightness&#x60; (#74)
   *  * &#x60;soundcontrol6&#x60; (#75)
   *  * &#x60;soundcontrol7&#x60; (#76)
   *  * &#x60;soundcontrol8&#x60; (#77)
   *  * &#x60;soundcontrol9&#x60; (#78)
   *  * &#x60;soundcontrol10&#x60; (#79)
   *  * &#x60;generalpurposebutton1&#x60; (#80)
   *  * &#x60;generalpurposebutton2&#x60; (#81)
   *  * &#x60;generalpurposebutton3&#x60; (#82)
   *  * &#x60;generalpurposebutton4&#x60; (#83)
   *  * &#x60;reverblevel&#x60; (#91)
   *  * &#x60;tremololevel&#x60; (#92)
   *  * &#x60;choruslevel&#x60; (#93)
   *  * &#x60;celestelevel&#x60; (#94)
   *  * &#x60;phaserlevel&#x60; (#95)
   *  * &#x60;databuttonincrement&#x60; (#96)
   *  * &#x60;databuttondecrement&#x60; (#97)
   *  * &#x60;nonregisteredparametercoarse&#x60; (#98)
   *  * &#x60;nonregisteredparameterfine&#x60; (#99)
   *  * &#x60;registeredparametercoarse&#x60; (#100)
   *  * &#x60;registeredparameterfine&#x60; (#101)
   *
   * Note: as you can see above, not all control change message have a matching common name. This
   * does not mean you cannot use the others. It simply means you will need to use their number
   * instead of their name.
   *
   * To view a list of all available &#x60;control change&#x60; messages, please consult &quot;Table 3 - Control
   * Change Messages&quot; from the [MIDI Messages](
   * https://www.midi.org/specifications/item/table-3-control-change-messages-data-bytes-2)
   * specification.
   *
   * @method sendControlChange
   * @chainable
   *
   * @param controller {Number|String} The MIDI controller number (0-119) or name.
   *
   * @param [value=0] {Number} The value to send (0-127).
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} Controller numbers must be between 0 and 119.
   * @throws {RangeError} Value must be between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendControlChange = function(controller, value, channel, options) {

    options = options || {};

    if (typeof controller === &quot;string&quot;) {

      controller = wm.MIDI_CONTROL_CHANGE_MESSAGES[controller];
      if (controller === undefined) throw new TypeError(&quot;Invalid controller name.&quot;);

    } else {

      controller = Math.floor(controller);
      if ( !(controller &gt;= 0 &amp;&amp; controller &lt;= 119) ) {
        throw new RangeError(&quot;Controller numbers must be between 0 and 119.&quot;);
      }

    }

    value = Math.floor(value) || 0;
    if ( !(value &gt;= 0 &amp;&amp; value &lt;= 127) ) {
      throw new RangeError(&quot;Controller value must be between 0 and 127.&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function(ch) {
      this.send(
        (wm.MIDI_CHANNEL_MESSAGES.controlchange &lt;&lt; 4) + (ch - 1),
        [controller, value],
        this._parseTimeParameter(options.time)
      );
    }.bind(this));

    return this;

  };

  /**
   * Selects a MIDI registered parameter so it is affected by data entry, data increment and data
   * decrement messages.
   *
   * @method _selectRegisteredParameter
   * @protected
   *
   * @param parameter {Array} A two-position array specifying the two control bytes (0x65, 0x64)
   * that identify the registered parameter.
   * @param channel
   * @param time
   *
   * @returns {Output}
   */
  Output.prototype._selectRegisteredParameter = function(parameter, channel, time) {

    var that = this;

    parameter[0] = Math.floor(parameter[0]);
    if ( !(parameter[0] &gt;= 0 &amp;&amp; parameter[0] &lt;= 127) ) {
      throw new RangeError(&quot;The control65 value must be between 0 and 127&quot;);
    }

    parameter[1] = Math.floor(parameter[1]);
    if ( !(parameter[1] &gt;= 0 &amp;&amp; parameter[1] &lt;= 127) ) {
      throw new RangeError(&quot;The control64 value must be between 0 and 127&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that.sendControlChange(0x65, parameter[0], channel, {time: time});
      that.sendControlChange(0x64, parameter[1], channel, {time: time});
    });

    return this;

  };

  /**
   * Selects a MIDI non-registered parameter so it is affected by data entry, data increment and
   * data decrement messages.
   *
   * @method _selectNonRegisteredParameter
   * @protected
   *
   * @param parameter {Array} A two-position array specifying the two control bytes (0x63, 0x62)
   * that identify the registered parameter.
   * @param channel
   * @param time
   *
   * @returns {Output}
   */
  Output.prototype._selectNonRegisteredParameter = function(parameter, channel, time) {

    var that = this;

    parameter[0] = Math.floor(parameter[0]);
    if ( !(parameter[0] &gt;= 0 &amp;&amp; parameter[0] &lt;= 127) ) {
      throw new RangeError(&quot;The control63 value must be between 0 and 127&quot;);
    }

    parameter[1] = Math.floor(parameter[1]);
    if ( !(parameter[1] &gt;= 0 &amp;&amp; parameter[1] &lt;= 127) ) {
      throw new RangeError(&quot;The control62 value must be between 0 and 127&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that.sendControlChange(0x63, parameter[0], channel, {time: time});
      that.sendControlChange(0x62, parameter[1], channel, {time: time});
    });

    return this;

  };

  /**
   * Sets the value of the currently selected MIDI registered parameter.
   *
   * @method _setCurrentRegisteredParameter
   * @protected
   *
   * @param data {int|Array}
   * @param channel
   * @param time
   *
   * @returns {Output}
   */
  Output.prototype._setCurrentRegisteredParameter = function(data, channel, time) {

    var that = this;

    data = [].concat(data);

    data[0] = Math.floor(data[0]);
    if ( !(data[0] &gt;= 0 &amp;&amp; data[0] &lt;= 127) ) {
      throw new RangeError(&quot;The msb value must be between 0 and 127&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that.sendControlChange(0x06, data[0], channel, {time: time});
    });

    data[1] = Math.floor(data[1]);
    if(data[1] &gt;= 0 &amp;&amp; data[1] &lt;= 127) {
      wm.toMIDIChannels(channel).forEach(function() {
        that.sendControlChange(0x26, data[1], channel, {time: time});
      });
    }

    return this;

  };

  /**
   * Deselects the currently active MIDI registered parameter so it is no longer affected by data
   * entry, data increment and data decrement messages.
   *
   * Current best practice recommends doing that after each call to
   * &#x60;_setCurrentRegisteredParameter()&#x60;.
   *
   * @method _deselectRegisteredParameter
   * @protected
   *
   * @param channel
   * @param time
   *
   * @returns {Output}
   */
  Output.prototype._deselectRegisteredParameter = function(channel, time) {

    var that = this;

    wm.toMIDIChannels(channel).forEach(function() {
      that.sendControlChange(0x65, 0x7F, channel, {time: time});
      that.sendControlChange(0x64, 0x7F, channel, {time: time});
    });

    return this;

  };

  /**
   * Sets the specified MIDI registered parameter to the desired value. The value is defined with
   * up to two bytes of data that each can go from 0 to 127.
   *
   * &gt;Unless you are very familiar with the MIDI standard you probably should favour one of the
   * &gt;simpler to use functions such as: &#x60;setPitchbendRange()&#x60;, &#x60;setModulationRange()&#x60;,
   * &gt;&#x60;setMasterTuning()&#x60;, etc.
   *
   * MIDI registered parameters extend the original list of control change messages. Currently,
   * there are only a limited number of them. Here are the original registered parameters with the
   * identifier that can be used as the first parameter of this function:
   *
   *  * Pitchbend Range (0x00, 0x00): &#x60;pitchbendrange&#x60;
   *  * Channel Fine Tuning (0x00, 0x01): &#x60;channelfinetuning&#x60;
   *  * Channel Coarse Tuning (0x00, 0x02): &#x60;channelcoarsetuning&#x60;
   *  * Tuning Program (0x00, 0x03): &#x60;tuningprogram&#x60;
   *  * Tuning Bank (0x00, 0x04): &#x60;tuningbank&#x60;
   *  * Modulation Range (0x00, 0x05): &#x60;modulationrange&#x60;
   *
   * Note that the **Tuning Program** and **Tuning Bank** parameters are part of the *MIDI Tuning
   * Standard*, which is not widely implemented.
   *
   * Another set of extra parameters have been later added for 3D sound controllers. They are:
   *
   *  * Azimuth Angle (0x3D, 0x00): &#x60;azimuthangle&#x60;
   *  * Elevation Angle (0x3D, 0x01): &#x60;elevationangle&#x60;
   *  * Gain (0x3D, 0x02): &#x60;gain&#x60;
   *  * Distance Ratio (0x3D, 0x03): &#x60;distanceratio&#x60;
   *  * Maximum Distance (0x3D, 0x04): &#x60;maximumdistance&#x60;
   *  * Maximum Distance Gain (0x3D, 0x05): &#x60;maximumdistancegain&#x60;
   *  * Reference Distance Ratio (0x3D, 0x06): &#x60;referencedistanceratio&#x60;
   *  * Pan Spread Angle (0x3D, 0x07): &#x60;panspreadangle&#x60;
   *  * Roll Angle (0x3D, 0x08): &#x60;rollangle&#x60;
   *
   * @method setRegisteredParameter
   * @chainable
   *
   * @param parameter {String|Array} A string identifying the parameter&quot;s name (see above) or a
   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
   * parameter.
   *
   * @param [data=[]] {Number|Array} An single integer or an array of integers with a maximum length
   * of 2 specifying the desired data.
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @returns {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.setRegisteredParameter = function(parameter, data, channel, options) {

    var that = this;

    options = options || {};

    if ( !Array.isArray(parameter) ) {
      if ( !wm.MIDI_REGISTERED_PARAMETER[parameter]) {
        throw new Error(&quot;The specified parameter is not available.&quot;);
      }
      parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that._selectRegisteredParameter(parameter, channel, options.time);
      that._setCurrentRegisteredParameter(data, channel, options.time);
      that._deselectRegisteredParameter(channel, options.time);
    });

    return this;

  };

  /**
   * Sets a non-registered parameter to the specified value. The NRPN is selected by passing in a
   * two-position array specifying the values of the two control bytes. The value is specified by
   * passing in an single integer (most cases) or an array of two integers.
   *
   * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way
   * they see fit. For example, according to the Roland GS specification, you can control the
   * **vibrato rate** using NRPN (1, 8). Therefore, to set the **vibrato rate** value to **123** you
   * would use:
   *
   *     WebMidi.outputs[0].setNonRegisteredParameter([1, 8], 123);
   *
   * Obviously, you should select a channel so the message is not sent to all channels. For
   * instance, to send to channel 1 of the first output port, you would use:
   *
   *     WebMidi.outputs[0].setNonRegisteredParameter([1, 8], 123, 1);
   *
   * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you
   * would use a 2-position array. For example, for its **ClockBPM** parameter (2, 63), Novation
   * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the
   * value to send was 10, you could use:
   *
   *     WebMidi.outputs[0].setNonRegisteredParameter([2, 63], [0, 10]);
   *
   * For further implementation details, refer to the manufacturer&quot;s documentation.
   *
   * @method setNonRegisteredParameter
   * @chainable
   *
   * @param parameter {Array} A two-position array specifying the two control bytes (0x63,
   * 0x62) that identify the non-registered parameter.
   *
   * @param [data=[]] {Number|Array} An integer or an array of integers with a length of 1 or 2
   * specifying the desired data.
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @returns {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.setNonRegisteredParameter = function(parameter, data, channel, options) {

    var that = this;

    options = options || {};

    if (
      !(parameter[0] &gt;= 0 &amp;&amp; parameter[0] &lt;= 127) ||
      !(parameter[1] &gt;= 0 &amp;&amp; parameter[1] &lt;= 127)
    ) {
      throw new Error(
        &quot;Position 0 and 1 of the 2-position parameter array must both be between 0 and 127.&quot;
      );
    }

    data = [].concat(data);

    wm.toMIDIChannels(channel).forEach(function() {
      that._selectNonRegisteredParameter(parameter, channel, options.time);
      that._setCurrentRegisteredParameter(data, channel, options.time);
      that._deselectRegisteredParameter(channel, options.time);
    });

    return this;

  };

  /**
   * Increments the specified MIDI registered parameter by 1. For more specific MIDI usage
   * information, check out [RP-18](http://dev.midi.org/techspecs/rp18.php) regarding the usage of
   * increment and decrement controllers.
   *
   * &gt;Unless you are very familiar with the MIDI standard you probably should favour one of the
   * &gt;simpler to use functions such as: &#x60;setPitchbendRange()&#x60;, &#x60;setModulationRange()&#x60;,
   * &gt;&#x60;setMasterTuning()&#x60;, etc.
   *
   * Here is the full list of parameter names that can be used with this function:
   *
   *  * Pitchbend Range (0x00, 0x00): &#x60;pitchbendrange&#x60;
   *  * Channel Fine Tuning (0x00, 0x01): &#x60;channelfinetuning&#x60;
   *  * Channel Coarse Tuning (0x00, 0x02): &#x60;channelcoarsetuning&#x60;
   *  * Tuning Program (0x00, 0x03): &#x60;tuningprogram&#x60;
   *  * Tuning Bank (0x00, 0x04): &#x60;tuningbank&#x60;
   *  * Modulation Range (0x00, 0x05): &#x60;modulationrange&#x60;
   *  * Azimuth Angle (0x3D, 0x00): &#x60;azimuthangle&#x60;
   *  * Elevation Angle (0x3D, 0x01): &#x60;elevationangle&#x60;
   *  * Gain (0x3D, 0x02): &#x60;gain&#x60;
   *  * Distance Ratio (0x3D, 0x03): &#x60;distanceratio&#x60;
   *  * Maximum Distance (0x3D, 0x04): &#x60;maximumdistance&#x60;
   *  * Maximum Distance Gain (0x3D, 0x05): &#x60;maximumdistancegain&#x60;
   *  * Reference Distance Ratio (0x3D, 0x06): &#x60;referencedistanceratio&#x60;
   *  * Pan Spread Angle (0x3D, 0x07): &#x60;panspreadangle&#x60;
   *  * Roll Angle (0x3D, 0x08): &#x60;rollangle&#x60;
   *
   * @method incrementRegisteredParameter
   * @chainable
   *
   * @param parameter {String|Array} A string identifying the parameter&quot;s name (see above) or a
   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
   * parameter.
   *
   * @param [channel=all] {uint|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws Error The specified parameter is not available.
   *
   * @returns {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.incrementRegisteredParameter = function(parameter, channel, options) {

    var that = this;

    options = options || {};

    if ( !Array.isArray(parameter) ) {
      if ( !wm.MIDI_REGISTERED_PARAMETER[parameter]) {
        throw new Error(&quot;The specified parameter is not available.&quot;);
      }
      parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that._selectRegisteredParameter(parameter, channel, options.time);
      that.sendControlChange(0x60, 0, channel, {time: options.time});
      that._deselectRegisteredParameter(channel, options.time);
    });

    return this;

  };

  /**
   * Decrements the specified MIDI registered parameter by 1. For more specific MIDI usage
   * information, check out [RP-18](http://dev.midi.org/techspecs/rp18.php) regarding the usage of
   * increment and decrement controllers.
   *
   * &gt;Unless you are very familiar with the MIDI standard you probably should favour one of the
   * &gt;simpler to use functions such as: &#x60;setPitchbendRange()&#x60;, &#x60;setModulationRange()&#x60;,
   * &gt;&#x60;setMasterTuning()&#x60;, etc.
   *
   * Here is the full list of parameter names that can be used with this function:
   *
   *  * Pitchbend Range (0x00, 0x00): &#x60;pitchbendrange&#x60;
   *  * Channel Fine Tuning (0x00, 0x01): &#x60;channelfinetuning&#x60;
   *  * Channel Coarse Tuning (0x00, 0x02): &#x60;channelcoarsetuning&#x60;
   *  * Tuning Program (0x00, 0x03): &#x60;tuningprogram&#x60;
   *  * Tuning Bank (0x00, 0x04): &#x60;tuningbank&#x60;
   *  * Modulation Range (0x00, 0x05): &#x60;modulationrange&#x60;
   *  * Azimuth Angle (0x3D, 0x00): &#x60;azimuthangle&#x60;
   *  * Elevation Angle (0x3D, 0x01): &#x60;elevationangle&#x60;
   *  * Gain (0x3D, 0x02): &#x60;gain&#x60;
   *  * Distance Ratio (0x3D, 0x03): &#x60;distanceratio&#x60;
   *  * Maximum Distance (0x3D, 0x04): &#x60;maximumdistance&#x60;
   *  * Maximum Distance Gain (0x3D, 0x05): &#x60;maximumdistancegain&#x60;
   *  * Reference Distance Ratio (0x3D, 0x06): &#x60;referencedistanceratio&#x60;
   *  * Pan Spread Angle (0x3D, 0x07): &#x60;panspreadangle&#x60;
   *  * Roll Angle (0x3D, 0x08): &#x60;rollangle&#x60;
   *
   * @method decrementRegisteredParameter
   * @chainable
   *
   * @param parameter {String|Array} A string identifying the parameter&quot;s name (see above) or a
   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
   * parameter.
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws TypeError The specified parameter is not available.
   *
   * @returns {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.decrementRegisteredParameter = function(parameter, channel, options) {

    options = options || {};

    if ( !Array.isArray(parameter) ) {
      if ( !wm.MIDI_REGISTERED_PARAMETER[parameter]) {
        throw new TypeError(&quot;The specified parameter is not available.&quot;);
      }
      parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
    }

    wm.toMIDIChannels(channel).forEach(function() {
      this._selectRegisteredParameter(parameter, channel, options.time);
      this.sendControlChange(0x61, 0, channel, {time: options.time});
      this._deselectRegisteredParameter(channel, options.time);
    }.bind(this));

    return this;

  };

  /**
   * Sends a pitch bend range message to the specified channel(s) at the scheduled time so that they
   * adjust the range used by their pitch bend lever. The range can be specified with the
   * &#x60;semitones&#x60; parameter, the &#x60;cents&#x60; parameter or by specifying both parameters at the same time.
   *
   * @method setPitchBendRange
   * @chainable
   *
   * @param [semitones=0] {Number} The desired adjustment value in semitones (integer between
   * 0-127). While nothing imposes that in the specification, it is very common for manufacturers to
   * limit the range to 2 octaves (-12 semitones to 12 semitones).
   *
   * @param [cents=0] {Number} The desired adjustment value in cents (integer between 0-127).
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} The semitones value must be between 0 and 127.
   * @throws {RangeError} The cents value must be between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.setPitchBendRange = function(semitones, cents, channel, options) {

    var that = this;

    options = options || {};

    semitones = Math.floor(semitones) || 0;
    if ( !(semitones &gt;= 0 &amp;&amp; semitones &lt;= 127) ) {
      throw new RangeError(&quot;The semitones value must be between 0 and 127&quot;);
    }

    cents = Math.floor(cents) || 0;
    if ( !(cents &gt;= 0 &amp;&amp; cents &lt;= 127) ) {
      throw new RangeError(&quot;The cents value must be between 0 and 127&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that.setRegisteredParameter(
        &quot;pitchbendrange&quot;, [semitones, cents], channel, {time: options.time}
      );
    });

    return this;

  };

  /**
   * Sends a modulation depth range message to the specified channel(s) so that they adjust the
   * depth of their modulation wheel&quot;s range. The range can be specified with the &#x60;semitones&#x60;
   * parameter, the &#x60;cents&#x60; parameter or by specifying both parameters at the same time.
   *
   * @method setModulationRange
   * @chainable
   *
   * @param [semitones=0] {Number} The desired adjustment value in semitones (integer between
   * 0-127).
   *
   * @param [cents=0] {Number} The desired adjustment value in cents (0-127).
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} The semitones value must be between 0 and 127.
   * @throws {RangeError} The cents value must be between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.setModulationRange = function(semitones, cents, channel, options) {

    var that = this;

    options = options || {};

    semitones = Math.floor(semitones) || 0;
    if ( !(semitones &gt;= 0 &amp;&amp; semitones &lt;= 127) ) {
      throw new RangeError(&quot;The semitones value must be between 0 and 127&quot;);
    }

    cents = Math.floor(cents) || 0;
    if ( !(cents &gt;= 0 &amp;&amp; cents &lt;= 127) ) {
      throw new RangeError(&quot;The cents value must be between 0 and 127&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that.setRegisteredParameter(
        &quot;modulationrange&quot;, [semitones, cents], channel, {time: options.time}
      );
    });

    return this;

  };

  /**
   * Sends a master tuning message to the specified channel(s). The value is decimal and must be
   * larger than -65 semitones and smaller than 64 semitones.
   *
   * &gt;Because of the way the MIDI specification works, the decimal portion of the value will be
   * &gt;encoded with a resolution of 14bit. The integer portion must be between -64 and 63
   * &gt;inclusively. For those familiar with the MIDI protocol, this function actually generates
   * &gt;**Master Coarse Tuning** and **Master Fine Tuning** RPN messages.
   *
   * @method setMasterTuning
   * @chainable
   *
   * @param [value=0.0] {Number} The desired decimal adjustment value in semitones (-65 &lt; x &lt; 64)
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller
   * than 64.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.setMasterTuning = function(value, channel, options) {

    var that = this;

    options = options || {};

    value = parseFloat(value) || 0.0;

    if (value &lt;= -65 || value &gt;= 64) {
      throw new RangeError(
        &quot;The value must be a decimal number larger than -65 and smaller than 64.&quot;
      );
    }

    var coarse = Math.floor(value) + 64;
    var fine = value - Math.floor(value);

    // Calculate MSB and LSB for fine adjustment (14bit resolution)
    fine = Math.round((fine + 1) / 2 * 16383);
    var msb = (fine &gt;&gt; 7) &amp; 0x7F;
    var lsb = fine &amp; 0x7F;

    wm.toMIDIChannels(channel).forEach(function() {
      that.setRegisteredParameter(&quot;channelcoarsetuning&quot;, coarse, channel, {time: options.time});
      that.setRegisteredParameter(&quot;channelfinetuning&quot;, [msb, lsb], channel, {time: options.time});
    });

    return this;

  };

  /**
   * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the
   * *MIDI Tuning Standard*, which is not widely implemented.
   *
   * @method setTuningProgram
   * @chainable
   *
   * @param value {Number} The desired tuning program (0-127).
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} The program value must be between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.setTuningProgram = function(value, channel, options) {

    var that = this;

    options = options || {};

    value = Math.floor(value);
    if ( !(value &gt;= 0 &amp;&amp; value &lt;= 127) ) {
      throw new RangeError(&quot;The program value must be between 0 and 127&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that.setRegisteredParameter(&quot;tuningprogram&quot;, value, channel, {time: options.time});
    });

    return this;

  };

  /**
   * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the
   * *MIDI Tuning Standard*, which is not widely implemented.
   *
   * @method setTuningBank
   * @chainable
   *
   * @param value {Number} The desired tuning bank (0-127).
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} The bank value must be between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.setTuningBank = function(value, channel, options) {

    var that = this;

    options = options || {};

    value = Math.floor(value) || 0;
    if ( !(value &gt;= 0 &amp;&amp; value &lt;= 127) ) {
      throw new RangeError(&quot;The bank value must be between 0 and 127&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function() {
      that.setRegisteredParameter(&quot;tuningbank&quot;, value, channel, {time: options.time});
    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;channel mode&#x60; message to the specified channel(s). The channel mode message to
   * send can be specified numerically or by using one of the following common names:
   *
   *   * &#x60;allsoundoff&#x60; (#120)
   *   * &#x60;resetallcontrollers&#x60; (#121)
   *   * &#x60;localcontrol&#x60; (#122)
   *   * &#x60;allnotesoff&#x60; (#123)
   *   * &#x60;omnimodeoff&#x60; (#124)
   *   * &#x60;omnimodeon&#x60; (#125)
   *   * &#x60;monomodeon&#x60; (#126)
   *   * &#x60;polymodeon&#x60; (#127)
   *
   * It should be noted that, per the MIDI specification, only &#x60;localcontrol&#x60; and &#x60;monomodeon&#x60; may
   * require a value that&quot;s not zero. For that reason, the &#x60;value&#x60; parameter is optional and
   * defaults to 0.
   *
   * @method sendChannelMode
   * @chainable
   *
   * @param command {Number|String} The numerical identifier of the channel mode message (integer
   * between 120-127) or its name as a string.
   * @param [value=0] {Number} The value to send (integer between 0-127).
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   * @param {Object} [options={}]
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {TypeError} Invalid channel mode message name.
   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.
   * @throws {RangeError} Value must be an integer between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   *
   */
  Output.prototype.sendChannelMode = function(command, value, channel, options) {

    options = options || {};

    if (typeof command === &quot;string&quot;) {

      command = wm.MIDI_CHANNEL_MODE_MESSAGES[command];

      if (!command) {
        throw new TypeError(&quot;Invalid channel mode message name.&quot;);
      }

    } else {

      command = Math.floor(command);

      if ( !(command &gt;= 120 &amp;&amp; command &lt;= 127) ) {
        throw new RangeError(&quot;Channel mode numerical identifiers must be between 120 and 127.&quot;);
      }

    }

    value = Math.floor(value) || 0;

    if (value &lt; 0 || value &gt; 127) {
      throw new RangeError(&quot;Value must be an integer between 0 and 127.&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function(ch) {

      this.send(
        (wm.MIDI_CHANNEL_MESSAGES.channelmode &lt;&lt; 4) + (ch - 1),
        [command, value],
        this._parseTimeParameter(options.time)
      );

    }.bind(this));

    return this;

  };

  /**
   * Sends a MIDI &#x60;program change&#x60; message to the specified channel(s) at the scheduled time.
   *
   * @method sendProgramChange
   * @chainable
   *
   * @param program {Number} The MIDI patch (program) number (0-127)
   *
   * @param [channel=all] {Number|Array|String} The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} Program numbers must be between 0 and 127.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   *
   */
  Output.prototype.sendProgramChange = function(program, channel, options) {

    var that = this;

    options = options || {};

    program = Math.floor(program);
    if (isNaN(program) || program &lt; 0 || program &gt; 127) {
      throw new RangeError(&quot;Program numbers must be between 0 and 127.&quot;);
    }

    wm.toMIDIChannels(channel).forEach(function(ch) {
      that.send(
        (wm.MIDI_CHANNEL_MESSAGES.programchange &lt;&lt; 4) + (ch - 1),
        [program],
        that._parseTimeParameter(options.time)
      );
    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;channel aftertouch&#x60; message to the specified channel(s). For key-specific
   * aftertouch, you should instead use &#x60;sendKeyAftertouch()&#x60;.
   *
   * @method sendChannelAftertouch
   * @chainable
   *
   * @param [pressure=0.5] {Number} The pressure level (between 0 and 1). An invalid pressure value
   * will silently trigger the default behaviour.
   *
   * @param [channel=all] {Number|Array|String}  The MIDI channel number (between 1 and 16) or
   * an array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to
   * all 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendChannelAftertouch = function(pressure, channel, options) {

    var that = this;

    options = options || {};

    pressure = parseFloat(pressure);
    if (isNaN(pressure) || pressure &lt; 0 || pressure &gt; 1) { pressure = 0.5; }

    var nPressure = Math.round(pressure * 127);

    wm.toMIDIChannels(channel).forEach(function(ch) {
      that.send(
        (wm.MIDI_CHANNEL_MESSAGES.channelaftertouch &lt;&lt; 4) + (ch - 1),
        [nPressure],
        that._parseTimeParameter(options.time)
      );
    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;pitch bend&#x60; message to the specified channel(s) at the scheduled time.
   *
   * @method sendPitchBend
   * @chainable
   *
   * @param bend {Number} The intensity level of the bend (between -1 and 1). A value of zero means
   * no bend.
   *
   * @param [channel=all] {Number|Array|String}  The MIDI channel number (between 1 and 16) or an
   * array of channel numbers. If the special value &quot;all&quot; is used, the message will be sent to all
   * 16 channels.
   *
   * @param {Object} [options={}]
   *
   * @param {DOMHighResTimeStamp|String} [options.time=undefined] This value can be one of two
   * things. If the value is a string starting with the + sign and followed by a number, the request
   * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
   * timestamp and the request will be scheduled at that timestamp. The &#x60;DOMHighResTimeStamp&#x60; value
   * is relative to the navigation start of the document. To retrieve the current time, you can use
   * &#x60;WebMidi.time&#x60;. If &#x60;time&#x60; is not present or is set to a time in the past, the request is to be
   * sent as soon as possible.
   *
   * @throws {RangeError} Pitch bend value must be between -1 and 1.
   *
   * @return {Output} Returns the &#x60;Output&#x60; object so methods can be chained.
   */
  Output.prototype.sendPitchBend = function(bend, channel, options) {

    var that = this;

    options = options || {};

    if (isNaN(bend) || bend &lt; -1 || bend &gt; 1) {
      throw new RangeError(&quot;Pitch bend value must be between -1 and 1.&quot;);
    }

    var nLevel = Math.round((bend + 1) / 2 * 16383);
    var msb = (nLevel &gt;&gt; 7) &amp; 0x7F;
    var lsb = nLevel &amp; 0x7F;

    wm.toMIDIChannels(channel).forEach(function(ch) {
      that.send(
        (wm.MIDI_CHANNEL_MESSAGES.pitchbend &lt;&lt; 4) + (ch - 1),
        [lsb, msb],
        that._parseTimeParameter(options.time)
      );
    });

    return this;

  };

  /**
   * Returns a timestamp, relative to the navigation start of the document, derived from the &#x60;time&#x60;
   * parameter. If the parameter is a string starting with the &quot;+&quot; sign and followed by a number,
   * the resulting value will be the sum of the current timestamp plus that number. Otherwise, the
   * value will be returned as is.
   *
   * If the calculated return value is 0, less than zero or an otherwise invalid value, &#x60;undefined&#x60;
   * will be returned.
   *
   * @method _parseTimeParameter
   * @param [time] {Number|String}
   * @return DOMHighResTimeStamp
   * @protected
   */
  Output.prototype._parseTimeParameter = function(time) {

    var value,
      parsed = parseFloat(time);

    if (typeof time === &quot;string&quot; &amp;&amp; time.substring(0, 1) === &quot;+&quot;) {
      if (parsed &amp;&amp; parsed &gt; 0) value = wm.time + parsed;
    } else {
      if (parsed &gt; wm.time) value = parsed;
    }

    return value;

  };

  /**
   * Converts an input value (which can be a uint, a string or an array of the previous two) to an
   * array of MIDI note numbers.
   *
   * @method _convertNoteToArray
   * @param [note] {Number|Array|String}
   * @returns {Array}
   * @protected
   */
  Output.prototype._convertNoteToArray = function(note) {

    var notes = [];

    if ( !Array.isArray(note) ) { note = [note]; }

    note.forEach(function(item) {
      notes.push(wm.guessNoteNumber(item));
    });

    return notes;

  };

  // Check if RequireJS/AMD is used. If it is, use it to define our module instead of
  // polluting the global space.
  if ( typeof define === &quot;function&quot; &amp;&amp; typeof define.amd === &quot;object&quot;) {
    define([], function () {
      return wm;
    });
  } else if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) {
    module.exports = wm;
  } else {
    if (!scope.WebMidi) { scope.WebMidi = wm; }
  }

}(this));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
