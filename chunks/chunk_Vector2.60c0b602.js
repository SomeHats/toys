import{f as m,e as b,g as w,k as M,v as P,c as S,n as A,l as p}from"./chunk_assert.67ae27bf.js";const o={ok(r){return new T(r)},error(r){return new O(r)},collect(r){const t=[];for(const e of r)if(e.isOk())t.push(e.value);else return e;return o.ok(t)}};class g{constructor(){}}class T extends g{constructor(t){super(),this.value=t}isOk(){return!0}isError(){return!1}unwrap(){return this.value}unwrapError(t){m(`${t!=null?t:"expected error"}: ${String(this.value)}`)}map(t){return o.ok(t(this.value))}mapErr(t){return this}andThen(t){return t(this.value)}}class O extends g{constructor(t){super(),this.error=t}isOk(){return!1}isError(){return!0}unwrap(t){m(`${t!=null?t:"expected value"}: ${String(this.error)}`)}unwrapError(t){return this.error}map(t){return this}mapErr(t){return o.error(t(this.error))}andThen(t){return this}}class u{constructor(t,e=[]){this.message=t,this.path=e}formatPath(){let t="ROOT";for(const e of this.path)typeof e=="number"?t+=`[${e}]`:t+=`.${e}`;return t}toString(){return`At ${this.formatPath()}: ${this.message}`}}function E(r){return t=>typeof t===r?o.ok(t):o.error(new u(`Expected ${r}, got ${typeof t}`,[]))}function d(r,t){return new u(r.message,[t,...r.path])}function f(r){if(r===null)return"null";if(Array.isArray(r))return"an array";const t=typeof r;switch(t){case"bigint":case"boolean":case"function":case"number":case"string":case"symbol":return`a ${t}`;case"object":return`an ${t}`;case"undefined":return"undefined";default:S(t)}}const V=E("string"),x=E("number");function q(r){return t=>Array.isArray(t)?o.collect(t.map((e,n)=>r(e).mapErr(a=>d(a,n)))):o.error(new u(`Expected Array, got ${f(t)}`,[]))}function j(r){return t=>typeof t!="object"||t===null?o.error(new u(`Expected object, got ${f(t)}`,[])):o.collect(b(r).map(([e,n])=>n(w(t,e)).map(a=>[e,a]).mapErr(a=>d(a,e)))).map(e=>Object.fromEntries(e))}function I(r,t){return e=>typeof e!="object"||e===null?o.error(new u(`Expected object, got ${f(e)}`,[])):o.collect(M(e).map(n=>r(n).andThen(a=>t(w(e,a)).map(i=>[a,i])).mapErr(a=>d(a,n)))).map(n=>Object.fromEntries(n))}function X(r){const t=new Set(Array.isArray(r)?r:P(r));return e=>{if(t.has(e))return o.ok(e);{const n=typeof e=="string"?`"${e}"`:typeof e=="boolean"||typeof e=="number"?String(e):f(e),a=Array.from(t,i=>typeof i=="string"?`"${i}"`:`${i}`).join(" or ");return o.error(new u(`Expected ${a}, got ${n}`))}}}function k(r,t){return e=>r(e).andThen(t)}const s=class{constructor(r,t){this.x=r,this.y=t}static fromPolar(r,t){return new s(t*Math.cos(r),t*Math.sin(r))}static average(r){return r.reduce((e,n)=>e.add(n),s.ZERO).div(r.length)}static fromVectorLike({x:r,y:t}){return new s(r,t)}static fromEvent({clientX:r,clientY:t}){return new s(r,t)}toString(r){return`Vector2(${r==null?this.x:this.x.toFixed(r)}, ${r==null?this.y:this.y.toFixed(r)})`}get magnitudeSquared(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.magnitudeSquared)}get angle(){return Math.atan2(this.y,this.x)}isInPolygon(r){const{x:t,y:e}=this;let n=!1;for(let a=0,i=r.length-1;a<r.length;i=a++){const{x:l,y:c}=r[a],{x:$,y}=r[i];c>e!=y>e&&t<($-l)*(e-c)/(y-c)+l&&(n=!n)}return n}equals(r){return this===r||this.x===r.x&&this.y===r.y}distanceTo({x:r,y:t}){return Math.hypot(this.x-r,this.y-t)}distanceToSq({x:r,y:t}){const e=this.x-r,n=this.y-t;return e*e+n*n}angleTo(r){return r.sub(this).angle}angleBetween(r){return A(Math.atan2(r.y,r.x)-Math.atan2(this.y,this.x))}dot(r){return this.x*r.x+this.y*r.y}div(r){return new s(this.x/r,this.y/r)}scale(r){return new s(this.x*r,this.y*r)}negate(){return this.scale(-1)}add({x:r,y:t}){return new s(this.x+r,this.y+t)}sub({x:r,y:t}){return new s(this.x-r,this.y-t)}floor(){return new s(Math.floor(this.x),Math.floor(this.y))}ceil(){return new s(Math.ceil(this.x),Math.ceil(this.y))}round(){return new s(Math.round(this.x),Math.round(this.y))}withMagnitude(r){return s.fromPolar(this.angle,r)}normalize(){return this.withMagnitude(1)}withAngle(r){return s.fromPolar(r,this.magnitude)}rotate(r){return this.withAngle(this.angle+r)}rotateAround(r,t){const e=Math.sin(t),n=Math.cos(t),a=this.x-r.x,i=this.y-r.y,l=a*n-i*e,c=a*e+i*n;return new s(l+r.x,c+r.y)}lerp(r,t){return new s(p(this.x,r.x,t),p(this.y,r.y,t))}perpendicular(){return new s(this.y,-this.x)}project(r,t){return r.scale(t).add(this)}};let h=s;h.ZERO=new s(0,0);h.UNIT=new s(1,1);h.X=new s(1,0);h.Y=new s(0,1);h.parse=k(j({x,y:x}),({x:r,y:t})=>o.ok(new s(r,t)));export{u as P,o as R,h as V,q as a,k as b,j as c,V as d,I as e,X as f,x as p};
