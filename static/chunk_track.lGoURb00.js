var H=Object.defineProperty;var $=(e,t,s)=>t in e?H(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var i=(e,t,s)=>($(e,typeof t!="symbol"?t+"":t,s),s);import{R as g,r as _}from"./chunk_index.V9mWGg2B.js";const L=8;class q{constructor(){i(this,"arraySize",0);i(this,"array",Array(L));i(this,"set",null)}get isEmpty(){if(this.array)return this.arraySize===0;if(this.set)return this.set.size===0;throw new Error("no set or array")}add(t){if(this.array)return this.array.indexOf(t)!==-1?!1:this.arraySize<L?(this.array[this.arraySize]=t,this.arraySize++,!0):(this.set=new Set(this.array),this.array=null,this.set.add(t),!0);if(this.set)return this.set.has(t)?!1:(this.set.add(t),!0);throw new Error("no set or array")}remove(t){if(this.array){const s=this.array.indexOf(t);return s===-1?!1:(this.array[s]=void 0,this.arraySize--,s!==this.arraySize&&(this.array[s]=this.array[this.arraySize],this.array[this.arraySize]=void 0),!0)}if(this.set)return this.set.has(t)?(this.set.delete(t),!0):!1;throw new Error("no set or array")}visit(t){if(this.array){for(let s=0;s<this.arraySize;s++){const r=this.array[s];typeof r<"u"&&t(r)}return}if(this.set){this.set.forEach(t);return}throw new Error("no set or array")}}function z(e){return e&&typeof e=="object"&&"parents"in e}function k(e){for(let t=0,s=e.parents.length;t<s;t++)if(e.parents[t].__unsafe__getWithoutCapture(),e.parents[t].lastChangedEpoch!==e.parentEpochs[t])return!0;return!1}const p=(e,t)=>{if(e.children.remove(t)&&e.children.isEmpty&&z(e))for(let s=0,r=e.parents.length;s<r;s++)p(e.parents[s],e)},R=(e,t)=>{if(e.children.add(t)&&z(e))for(let s=0,r=e.parents.length;s<r;s++)R(e.parents[s],e)};function O(e,t){return e===t||Object.is(e,t)||!!(e&&t&&typeof e.equals=="function"&&e.equals(t))}const V=Object.freeze([]),P=Symbol.for("__@tldraw/state__"),T=globalThis;T[P]?console.error('Multiple versions of @tldraw/state detected. This will cause unexpected behavior. Please add "resolutions" (yarn/pnpm) or "overrides" (npm) in your package.json to ensure only one version of @tldraw/state is loaded.'):T[P]=!0;class G{constructor(t,s){i(this,"offset",0);i(this,"numNewParents",0);i(this,"maybeRemoved");this.below=t,this.child=s}}let a=null;function I(e){a=new G(a,e)}function N(){const e=a;if(a=e.below,e.numNewParents>0||e.offset!==e.child.parents.length){for(let s=e.offset;s<e.child.parents.length;s++){const r=e.child.parents[s];e.child.parents.indexOf(r)>=e.offset&&p(r,e.child)}if(e.child.parents.length=e.offset,e.child.parentEpochs.length=e.offset,a!=null&&a.maybeRemoved)for(let s=0;s<a.maybeRemoved.length;s++){const r=a.maybeRemoved[s];e.child.parents.indexOf(r)===-1&&p(r,e.child)}}}function v(e){if(a){const t=a.child.parents.indexOf(e);if(t<0&&(a.numNewParents++,a.child.isActivelyListening&&R(e,a.child)),t<0||t>=a.offset){if(t!==a.offset&&t>0){const s=a.child.parents[a.offset];a.maybeRemoved?a.maybeRemoved.indexOf(s)===-1&&a.maybeRemoved.push(s):a.maybeRemoved=[s]}a.child.parents[a.offset]=e,a.child.parentEpochs[a.offset]=e.lastChangedEpoch,a.offset++}}}const d=Symbol("RESET_VALUE");class M{constructor(t){i(this,"index",0);i(this,"buffer");this.capacity=t,this.buffer=new Array(t)}pushEntry(t,s,r){if(r!==void 0){if(r===d){this.clear();return}this.buffer[this.index]=[t,s,r],this.index=(this.index+1)%this.capacity}}clear(){this.index=0,this.buffer.fill(void 0)}getChangesSince(t){const{index:s,capacity:r,buffer:n}=this;for(let h=0;h<r;h++){const f=(s-1+r-h)%r,y=n[f];if(!y)return d;const[m,w]=y;if(h===0&&t>=w)return[];if(m<=t&&t<w){const l=h+1,x=new Array(l);for(let E=0;E<l;E++)x[E]=n[(f+E)%r][2];return x}}return d}}const o=-1;let c=o+1,b=!1;function U(){c++}class Y{constructor(t){i(this,"initialAtomValues",new Map);this.parent=t}get isRoot(){return this.parent===null}commit(){if(this.isRoot){const t=this.initialAtomValues;this.initialAtomValues=new Map,W(t.keys())}else this.initialAtomValues.forEach((t,s)=>{this.parent.initialAtomValues.has(s)||this.parent.initialAtomValues.set(s,t)})}abort(){c++,this.initialAtomValues.forEach((t,s)=>{var r;s.set(t),(r=s.historyBuffer)==null||r.clear()}),this.commit()}}function W(e){if(b)throw new Error("cannot change atoms during reaction cycle");try{b=!0;const t=new Set,s=r=>{r.lastTraversedEpoch!==c&&(r.lastTraversedEpoch=c,"maybeScheduleEffect"in r?t.add(r):r.children.visit(s))};for(const r of e)r.children.visit(s);for(const r of t)r.maybeScheduleEffect()}finally{b=!1}}function Z(e,t){u?u.initialAtomValues.has(e)||u.initialAtomValues.set(e,t):W([e])}let u=null;function F(e){const t=new Y(u);u=t;try{let s=!1;const r=e(()=>s=!0);return s?t.abort():t.commit(),r}catch(s){throw t.abort(),s}finally{u=u.parent}}function st(e){return u?e():F(e)}class K{constructor(t,s,r){i(this,"isEqual");i(this,"computeDiff");i(this,"lastChangedEpoch",c);i(this,"children",new q);i(this,"historyBuffer");this.name=t,this.current=s,this.isEqual=(r==null?void 0:r.isEqual)??null,r&&(r.historyLength&&(this.historyBuffer=new M(r.historyLength)),this.computeDiff=r.computeDiff)}__unsafe__getWithoutCapture(){return this.current}get value(){return v(this),this.current}set(t,s){var n,h;if(((n=this.isEqual)==null?void 0:n.call(this,this.current,t))??O(this.current,t))return this.current;U(),this.historyBuffer&&this.historyBuffer.pushEntry(this.lastChangedEpoch,c,s??((h=this.computeDiff)==null?void 0:h.call(this,this.current,t,this.lastChangedEpoch,c))??d),this.lastChangedEpoch=c;const r=this.current;return this.current=t,Z(this,r),t}update(t){return this.set(t(this.current))}getDiffSince(t){var s;return v(this),t>=this.lastChangedEpoch?V:((s=this.historyBuffer)==null?void 0:s.getChangesSince(t))??d}}function rt(e,t,s){return new K(e,t,s)}const S=Symbol("UNINITIALIZED"),it=e=>e===S;class C{constructor(t,s){this.value=t,this.diff=s}}function at(e,t){return new C(e,t)}class j{constructor(t,s,r){i(this,"lastChangedEpoch",o);i(this,"lastTraversedEpoch",o);i(this,"lastCheckedEpoch",o);i(this,"parents",[]);i(this,"parentEpochs",[]);i(this,"children",new q);i(this,"historyBuffer");i(this,"state",S);i(this,"computeDiff");i(this,"isEqual");this.name=t,this.derive=s,r!=null&&r.historyLength&&(this.historyBuffer=new M(r.historyLength)),this.computeDiff=r==null?void 0:r.computeDiff,this.isEqual=(r==null?void 0:r.isEqual)??O}get isActivelyListening(){return!this.children.isEmpty}__unsafe__getWithoutCapture(){var s;const t=this.lastChangedEpoch===o;if(!t&&(this.lastCheckedEpoch===c||!k(this)))return this.lastCheckedEpoch=c,this.state;try{I(this);const r=this.derive(this.state,this.lastCheckedEpoch),n=r instanceof C?r.value:r;if(this.state===S||!this.isEqual(n,this.state)){if(this.historyBuffer&&!t){const h=r instanceof C?r.diff:void 0;this.historyBuffer.pushEntry(this.lastChangedEpoch,c,h??((s=this.computeDiff)==null?void 0:s.call(this,this.state,n,this.lastCheckedEpoch,c))??d)}this.lastChangedEpoch=c,this.state=n}return this.lastCheckedEpoch=c,this.state}finally{N()}}get value(){const t=this.__unsafe__getWithoutCapture();return v(this),t}getDiffSince(t){var s;return this.value,t>=this.lastChangedEpoch?V:((s=this.historyBuffer)==null?void 0:s.getChangesSince(t))??d}}function D(e={},t,s,r){const n=r.get,h=Symbol.for("__@tldraw/state__computed__"+s);return r.get=function(){let f=this[h];return f||(f=new j(s,n.bind(this),e),Object.defineProperty(this,h,{enumerable:!1,configurable:!1,writable:!1,value:f})),f.value},r}function nt(){if(arguments.length===1){const e=arguments[0];return(t,s,r)=>D(e,t,s,r)}else return typeof arguments[0]=="string"?new j(arguments[0],arguments[1],arguments[2]):D(void 0,arguments[0],arguments[1],arguments[2])}class A{constructor(t,s,r){i(this,"_isActivelyListening",!1);i(this,"lastTraversedEpoch",o);i(this,"lastReactedEpoch",o);i(this,"_scheduleCount",0);i(this,"parentEpochs",[]);i(this,"parents",[]);i(this,"_scheduleEffect");i(this,"maybeExecute",()=>{this._isActivelyListening&&this.execute()});this.name=t,this.runEffect=s,this._scheduleEffect=r==null?void 0:r.scheduleEffect}get isActivelyListening(){return this._isActivelyListening}get scheduleCount(){return this._scheduleCount}maybeScheduleEffect(){if(this._isActivelyListening&&this.lastReactedEpoch!==c){if(this.parents.length&&!k(this)){this.lastReactedEpoch=c;return}this.scheduleEffect()}}scheduleEffect(){this._scheduleCount++,this._scheduleEffect?this._scheduleEffect(this.maybeExecute):this.execute()}attach(){this._isActivelyListening=!0;for(let t=0,s=this.parents.length;t<s;t++)R(this.parents[t],this)}detach(){this._isActivelyListening=!1;for(let t=0,s=this.parents.length;t<s;t++)p(this.parents[t],this)}execute(){try{I(this);const t=this.runEffect(this.lastReactedEpoch);return this.lastReactedEpoch=c,t}finally{N()}}}function ht(e,t,s){const r=new A(e,t,s);return r.attach(),r.scheduleEffect(),()=>{r.detach()}}function ct(e,t,s){const r=new A(e,t,s);return{scheduler:r,start:n=>{const h=(n==null?void 0:n.force)??!1;r.attach(),h?r.scheduleEffect():r.maybeScheduleEffect()},stop:()=>{r.detach()}}}function J(e,t){const s=g.useRef(t);s.current=t;const[r,n,h]=g.useMemo(()=>{let f=null;const y=l=>(f=l,()=>{f=null}),m=new A(`useStateTracking(${e})`,()=>{var l;return(l=s.current)==null?void 0:l.call(s)},{scheduleEffect(){f==null||f()}});return[m,y,()=>m.scheduleCount]},[e]);return g.useSyncExternalStore(n,h,h),g.useEffect(()=>(r.attach(),r.maybeScheduleEffect(),()=>{r.detach()}),[r]),r.execute()}const B={apply(e,t,s){return J(e.displayName??e.name??"tracked(???)",()=>e.apply(t,s))}},Q=Symbol.for("react.memo"),X=Symbol.for("react.forward_ref");function ft(e){let t=null;const s=e.$$typeof;return s===Q&&(e=e.type,t=e.compare),s===X?_.memo(_.forwardRef(new Proxy(e.render,B))):_.memo(new Proxy(e,B),t)}export{V as E,d as R,rt as a,st as b,nt as c,ct as d,it as i,ht as r,ft as t,at as w};
