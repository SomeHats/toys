{"mappings":"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","sources":["src/lib/fakeConsole.ts","src/blob-tree/traceBlobTree.tsx","src/blob-tree/BlobTreeEditor.tsx","src/blob-tree/canvas.ts","src/lib/IdGenerator.tsx","src/blob-tree/BlobTree.tsx","src/blob-tree/blob-tree-main.tsx"],"sourcesContent":["import { profile } from 'console';\nimport { NoToneMapping } from 'three';\nimport { noop } from './utils';\n\nexport const fakeConsole: Console = {\n  assert: noop,\n  clear: noop,\n  count: noop,\n  countReset: noop,\n  debug: noop,\n  dir: noop,\n  dirxml: noop,\n  error: noop,\n  group: noop,\n  groupCollapsed: noop,\n  groupEnd: noop,\n  info: noop,\n  log: noop,\n  table: noop,\n  time: noop,\n  timeEnd: noop,\n  timeLog: noop,\n  timeStamp: noop,\n  trace: noop,\n  warn: noop,\n  profile: noop,\n  profileEnd: noop,\n  Console: console.Console,\n};\n","import { assert } from '../lib/assert';\nimport { DebugDraw } from '../lib/DebugDraw';\nimport { fakeConsole } from '../lib/fakeConsole';\nimport Vector2 from '../lib/geom/Vector2';\nimport { constrainWrapped, indexed, sortBy } from '../lib/utils';\nimport { BlobTree, BlobTreeNode } from './BlobTree';\n\n// interface TracerInterface {\n//   moveTo(x: number, y: number);\n//   quadraticCurveTo(cpx: number, cpy: number, x: number, y: number);\n// }\n\nconst TENSION = 0.2;\n\nexport function traceBlobTree(\n  blobTree: BlobTree,\n  debugDraw: DebugDraw,\n  console = fakeConsole,\n) {\n  for (const rootNode of blobTree.iterateRootNodes()) {\n    traceBlobTreeRoot(blobTree, rootNode, debugDraw, console);\n  }\n}\n\nexport function traceBlobTreeRoot(\n  tree: BlobTree,\n  root: BlobTreeNode,\n  debugDraw: DebugDraw,\n  console = fakeConsole,\n) {\n  const prevNode = root;\n  const node: BlobTreeNode | undefined = Array.from(\n    tree.iterateChildNodes(root),\n  )[0];\n  const nextNode = node\n    ? Array.from(tree.iterateChildNodes(node))[0]\n    : undefined;\n\n  if (!prevNode || !node || !nextNode) {\n    return;\n  }\n\n  const prevCircle = prevNode.toCircle();\n  const circle = node.toCircle();\n  const nextCircle = nextNode.toCircle();\n\n  const prevTangents = prevCircle.outerTangentsWith(circle);\n  const nextTangents = circle.outerTangentsWith(nextCircle);\n\n  if (!prevTangents || !nextTangents) {\n    return;\n  }\n\n  const incomingTangentAtNode = prevTangents[0];\n  const outgoingTangentAtNode = nextTangents[0];\n  debugDraw.debugLine2(incomingTangentAtNode, { color: 'lime' });\n  debugDraw.debugLine2(outgoingTangentAtNode, { color: 'lime' });\n  const tangentIntersection = incomingTangentAtNode.pointAtIntersectionWith(\n    outgoingTangentAtNode,\n  );\n  const connectionNormal = circle.center.angleTo(tangentIntersection);\n  const connectionPoint =\n    incomingTangentAtNode.isPointWithinBounds(tangentIntersection) &&\n    outgoingTangentAtNode.isPointWithinBounds(tangentIntersection)\n      ? tangentIntersection\n      : circle.pointOnCircumference(connectionNormal);\n\n  debugDraw.debugPointX(connectionPoint);\n\n  const startPoint = incomingTangentAtNode.start;\n  const endPoint = connectionPoint;\n  const startDerivative = incomingTangentAtNode.start\n    .lerp(incomingTangentAtNode.end, TENSION)\n    .sub(startPoint);\n  const endDerivative = Vector2.fromPolar(\n    connectionNormal + Math.PI / 2,\n    incomingTangentAtNode.length * TENSION,\n  );\n  debugDraw.debugVectorAtPoint(startDerivative, startPoint);\n  debugDraw.debugVectorAtPoint(endDerivative, endPoint);\n\n  debugDraw.debugBezierCurve(\n    startPoint,\n    startPoint.add(startDerivative),\n    endPoint.sub(endDerivative),\n    endPoint,\n  );\n}\n\n// export function traceBlobTreeRoot(\n//   tree: BlobTree,\n//   root: BlobTreeNode,\n//   debugDraw: DebugDraw,\n//   console = fakeConsole,\n// ) {\n//   console.group('traceBlobTreeRoot');\n//   console.log({ tree, root });\n//   function traceNode(node: BlobTreeNode, prevTangent?: Vector2) {\n//     console.group('traceNode');\n//     console.log({ node });\n//     const nodeCircle = node.toCircle();\n\n//     const parentNode = tree.getNodeParentIfExists(node);\n//     const parentAngle = parentNode\n//       ? node.position.angleTo(parentNode.position)\n//       : 0;\n//     const children = sortBy(Array.from(tree.iterateChildNodes(node)), (child) =>\n//       constrainWrapped(\n//         0,\n//         Math.PI * 2,\n//         node.position.angleTo(child.position) - parentAngle,\n//       ),\n//     );\n\n//     let last = parentNode;\n//     let incomingTangent = prevTangent;\n//     for (const [index, child] of indexed(children)) {\n//       const childTangents = nodeCircle.outerTangentsWith(child.toCircle());\n//       if (!childTangents) continue;\n//       debugDraw.debugPolyLine([childTangents[0].start, childTangents[0].end], {\n//         color: 'lime',\n//         label: String(index),\n//       });\n\n//       const lastTangents = last?.toCircle().outerTangentsWith(nodeCircle);\n//       console.log(lastTangents);\n//       if (lastTangents) {\n//         const t1 = lastTangents[0];\n//         const t2 = childTangents[0];\n//         const angleToLineNormal = nodeCircle.center.angleTo(\n//           t1.pointAtIntersectionWith(t2),\n//         );\n//         const targetPoint = nodeCircle.pointOnCircumference(angleToLineNormal);\n//         debugDraw.debugPointX(targetPoint);\n//         const cp1 = targetPoint.add(\n//           Vector2.fromPolar(angleToLineNormal - Math.PI / 2, t1.length * 0.3),\n//         );\n//         debugDraw.debugPointX(cp1);\n//         if (prevTangent) {\n//           debugDraw.debugPointX(prevTangent, { color: 'cyan' });\n//         }\n//       }\n\n//       traceNode(child);\n//       last = child;\n//     }\n//     console.groupEnd();\n//   }\n\n//   traceNode(root);\n//   console.groupEnd();\n// }\n","import { fail } from '../lib/assert';\nimport { DebugDraw } from '../lib/DebugDraw';\nimport Vector2 from '../lib/geom/Vector2';\nimport { exhaustiveSwitchError } from '../lib/utils';\nimport { BlobTree, BlobTreeNode } from './BlobTree';\nimport { traceBlobTree } from './traceBlobTree';\n\ntype EditorState =\n  | {\n      type: 'idle';\n    }\n  | {\n      type: 'createNode';\n      node: BlobTreeNode;\n    }\n  | {\n      type: 'selectedIdle';\n      node: BlobTreeNode;\n    }\n  | {\n      type: 'moveNode';\n      node: BlobTreeNode;\n      offset: Vector2;\n    }\n  | {\n      type: 'resizeNode';\n      node: BlobTreeNode;\n      offset: number;\n    };\n\ntype HoverMode = 'center' | 'edge';\nconst HOVER_EDGE_SIZE = 6;\n\nexport class BlobTreeEditor {\n  private mousePosition = Vector2.ZERO;\n  private state: EditorState = { type: 'idle' };\n\n  constructor(\n    private readonly canvas: DebugDraw,\n    public readonly blobTree: BlobTree,\n  ) {}\n\n  private getSelectedNode() {\n    switch (this.state.type) {\n      case 'idle':\n        return null;\n      case 'createNode':\n      case 'selectedIdle':\n      case 'moveNode':\n      case 'resizeNode':\n        return this.state.node;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n  private getHover(): null | { node: BlobTreeNode; mode: HoverMode } {\n    let nearestNode = null;\n    let nearestDistance = Infinity;\n    for (const node of this.blobTree.iterateNodes()) {\n      const distance = node.position.distanceTo(this.mousePosition);\n      if (distance > node.radius + HOVER_EDGE_SIZE) {\n        continue;\n      }\n      if (distance < nearestDistance) {\n        nearestDistance = distance;\n        nearestNode = node;\n      }\n    }\n\n    if (!nearestNode) {\n      return null;\n    }\n\n    const hoverEdgeSize = Math.min(nearestNode.radius * 0.1, HOVER_EDGE_SIZE);\n    return {\n      node: nearestNode,\n      mode:\n        nearestDistance < nearestNode.radius - hoverEdgeSize\n          ? 'center'\n          : 'edge',\n    };\n  }\n\n  onMouseMove(position: Vector2) {\n    this.mousePosition = position;\n  }\n\n  onMouseDown(position: Vector2) {\n    switch (this.state.type) {\n      case 'idle':\n      case 'selectedIdle': {\n        const hover = this.getHover();\n        if (hover) {\n          switch (hover.mode) {\n            case 'center':\n              this.state = {\n                type: 'moveNode',\n                node: hover.node,\n                offset: hover.node.position.sub(this.mousePosition),\n              };\n              return;\n            case 'edge':\n              this.state = {\n                type: 'resizeNode',\n                node: hover.node,\n                offset:\n                  hover.node.radius -\n                  hover.node.position.distanceTo(this.mousePosition),\n              };\n              return;\n            default:\n              exhaustiveSwitchError(hover.mode);\n          }\n        }\n        this.state = {\n          type: 'createNode',\n          node:\n            this.state.type === 'idle'\n              ? this.blobTree.createNewRoot(position, 1)\n              : this.blobTree.createNewChild(this.state.node, position, 1),\n        };\n        return;\n      }\n      case 'selectedIdle':\n        this.state = {\n          type: 'createNode',\n          node: this.blobTree.createNewChild(this.state.node, position, 1),\n        };\n        return;\n      case 'createNode':\n      case 'moveNode':\n      case 'resizeNode':\n        return;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n\n  onMouseUp(position: Vector2) {\n    switch (this.state.type) {\n      case 'idle':\n      case 'selectedIdle':\n        return;\n      case 'createNode':\n      case 'moveNode':\n      case 'resizeNode':\n        this.state = { type: 'selectedIdle', node: this.state.node };\n        return;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n\n  onKeyDown(key: string) {\n    console.log(key);\n    if (key === ' ') {\n      traceBlobTree(this.blobTree, this.canvas, console);\n    }\n  }\n\n  tick() {\n    switch (this.state.type) {\n      case 'idle':\n        return;\n      case 'createNode':\n        this.state.node.radius = this.state.node.position.distanceTo(\n          this.mousePosition,\n        );\n        return;\n      case 'moveNode':\n        this.state.node.position = this.mousePosition.add(this.state.offset);\n        return;\n      case 'resizeNode':\n        this.state.node.radius =\n          this.mousePosition.distanceTo(this.state.node.position) +\n          this.state.offset;\n      case 'selectedIdle':\n        return;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n\n  draw() {\n    this.canvas.clear();\n\n    const selectedNode = this.getSelectedNode();\n    const hover = this.getHover();\n\n    this.canvas.beginPath();\n    traceBlobTree(this.blobTree, this.canvas);\n    // this.canvas.stroke({\n    //   stroke: 'rgba(255, 255, 255, 0.6)',\n    //   strokeWidth: 10,\n    // });\n\n    for (const node of this.blobTree.iterateNodes()) {\n      const style =\n        node === this.getSelectedNode()\n          ? { stroke: 'lime', strokeWidth: 2 }\n          : node === hover?.node\n          ? { stroke: 'lime', strokeWidth: 1 }\n          : { stroke: 'magenta', strokeWidth: 1 };\n      this.canvas.circle(node.position, node.radius, style);\n\n      for (const child of this.blobTree.iterateChildNodes(node)) {\n        this.canvas.polyLine([node.position, child.position], {\n          stroke: 'cyan',\n          strokeWidth: 1,\n        });\n      }\n    }\n  }\n}\n","import { DebugDraw } from '../lib/DebugDraw';\n\nexport const canvasEl = document.createElement('canvas');\nexport const ctx = canvasEl.getContext('2d')!;\nexport const width = document.body.clientWidth;\nexport const height = document.body.clientHeight;\nexport const scale = window.devicePixelRatio;\n\ncanvasEl.width = width * scale;\ncanvasEl.height = height * scale;\ncanvasEl.style.width = `${width}px`;\ncanvasEl.style.height = `${height}px`;\nctx.scale(scale, scale);\nexport const canvas = new DebugDraw(ctx);\ndocument.body.appendChild(canvasEl);\n","export class IdGenerator {\n  private number = 0;\n  constructor(private readonly prefix: string) {}\n\n  next() {\n    return `${this.prefix}${this.number++}`;\n  }\n}\n","import { assert } from '../lib/assert';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { IdGenerator } from '../lib/IdGenerator';\n\nexport class BlobTreeNode {\n  private static readonly ids = new IdGenerator('BlobTreeNode');\n\n  static create(position: Vector2, radius: number): BlobTreeNode {\n    return new BlobTreeNode(BlobTreeNode.ids.next(), position, radius);\n  }\n\n  constructor(\n    readonly id: string,\n    public position: Vector2,\n    public radius: number,\n  ) {}\n\n  toCircle(): Circle {\n    return new Circle(this.position, this.radius);\n  }\n}\n\nexport class BlobTree {\n  private nodesById = new Map<string, BlobTreeNode>();\n  private childrenById = new Map<string, Array<string>>();\n  private parentById = new Map<string, string>();\n\n  constructor() {}\n\n  getNodeByIdIfExists(id: string): BlobTreeNode | undefined {\n    return this.nodesById.get(id);\n  }\n  getNodeById(id: string): BlobTreeNode {\n    const node = this.getNodeByIdIfExists(id);\n    assert(node);\n    return node;\n  }\n\n  getNodeParentIfExists(node: BlobTreeNode): BlobTreeNode | undefined {\n    const parentId = this.parentById.get(node.id);\n    if (!parentId) {\n      return undefined;\n    }\n    return this.getNodeById(parentId);\n  }\n\n  private getMutableChildIds(node: BlobTreeNode) {\n    let childIds = this.childrenById.get(node.id);\n    if (!childIds) {\n      childIds = [];\n      this.childrenById.set(node.id, childIds);\n    }\n    return childIds;\n  }\n\n  createNewRoot(position: Vector2, radius: number): BlobTreeNode {\n    const node = BlobTreeNode.create(position, radius);\n    this.nodesById.set(node.id, node);\n    return node;\n  }\n  createNewChild(\n    parent: BlobTreeNode,\n    position: Vector2,\n    radius: number,\n  ): BlobTreeNode {\n    const node = BlobTreeNode.create(position, radius);\n    this.nodesById.set(node.id, node);\n    this.parentById.set(node.id, parent.id);\n    this.getMutableChildIds(parent).push(node.id);\n    return node;\n  }\n\n  *iterateNodes() {\n    for (const node of this.nodesById.values()) {\n      yield node;\n    }\n  }\n  *iterateChildNodes(parent: BlobTreeNode) {\n    for (const childId of this.childrenById.get(parent.id) ?? []) {\n      yield this.getNodeById(childId);\n    }\n  }\n  *iterateRootNodes() {\n    for (const node of this.nodesById.values()) {\n      if (!this.getNodeParentIfExists(node)) {\n        yield node;\n      }\n    }\n  }\n}\n","import { BlobTreeEditor } from './BlobTreeEditor';\nimport { frameLoop } from '../lib/utils';\nimport { canvas } from './canvas';\nimport { BlobTree } from './BlobTree';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst editor = new BlobTreeEditor(canvas, new BlobTree());\n\ndocument.addEventListener('mousemove', (event) => {\n  editor.onMouseMove(new Vector2(event.clientX, event.clientY));\n});\ndocument.addEventListener('mousedown', (event) => {\n  editor.onMouseDown(new Vector2(event.clientX, event.clientY));\n});\ndocument.addEventListener('mouseup', (event) => {\n  editor.onMouseUp(new Vector2(event.clientX, event.clientY));\n});\ndocument.addEventListener('keydown', (event) => {\n  editor.onKeyDown(event.key);\n});\n\nframeLoop(() => {\n  editor.tick();\n  editor.draw();\n});\n\nif ((module as any).hot) {\n  (module as any).hot.dispose(() => window.location.reload());\n}\n"],"names":["$e9ac485245e0eae4$export$fd2b1208638d84fa","assert","noop","clear","$8qLe2","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","profile","profileEnd","Console","console","$e0c4b586d7c2e529$export$64151648616ed69e","blobTree","debugDraw","param","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterateRootNodes","Symbol","iterator","next","done","$e0c4b586d7c2e529$export$b3a9c7999facdccc","value","err","return","tree","root","prevNode","node","Array","from","iterateChildNodes","nextNode","prevCircle","toCircle","circle","nextCircle","prevTangents","outerTangentsWith","nextTangents","incomingTangentAtNode","outgoingTangentAtNode","debugLine2","color","tangentIntersection","pointAtIntersectionWith","connectionNormal","center","angleTo","connectionPoint","isPointWithinBounds","pointOnCircumference","debugPointX","startPoint","start","endPoint","startDerivative","lerp","end","sub","endDerivative","$39Hjj","default","fromPolar","Math","PI","length","debugVectorAtPoint","debugBezierCurve","add","$fdb68cf6d60c721f$export$eae5d42140f0c66c","canvas","this","mousePosition","ZERO","state","type","key","exhaustiveSwitchError","nearestNode","nearestDistance","Infinity","iterateNodes","distance","position","distanceTo","radius","hoverEdgeSize","min","mode","hover","getHover","offset","createNewRoot","createNewChild","getSelectedNode","beginPath","style","stroke","strokeWidth","_iteratorNormalCompletion1","_didIteratorError1","_iteratorError1","_step1","_iterator1","child","polyLine","$5fd77a6bb584c720$export$38c8a1558598a89e","document","createElement","$5fd77a6bb584c720$export$39f92e86d1722f3a","getContext","$5fd77a6bb584c720$export$7e3df82ee760448c","body","clientWidth","$5fd77a6bb584c720$export$ac607276a8fe9f0a","clientHeight","$5fd77a6bb584c720$export$dcdf75081b88279d","window","devicePixelRatio","width","height","concat","scale","$5fd77a6bb584c720$export$67ea982130081db","$aCcLp","DebugDraw","appendChild","$2687d5888bfdc6c8$export$9a37b8e73fa34e75","prefix","number","$834e42c4db3b4b07$export$b9cbe4a3eefb3140","id","$eJCSX","ids","$834e42c4db3b4b07$export$9d56991d5c7765da","nodesById","Map","childrenById","parentById","get","getNodeByIdIfExists","$8OvEy","parentId","getNodeById","childIds","set","create","parent","getMutableChildIds","push","_ctx","values","t0","ref","childId","getNodeParentIfExists","$6964682745d34772$var$editor","addEventListener","event","onMouseMove","clientX","clientY","onMouseDown","onMouseUp","onKeyDown","frameLoop","tick","draw"],"version":3,"file":"index.dcc86dfa.js.map"}