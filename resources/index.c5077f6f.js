function t(t,i,e){return(i-t)*e+t}function i(t,i){const e=new Set(t),s=new Set;for(const t of i)e.has(t)&&s.add(t);return Array.from(s)}function e(t=""){return`${t}${Math.random().toString(36).slice(1)}`}class s{static fromPolar(t,i){return new s(i*Math.cos(t),i*Math.sin(t))}static average(t){return t.reduce(((t,i)=>t.add(i)),s.ZERO).div(t.length)}static fromVectorLike({x:t,y:i}){return new s(t,i)}toString(){return`Vector2(${this.x}, ${this.y})`}get magnitudeSquared(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.magnitudeSquared)}get angle(){return Math.atan2(this.y,this.x)}isInPolygon(t){const{x:i,y:e}=this;let s=!1;for(let n=0,o=t.length-1;n<t.length;o=n++){const{x:r,y:h}=t[n],{x:l,y:a}=t[o];h>e!=a>e&&i<(l-r)*(e-h)/(a-h)+r&&(s=!s)}return s}equals(t){return this===t||this.x===t.x&&this.y===t.y}distanceTo({x:t,y:i}){const e=t-this.x,s=i-this.y;return Math.sqrt(e*e+s*s)}angleTo(t){return t.sub(this).angle}angleBetween(t){return i=Math.atan2(t.y,t.x)-Math.atan2(this.y,this.x),function(t,i,e){const s=i-t;for(e-=t;e<0;)e+=s;return t+e%s}(-Math.PI,Math.PI,i);var i}dot(t){return this.x*t.x+this.y*t.y}div(t){return new s(this.x/t,this.y/t)}scale(t){return new s(this.x*t,this.y*t)}negate(){return this.scale(-1)}add({x:t,y:i}){return new s(this.x+t,this.y+i)}sub({x:t,y:i}){return new s(this.x-t,this.y-i)}floor(){return new s(Math.floor(this.x),Math.floor(this.y))}ceil(){return new s(Math.ceil(this.x),Math.ceil(this.y))}round(){return new s(Math.round(this.x),Math.round(this.y))}withMagnitude(t){return s.fromPolar(this.angle,t)}normalize(){return this.withMagnitude(1)}withAngle(t){return s.fromPolar(t,this.magnitude)}rotate(t){return this.withAngle(this.angle+t)}lerp(i,e){return new s(t(this.x,i.x,e),t(this.y,i.y,e))}constructor(t,i){this.x=t,this.y=i}}s.ZERO=new s(0,0);const n=new s(5,0),o=.75*Math.PI;const r=document.createElement("canvas"),h=r.getContext("2d"),l=document.body.clientWidth,a=document.body.clientHeight,u=window.devicePixelRatio;r.width=l*u,r.height=a*u,r.style.width=`${l}px`,r.style.height=`${a}px`,h.scale(u,u);const d=new class{clear(t){t?(this.applyFillOptions({fill:t}),this.ctx.fillRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height)):this.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height)}beginPath(){this.ctx.beginPath()}moveTo({x:t,y:i}){this.ctx.moveTo(t,i)}lineTo({x:t,y:i}){this.ctx.lineTo(t,i)}arc({x:t,y:i},e,s,n,o){this.ctx.arc(t,i,e,s,n,o)}arcTo(t,i,e){this.ctx.arcTo(t.x,t.y,i.x,i.y,e)}quadraticCurveTo(t,i){this.ctx.quadraticCurveTo(t.x,t.y,i.x,i.y)}bezierCurveTo(t,i,e){this.ctx.bezierCurveTo(t.x,t.y,i.x,i.y,e.x,e.y)}applyStrokeOptions({strokeWidth:t=1,stroke:i,strokeCap:e="butt",strokeDash:s=[],strokeDashOffset:n=0,strokeJoin:o="round"}){i&&(this.ctx.lineWidth=t,this.ctx.strokeStyle=i,this.ctx.lineCap=e,this.ctx.setLineDash(s),this.ctx.lineDashOffset=n,this.ctx.lineJoin=o)}stroke(t){t.stroke&&(this.applyStrokeOptions(t),this.ctx.stroke())}applyFillOptions({fill:t}){t&&(this.ctx.fillStyle=t)}fill(t){t.fill&&(this.applyFillOptions(t),this.ctx.fill())}applyStrokeAndFillOptions(t){this.applyFillOptions(t),this.applyStrokeOptions(t)}strokeAndFill(t){this.fill(t),this.stroke(t)}getDebugStrokeOptions(t="magenta"){return{stroke:t,strokeWidth:.5}}debugStroke(t="magenta"){this.stroke(this.getDebugStrokeOptions(t))}fillText(t,i,e={}){this.applyFillOptions(e),this.ctx.fillText(t,i.x,i.y)}circle(t,i,e){this.beginPath(),this.arc(t,i,0,2*Math.PI),this.strokeAndFill(e)}ellipse(t,i,e,s){this.beginPath(),this.ctx.ellipse(t.x,t.y,i,e,0,0,2*Math.PI),this.strokeAndFill(s)}debugLabel(t,i,e){t&&(this.applyFillOptions({fill:e}),this.fillText(t,i.add(n)))}debugPointX(t,{color:i="magenta",label:e}={}){this.debugLabel(e,t,i),this.beginPath(),this.ctx.moveTo(t.x-3,t.y-3),this.ctx.lineTo(t.x+3,t.y+3),this.ctx.moveTo(t.x+3,t.y-3),this.ctx.lineTo(t.x-3,t.y+3),this.stroke({strokeWidth:.5,stroke:i})}debugPointO(t,{color:i="magenta",label:e}={}){this.debugLabel(e,t,i),this.circle(t,3,{strokeWidth:.5,stroke:i})}debugArrow(t,i,{color:e="magenta",label:n}={}){this.debugLabel(n,s.average([t,i]),e),this.ctx.beginPath(),this.moveTo(t),this.lineTo(i);const r=i.sub(t),h=r.rotate(-o).withMagnitude(5).add(i),l=r.rotate(+o).withMagnitude(5).add(i);this.moveTo(h),this.lineTo(i),this.lineTo(l),this.stroke({strokeWidth:.5,stroke:e})}debugVectorAtPoint(t,i,e){this.debugArrow(i,i.add(t),e)}polygon(t,i={}){this.beginPath(),this.moveTo(t[t.length-1]);for(const i of t)this.lineTo(i);this.strokeAndFill(i)}polyLine(t,i={}){this.beginPath(),this.moveTo(t[0]);for(let i=1;i<t.length;i++)this.lineTo(t[i]);this.stroke(i)}debugPolygon(t,{color:i="magenta",label:e}={}){this.debugLabel(e,t[0],i),this.polygon(t,this.getDebugStrokeOptions(i))}debugPolyLine(t,{color:i="magenta",label:e}={}){this.debugLabel(e,t[0],i),this.polyLine(t,this.getDebugStrokeOptions(i))}debugQuadraticCurve(t,i,e,{color:s="magenta",label:n}={}){this.debugLabel(n,t,s),this.beginPath(),this.moveTo(t),this.quadraticCurveTo(i,e),this.stroke(this.getDebugStrokeOptions(s))}debugBezierCurve(t,i,e,s,{color:n="magenta",label:o}={}){this.debugLabel(o,t,n),this.beginPath(),this.moveTo(t),this.bezierCurveTo(i,e,s),this.stroke(this.getDebugStrokeOptions(n))}debugLine2(t,{color:i="magenta",label:e}={}){this.debugLabel(e,t.start,i),this.debugArrow(t.start,t.end,{color:i,label:e})}aabb(t,i){i.debug&&this.debugLabel(i.debug.label,t.origin,i.debug.color||"magenta"),this.ctx.beginPath(),this.ctx.rect(t.left,t.top,t.width,t.height),this.strokeAndFill(i)}constructor(t){this.ctx=t}}(h);document.body.appendChild(r);class c{static fromLeftTopRightBottom(t,i,e,n){return new c(new s(t,i),new s(e-t,n-i))}contains({x:t,y:i}){return this.left<=t&&t<=this.right&&this.top<=i&&i<=this.bottom}intersects(t){return!(this.right<t.left||this.left>t.right||this.bottom<t.top||this.top>t.bottom)}getCenter(){return this.origin.add(this.size.scale(.5))}get left(){return this.origin.x}get right(){return this.origin.x+this.size.x}get top(){return this.origin.y}get bottom(){return this.origin.y+this.size.y}get width(){return this.size.x}get height(){return this.size.y}constructor(t,i){this.origin=t,this.size=i,Object.freeze(this)}}class g{insert(t){const i=this._getPosition(t);if(!this.boundary.contains(i))return!1;if(this._nextItemIndex<g.NODE_CAPACITY)return this._items[this._nextItemIndex]=t,this._nextItemIndex++,!0;const e=this._getSubdivisions();if(e[0].insert(t))return!0;if(e[1].insert(t))return!0;if(e[2].insert(t))return!0;if(e[3].insert(t))return!0;throw new Error("Couldnt insert item")}remove(t){const i=this._getPosition(t);if(!this.boundary.contains(i))return!1;const e=this._items.indexOf(t);if(-1!==e)return this._items.splice(e,1),this._nextItemIndex--,!0;const s=this._subdivisions;if(s){if(s[0].remove(t))return!0;if(s[1].remove(t))return!0;if(s[2].remove(t))return!0;if(s[3].remove(t))return!0}return!1}clear(){for(let t=0;t<this._nextItemIndex;t++)this._items[t]=void 0,this._nextItemIndex=0;this._subdivisions&&this._subdivisions.forEach((t=>t.clear()))}findItemsInRect(t){const i=[];if(!this.boundary.intersects(t))return i;for(let e=0;e<this._nextItemIndex;e++){const s=this._items[e];if(null==s)continue;const n=this._getPosition(s);t.contains(n)&&i.push(s)}const e=this._subdivisions;return e?(e[0].boundary.intersects(t)&&i.push(...e[0].findItemsInRect(t)),e[1].boundary.intersects(t)&&i.push(...e[1].findItemsInRect(t)),e[2].boundary.intersects(t)&&i.push(...e[2].findItemsInRect(t)),e[3].boundary.intersects(t)&&i.push(...e[3].findItemsInRect(t)),i):i}findItemsInCircle(t){return this.findItemsInRect(t.getBoundingBox()).filter((i=>t.containsPoint(this._getPosition(i))))}_getSubdivisions(){if(this._subdivisions)return this._subdivisions;const t=this.boundary.getCenter(),i=[new g(c.fromLeftTopRightBottom(this.boundary.left,this.boundary.top,t.x,t.y),this._getPosition),new g(c.fromLeftTopRightBottom(t.x,this.boundary.top,this.boundary.right,t.y),this._getPosition),new g(c.fromLeftTopRightBottom(this.boundary.left,t.y,t.x,this.boundary.bottom),this._getPosition),new g(c.fromLeftTopRightBottom(t.x,t.y,this.boundary.right,this.boundary.bottom),this._getPosition)];return this._subdivisions=i,i}constructor(t,i){this._items=[],this._nextItemIndex=0,this._subdivisions=null,this.boundary=t,this._getPosition=i}}g.NODE_CAPACITY=4;const x=function(t,n,o){const r=t*Math.sqrt(3)/2,h=[],l=[];for(let i=0;i*r<o+r;i++){const o=[];h.push(o);const a=[];l.push(a);for(let l=0;l*t<n+t;l++){const n=new s(l*t+(i%2==0?-t/2:0),i*r);if(o.push(n),0!==i&&0!==l)if(i%2==0){const t={id:e("triangle"),points:[n,h[i][l-1],h[i-1][l-1]]},s={id:e("triangle"),points:[n,h[i-1][l-1],h[i-1][l]]};a.push(t,s)}else if(h[i-1][l+1]){const t={id:e("triangle"),points:[n,h[i][l-1],h[i-1][l]]},s={id:e("triangle"),points:[n,h[i-1][l+1],h[i-1][l]]};a.push(t,s)}}}const a=new Map;for(let t=0;t<l.length;t++)for(let e=0;e<l[t].length;e++){var u,d,c,g,x,b,y,f,m,p,v,w;const n=l[t][e],o=s.average(n.points),r=(e%2==0?t%2==0?[null===(u=l[t])||void 0===u?void 0:u[e-1],null===(d=l[t])||void 0===d?void 0:d[e+1],null===(c=l[t+1])||void 0===c?void 0:c[e-1]]:[null===(g=l[t])||void 0===g?void 0:g[e-1],null===(x=l[t])||void 0===x?void 0:x[e+1],null===(b=l[t+1])||void 0===b?void 0:b[e+1]]:t%2==0?[null===(y=l[t])||void 0===y?void 0:y[e-1],null===(f=l[t])||void 0===f?void 0:f[e+1],null===(m=l[t-1])||void 0===m?void 0:m[e-1]]:[null===(p=l[t])||void 0===p?void 0:p[e-1],null===(v=l[t])||void 0===v?void 0:v[e+1],null===(w=l[t-1])||void 0===w?void 0:w[e+1]]).filter((t=>null!=t)),h=n;h.center=o,h.neighbours=r.map((t=>({triangle:t,sharedPoints:i(n.points,t.points)}))),h.ix=e,h.iy=t,a.set(h.id,h)}return a}(30,l,a),b=new g(new c(new s(-30,-30),new s(l+30,a+30)),(t=>t.center));for(const t of x.values())b.insert(t);const y=b.findItemsInRect(new c(new s(100,100),new s(200,200)));console.log(y);for(const t of y)d.debugPolygon(t.points);
//# sourceMappingURL=index.c5077f6f.js.map
