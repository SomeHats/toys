{"mappings":"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","sources":["src/lib/utils.ts","src/lib/geom/Vector2.ts","src/lib/DebugDraw.ts","src/worms/canvas.ts","src/lib/assert.ts","src/worms/colors.ts","src/worms/worms-main.ts","src/lib/createTriangleGrid.ts"],"sourcesContent":["export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function isWithin(a: number, b: number, n: number): boolean {\n  return a > b ? b <= n && n <= a : a <= n && n <= b;\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n\nexport function last<T>(arr: ReadonlyArray<T>): T | undefined {\n  if (!arr.length) {\n    return undefined;\n  }\n  return arr[arr.length - 1];\n}\n\nexport function* indexed<T>(\n  iterable: Iterable<T>,\n): Generator<[number, T], void> {\n  let i = 0;\n  for (const item of iterable) {\n    yield [i, item];\n    i++;\n  }\n}\n\nexport function noop() {}\n","import { normalizeAngle, lerp } from '../utils';\n\nexport default class Vector2 {\n  static readonly ZERO = new Vector2(0, 0);\n\n  static fromPolar(angle: number, radius: number) {\n    return new Vector2(radius * Math.cos(angle), radius * Math.sin(angle));\n  }\n\n  static average(points: ReadonlyArray<Vector2>): Vector2 {\n    const sum = points.reduce((memo, p) => memo.add(p), Vector2.ZERO);\n    return sum.div(points.length);\n  }\n\n  static fromVectorLike({ x, y }: { x: number; y: number }): Vector2 {\n    return new Vector2(x, y);\n  }\n\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  toString(): string {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n\n  get magnitudeSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  get magnitude(): number {\n    return Math.sqrt(this.magnitudeSquared);\n  }\n\n  get angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  isInPolygon(polygon: ReadonlyArray<Vector2>): boolean {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const { x, y } = this;\n\n    let isInside = false;\n    for (\n      let currentIdx = 0, previousIdx = polygon.length - 1;\n      currentIdx < polygon.length;\n      previousIdx = currentIdx++\n    ) {\n      const { x: currentX, y: currentY } = polygon[currentIdx];\n      const { x: previousX, y: previousY } = polygon[previousIdx];\n      const doesIntersect =\n        currentY > y != previousY > y &&\n        x <\n          ((previousX - currentX) * (y - currentY)) / (previousY - currentY) +\n            currentX;\n\n      if (doesIntersect) {\n        isInside = !isInside;\n      }\n    }\n\n    return isInside;\n  }\n\n  equals(other: Vector2) {\n    return this === other || (this.x === other.x && this.y === other.y);\n  }\n\n  distanceTo({ x, y }: Vector2): number {\n    const dx = x - this.x;\n    const dy = y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angleTo(other: Vector2): number {\n    return other.sub(this).angle;\n  }\n\n  angleBetween(other: Vector2): number {\n    return normalizeAngle(\n      Math.atan2(other.y, other.x) - Math.atan2(this.y, this.x),\n    );\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  div(scale: number): Vector2 {\n    return new Vector2(this.x / scale, this.y / scale);\n  }\n\n  scale(scale: number): Vector2 {\n    return new Vector2(this.x * scale, this.y * scale);\n  }\n\n  negate(): Vector2 {\n    return this.scale(-1);\n  }\n\n  add({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x + x, this.y + y);\n  }\n\n  sub({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x - x, this.y - y);\n  }\n\n  floor(): Vector2 {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  ceil(): Vector2 {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n\n  round(): Vector2 {\n    return new Vector2(Math.round(this.x), Math.round(this.y));\n  }\n\n  withMagnitude(newMagnitude: number): Vector2 {\n    return Vector2.fromPolar(this.angle, newMagnitude);\n  }\n\n  normalize(): Vector2 {\n    return this.withMagnitude(1);\n  }\n\n  withAngle(newAngle: number): Vector2 {\n    return Vector2.fromPolar(newAngle, this.magnitude);\n  }\n\n  rotate(byAngle: number): Vector2 {\n    return this.withAngle(this.angle + byAngle);\n  }\n\n  lerp(other: Vector2, n: number): Vector2 {\n    return new Vector2(lerp(this.x, other.x, n), lerp(this.y, other.y, n));\n  }\n}\n","import AABB from './geom/AABB';\nimport Line2 from './geom/Line2';\nimport Vector2 from './geom/Vector2';\n\nconst DEFAULT_DEBUG_COLOR = 'magenta';\nconst LABEL_OFFSET = new Vector2(5, 0);\nconst DEBUG_POINT_SIZE = 3;\nconst HAIRLINE = 0.5;\nconst DEBUG_ARROW_ANGLE = Math.PI * 0.75;\nconst DEBUG_ARROW_SIZE = 5;\n\nexport type StrokeOptions = {\n  strokeWidth?: number;\n  stroke?: string;\n  strokeCap?: 'butt' | 'round' | 'square';\n  strokeDash?: number[];\n  strokeDashOffset?: number;\n  strokeJoin?: 'bevel' | 'round' | 'miter';\n};\n\nexport type FillOptions = {\n  fill?: string;\n};\n\nexport type DebugOptions = {\n  color?: string;\n  label?: string;\n};\n\nexport type StrokeAndFillOptions = StrokeOptions & FillOptions;\n\nexport class DebugDraw {\n  constructor(public readonly ctx: CanvasRenderingContext2D) {}\n\n  public clear(fill?: string) {\n    if (!fill) {\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      return;\n    }\n\n    this.applyFillOptions({ fill });\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n\n  public beginPath() {\n    this.ctx.beginPath();\n  }\n\n  public moveTo({ x, y }: Vector2) {\n    this.ctx.moveTo(x, y);\n  }\n\n  public lineTo({ x, y }: Vector2) {\n    this.ctx.lineTo(x, y);\n  }\n\n  public arc(\n    { x, y }: Vector2,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean,\n  ) {\n    this.ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  public arcTo(p1: Vector2, p2: Vector2, radius: number) {\n    this.ctx.arcTo(p1.x, p1.y, p2.x, p2.y, radius);\n  }\n\n  public quadraticCurveTo(control: Vector2, target: Vector2) {\n    this.ctx.quadraticCurveTo(control.x, control.y, target.x, target.y);\n  }\n  public bezierCurveTo(control1: Vector2, control2: Vector2, target: Vector2) {\n    this.ctx.bezierCurveTo(\n      control1.x,\n      control1.y,\n      control2.x,\n      control2.y,\n      target.x,\n      target.y,\n    );\n  }\n\n  public applyStrokeOptions({\n    strokeWidth = 1,\n    stroke = undefined,\n    strokeCap = 'butt',\n    strokeDash = [],\n    strokeDashOffset = 0,\n    strokeJoin = 'round',\n  }: StrokeOptions) {\n    if (stroke) {\n      this.ctx.lineWidth = strokeWidth;\n      this.ctx.strokeStyle = stroke;\n      this.ctx.lineCap = strokeCap;\n      this.ctx.setLineDash(strokeDash);\n      this.ctx.lineDashOffset = strokeDashOffset;\n      this.ctx.lineJoin = strokeJoin;\n    }\n  }\n\n  public stroke(options: StrokeOptions) {\n    if (options.stroke) {\n      this.applyStrokeOptions(options);\n      this.ctx.stroke();\n    }\n  }\n\n  public applyFillOptions({ fill = undefined }: FillOptions) {\n    if (fill) {\n      this.ctx.fillStyle = fill;\n    }\n  }\n\n  public fill(options: FillOptions) {\n    if (options.fill) {\n      this.applyFillOptions(options);\n      this.ctx.fill();\n    }\n  }\n\n  public applyStrokeAndFillOptions(options: StrokeAndFillOptions) {\n    this.applyFillOptions(options);\n    this.applyStrokeOptions(options);\n  }\n\n  public strokeAndFill(options: StrokeAndFillOptions) {\n    this.fill(options);\n    this.stroke(options);\n  }\n\n  public getDebugStrokeOptions(\n    color: string = DEFAULT_DEBUG_COLOR,\n  ): StrokeOptions {\n    return { stroke: color, strokeWidth: HAIRLINE };\n  }\n\n  public debugStroke(color: string = DEFAULT_DEBUG_COLOR) {\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n\n  public fillText(text: string, position: Vector2, options: FillOptions = {}) {\n    this.applyFillOptions(options);\n    this.ctx.fillText(text, position.x, position.y);\n  }\n\n  public circle(\n    center: Vector2,\n    radius: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.arc(center, radius, 0, 2 * Math.PI);\n    this.strokeAndFill(options);\n  }\n\n  public ellipse(\n    center: Vector2,\n    radiusX: number,\n    radiusY: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.ctx.ellipse(center.x, center.y, radiusX, radiusY, 0, 0, Math.PI * 2);\n    this.strokeAndFill(options);\n  }\n\n  public debugLabel(\n    label: string | undefined,\n    position: Vector2,\n    color: string,\n  ) {\n    if (label) {\n      this.applyFillOptions({ fill: color });\n      this.fillText(label, position.add(LABEL_OFFSET));\n    }\n  }\n\n  public debugPointX(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.beginPath();\n    this.ctx.moveTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.ctx.moveTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugPointO(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.circle(position, DEBUG_POINT_SIZE, {\n      strokeWidth: HAIRLINE,\n      stroke: color,\n    });\n  }\n\n  public debugArrow(\n    start: Vector2,\n    end: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, Vector2.average([start, end]), color);\n\n    this.ctx.beginPath();\n    this.moveTo(start);\n    this.lineTo(end);\n\n    const vector = end.sub(start);\n    const arrowLeftPoint = vector\n      .rotate(-DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n    const arrowRightPoint = vector\n      .rotate(+DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n\n    this.moveTo(arrowLeftPoint);\n    this.lineTo(end);\n    this.lineTo(arrowRightPoint);\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugVectorAtPoint(\n    vector: Vector2,\n    base: Vector2,\n    options?: DebugOptions,\n  ) {\n    this.debugArrow(base, base.add(vector), options);\n  }\n\n  public polygon(\n    polygon: ReadonlyArray<Vector2>,\n    options: StrokeAndFillOptions = {},\n  ) {\n    this.beginPath();\n    this.moveTo(polygon[polygon.length - 1]);\n    for (const point of polygon) {\n      this.lineTo(point);\n    }\n    this.strokeAndFill(options);\n  }\n\n  public polyLine(points: ReadonlyArray<Vector2>, options: StrokeOptions = {}) {\n    this.beginPath();\n    this.moveTo(points[0]);\n    for (let i = 1; i < points.length; i++) {\n      this.lineTo(points[i]);\n    }\n    this.stroke(options);\n  }\n\n  public debugPolygon(\n    polygon: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polygon[0], color);\n    this.polygon(polygon, this.getDebugStrokeOptions(color));\n  }\n\n  public debugPolyLine(\n    polyLine: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polyLine[0], color);\n    this.polyLine(polyLine, this.getDebugStrokeOptions(color));\n  }\n  public debugQuadraticCurve(\n    from: Vector2,\n    control: Vector2,\n    to: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, from, color);\n    this.beginPath();\n    this.moveTo(from);\n    this.quadraticCurveTo(control, to);\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n  public debugBezierCurve(\n    from: Vector2,\n    control1: Vector2,\n    control2: Vector2,\n    to: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, from, color);\n    this.beginPath();\n    this.moveTo(from);\n    this.bezierCurveTo(control1, control2, to);\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n  public debugLine2(\n    line: Line2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, line.start, color);\n    this.debugArrow(line.start, line.end, { color, label });\n  }\n\n  public aabb(\n    aabb: AABB,\n    opts: StrokeAndFillOptions & { debug?: DebugOptions },\n  ) {\n    if (opts.debug) {\n      this.debugLabel(\n        opts.debug.label,\n        aabb.origin,\n        opts.debug.color || DEFAULT_DEBUG_COLOR,\n      );\n    }\n    this.ctx.beginPath();\n    this.ctx.rect(aabb.left, aabb.top, aabb.width, aabb.height);\n    this.strokeAndFill(opts);\n  }\n}\n","import { DebugDraw } from '../lib/DebugDraw';\n\nexport const canvasEl = document.createElement('canvas');\nexport const ctx = canvasEl.getContext('2d')!;\nexport const width = document.body.clientWidth;\nexport const height = document.body.clientHeight;\nexport const scale = window.devicePixelRatio;\n\ncanvasEl.width = width * scale;\ncanvasEl.height = height * scale;\ncanvasEl.style.width = `${width}px`;\ncanvasEl.style.height = `${height}px`;\nctx.scale(scale, scale);\nexport const canvas = new DebugDraw(ctx);\ndocument.body.appendChild(canvasEl);\n","export function fail(message: string): never {\n  throw new Error(message);\n}\n\nexport function assert(value: unknown, message?: string): asserts value {\n  if (!value) {\n    fail(message || 'Assertion Error');\n  }\n}\n","import Color from 'color';\n\n// // https://coolors.co/f2dc5d-f2a359-db9065-a4031f-240b36\n// export const BG = new Color('#240b36');\n// export const SNAKES = [\n//   new Color('#f2dc5d'),\n//   new Color('#f2a359'),\n//   new Color('#db9065'),\n//   new Color('#a4031f'),\n// ];\n\n// https://coolors.co/ba2d0b-d5f2e3-73ba9b-003e1f-01110a\n// export const BG = new Color('#01110a');\n\n// export const SNAKES = [\n//   new Color('#ba2d0b'),\n//   new Color('#d5f2e3'),\n//   new Color('#73ba9b'),\n//   new Color('#003e1f'),\n// ];\n\n// https://coolors.co/f4e04d-f2ed6f-cee397-8db1ab-587792\nexport const BG = new Color('#E2ECC9');\nexport const SNAKES = [\n  new Color('#C33C54'),\n  new Color('#bfb915'),\n  new Color('#96ba3b'),\n  new Color('#39847f'),\n  new Color('#12416b'),\n];\n","import { canvas, width, height } from './canvas';\nimport Vector2 from '../lib/geom/Vector2';\nimport {\n  compact,\n  getId,\n  sample,\n  shuffle,\n  times,\n  randomInt,\n  frameLoop,\n  uniq,\n  random,\n} from '../lib/utils';\nimport createTriangleGrid, { Triangle } from '../lib/createTriangleGrid';\nimport { assert } from '../lib/assert';\nimport { SNAKES, BG } from './colors';\nimport { schemePaired } from 'd3-scale-chromatic';\n\nconst TILE_SIZE = 50;\nconst ARC_LENGTH = (Math.PI * TILE_SIZE) / 6;\n\nconst trianglesById = createTriangleGrid(TILE_SIZE, width, height);\n\n// for (const triangle of trianglesById.values()) {\n//   canvas.debugPolygon(triangle.points, { color: 'lime' });\n// }\n\ntype Palatte = {\n  palette: Array<string>;\n  current(): string;\n  next(): string;\n  reset(idx?: number): void;\n};\nconst makeColorPalette = (): Palatte => {\n  const palette = times(randomInt(2, 6), () => sample(SNAKES).string());\n  if (uniq(palette).length === 1) return makeColorPalette();\n\n  let i = 0;\n  return {\n    palette,\n    current: () => {\n      return palette[i % palette.length];\n    },\n    next: () => {\n      i++;\n      return palette[i % palette.length];\n    },\n    reset: (idx = 0) => {\n      i = idx;\n    },\n  };\n};\n\nfunction getSharedPoints(a: Triangle, b: Triangle) {\n  const neighbour = a.neighbours.find(n => n.triangle === b);\n  assert(neighbour, 'must be a neighbour');\n  return neighbour.sharedPoints;\n}\n\nconst occupied = new Set<Triangle>();\ntype Snake = {\n  triangles: Array<Triangle>;\n  palette: ReturnType<typeof makeColorPalette>;\n  speed: number;\n  base: number;\n  offset: number;\n  length: number;\n  isDead: boolean;\n};\n\nconst makeSnake = () => {\n  const triangles: Array<Triangle> = [];\n  const palette = makeColorPalette();\n  let neighbours = [...trianglesById.values()];\n  for (let i = 0; i < 2; i++) {\n    const availableNeighbours = neighbours.filter(\n      neighbour => !occupied.has(neighbour),\n    );\n    if (!availableNeighbours.length) break;\n    const triangle = sample(availableNeighbours);\n    triangles.push(triangle);\n    occupied.add(triangle);\n    neighbours = triangle.neighbours.map(n => n.triangle);\n  }\n\n  // if (triangles.length < 2) continue;\n  return {\n    triangles,\n    palette,\n    speed: random(0.06, 0.12),\n    offset: 0,\n    base: 0,\n    length: triangles.length,\n    isDead: false,\n  };\n};\nconst snakes: Snake[] = [];\n\nfor (let si = 0; si < 10; si++) {\n  snakes.push(makeSnake());\n}\n\nframeLoop(() => {\n  canvas.clear(BG.string());\n\n  for (const snake of snakes) {\n    snake.offset += snake.speed;\n    if (snake.offset > 1) {\n      snake.offset--;\n      snake.base++;\n\n      if (!snake.isDead) {\n        const headTriangle = snake.triangles[0];\n        const availableNeighbours = headTriangle.neighbours.filter(\n          neighbour => !occupied.has(neighbour.triangle),\n        );\n        if (availableNeighbours.length) {\n          const triangle = sample(availableNeighbours).triangle;\n          occupied.add(triangle);\n          snake.triangles.unshift(triangle);\n          snake.base--;\n          snake.length++;\n        } else {\n          snake.isDead = true;\n          snakes.push(makeSnake());\n        }\n      }\n\n      const lastTriangle = snake.triangles[snake.triangles.length - snake.base];\n      if (lastTriangle) {\n        occupied.delete(lastTriangle);\n        snake.length--;\n      }\n    }\n\n    const { triangles, palette } = snake;\n    palette.reset(snake.base);\n    for (let i = 0; i < snake.length; i++) {\n      const triangle = triangles[i];\n      const last: Triangle | undefined = triangles[i - 1];\n      const next: Triangle | undefined = triangles[i + 1];\n      const currentColor = palette.current();\n      const nextColor = palette.next();\n\n      canvas.beginPath();\n      if (!last) {\n        continue;\n        // assert(next);\n        // const neck = Vector2.average(getSharedPoints(triangle, next));\n        // const head = triangle.center\n        //   .sub(neck)\n        //   .withMagnitude(ARC_LENGTH)\n        //   .add(neck);\n        // canvas.moveTo(head);\n        // canvas.lineTo(neck);\n      } else if (!next) {\n        assert(last);\n        canvas.moveTo(Vector2.average(getSharedPoints(triangle, last)));\n        canvas.lineTo(triangle.center);\n      } else {\n        canvas.moveTo(Vector2.average(getSharedPoints(triangle, last)));\n        canvas.arcTo(triangle.center, next.center, TILE_SIZE / 2 - 0.5);\n      }\n      if (!(i === 1 && !snake.isDead)) {\n        canvas.stroke({\n          strokeWidth: TILE_SIZE / 2,\n          stroke: currentColor,\n          strokeCap: 'round',\n          strokeDash: [ARC_LENGTH, ARC_LENGTH],\n          strokeDashOffset: snake.offset * ARC_LENGTH,\n        });\n      }\n      if (!(i === snake.length - 1 && snake.isDead)) {\n        canvas.stroke({\n          strokeWidth: TILE_SIZE / 2,\n          stroke: nextColor,\n          strokeCap: 'round',\n          strokeDash: [ARC_LENGTH, ARC_LENGTH],\n          strokeDashOffset: snake.offset * ARC_LENGTH - ARC_LENGTH,\n        });\n      }\n    }\n  }\n});\n","import Vector2 from '../lib/geom/Vector2';\nimport { getId, compact, intersection } from '../lib/utils';\nimport Intersection from '../network/networkNodes/Intersection';\n\ntype TriangleGeom = [Vector2, Vector2, Vector2];\ntype IntermediateTriangle = {\n  id: string;\n  points: TriangleGeom;\n};\n\nexport type TriangleNeighbour = {\n  triangle: Triangle;\n  sharedPoints: [Vector2, Vector2];\n};\nexport type Triangle = {\n  id: string;\n  center: Vector2;\n  points: TriangleGeom;\n  neighbours: TriangleNeighbour[];\n  ix: number;\n  iy: number;\n};\n\nexport default function createTriangleGrid(\n  tileSize: number,\n  width: number,\n  height: number,\n): Map<string, Triangle> {\n  const tileHeight = (tileSize * Math.sqrt(3)) / 2;\n  const points: Vector2[][] = [];\n  const trianglePoints: IntermediateTriangle[][] = [];\n  for (let iy = 0; iy * tileHeight < height + tileHeight; iy++) {\n    const pointRow: Vector2[] = [];\n    points.push(pointRow);\n    const triangleRow: IntermediateTriangle[] = [];\n    trianglePoints.push(triangleRow);\n    for (let ix = 0; ix * tileSize < width + tileSize; ix++) {\n      const xOffset = iy % 2 === 0 ? -tileSize / 2 : 0;\n      const point = new Vector2(ix * tileSize + xOffset, iy * tileHeight);\n      pointRow.push(point);\n\n      if (iy !== 0 && ix !== 0) {\n        if (iy % 2 === 0) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix - 1]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix - 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        } else if (points[iy - 1][ix + 1]) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix + 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        }\n      }\n    }\n  }\n\n  const trianglesById = new Map<string, Triangle>();\n  for (let iy = 0; iy < trianglePoints.length; iy++) {\n    for (let ix = 0; ix < trianglePoints[iy].length; ix++) {\n      const triangle = trianglePoints[iy][ix];\n      const center = Vector2.average(triangle.points);\n\n      const neighbours = compact(\n        ix % 2 === 0\n          ? iy % 2 === 0\n            ? [\n                // 2,2\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix - 1],\n              ]\n            : [\n                // 2,3\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix + 1],\n              ]\n          : iy % 2 === 0\n          ? [\n              // 3,2\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix - 1],\n            ]\n          : [\n              //3,3\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix + 1],\n            ],\n      );\n\n      const fullTriangle = triangle as Triangle;\n      fullTriangle.center = center;\n      fullTriangle.neighbours = neighbours.map(neighbourTriangle => ({\n        triangle: neighbourTriangle,\n        sharedPoints: intersection(triangle.points, neighbourTriangle.points),\n      })) as TriangleNeighbour[];\n      fullTriangle.ix = ix;\n      fullTriangle.iy = iy;\n\n      trianglesById.set(fullTriangle.id, fullTriangle);\n    }\n  }\n\n  return trianglesById;\n}\n"],"names":["$15a201ffde8bbde4$export$3a89f8d6f6bf6c9f","a","b","n","$15a201ffde8bbde4$export$4385e60b38654f68","Math","random","$15a201ffde8bbde4$export$4812e460280c6ef2","arr","floor","length","$15a201ffde8bbde4$export$bc86dfbf7795668c","a1","a2","a1Items","Set","result","item","has","add","Array","from","$15a201ffde8bbde4$export$218c8c3169c024d2","prefix","toString","slice","$db8edb9c8035529a$export$2e2bcd8739ae039","angle","radius","cos","sin","points","reduce","memo","p","ZERO","div","x","y","this","magnitudeSquared","magnitude","sqrt","atan2","isInPolygon","polygon","isInside","currentIdx","previousIdx","currentX","currentY","previousX","previousY","equals","other","distanceTo","x1","y1","dx","dy","angleTo","other1","sub","angleBetween","other2","min","max","size","$15a201ffde8bbde4$export$9013bf5175691fac","PI","dot","other3","scale","scale1","negate","x2","y2","x3","y3","ceil","round","withMagnitude","newMagnitude","fromPolar","normalize","withAngle","newAngle","rotate","byAngle","lerp","other4","x4","y4","$870293e39def1396$var$LABEL_OFFSET","$870293e39def1396$var$DEBUG_ARROW_ANGLE","$023070177873dee0$export$38c8a1558598a89e","document","createElement","$023070177873dee0$export$39f92e86d1722f3a","getContext","$023070177873dee0$export$7e3df82ee760448c","body","clientWidth","$023070177873dee0$export$ac607276a8fe9f0a","clientHeight","$023070177873dee0$export$dcdf75081b88279d","window","devicePixelRatio","width","height","style","$023070177873dee0$export$67ea982130081db","clear","fill","applyFillOptions","ctx","fillRect","canvas","clearRect","beginPath","moveTo","lineTo","arc","startAngle","endAngle","anticlockwise","arcTo","p1","p2","radius1","quadraticCurveTo","control","target","bezierCurveTo","control1","control2","target1","applyStrokeOptions","strokeWidth","stroke","strokeCap","strokeDash","strokeDashOffset","strokeJoin","lineWidth","strokeStyle","lineCap","setLineDash","lineDashOffset","lineJoin","options","fill1","fillStyle","options1","applyStrokeAndFillOptions","options2","strokeAndFill","options3","getDebugStrokeOptions","color","debugStroke","color1","fillText","text","position","options4","circle","center","radius2","options5","ellipse","center1","radiusX","radiusY","options6","debugLabel","label","position1","color2","debugPointX","position2","color3","label1","debugPointO","position3","color4","label2","debugArrow","start","end","color5","label3","average","vector","arrowLeftPoint","arrowRightPoint","debugVectorAtPoint","base","options7","options8","point","polyLine","options9","i","debugPolygon","polygon1","color6","label4","debugPolyLine","color7","label5","debugQuadraticCurve","control3","to","color8","label6","debugBezierCurve","from1","control11","control21","to1","color9","label7","debugLine2","line","color10","label8","aabb","opts","debug","origin","rect","left","top","$90518cd969dab22c$export$a7a9523472993e97","value","message","Error","$90518cd969dab22c$export$2b62a06a9fee979c","appendChild","$665edb9978ab1158$export$7ecc97c3ec9172d0","$parcel$interopDefault","$0FWmF","$665edb9978ab1158$export$5584a1b37cf6f0e0","$f6ab413e1cc8373c$var$ARC_LENGTH","$f6ab413e1cc8373c$var$trianglesById","tileSize","tileHeight","trianglePoints","iy","pointRow","push","triangleRow","ix","triangle1","id","triangle2","trianglesById","Map","iy1","ref","ref1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","ref10","ref11","triangle","neighbours","filter","fullTriangle","map","neighbourTriangle","sharedPoints","set","$dd4ecc289fc2ac4a$export$2e2bcd8739ae039","$f6ab413e1cc8373c$var$makeColorPalette","palette","fn","$15a201ffde8bbde4$export$b5bc26e198ce73d0","string","current","next","reset","idx","$f6ab413e1cc8373c$var$getSharedPoints","neighbour","find","$f6ab413e1cc8373c$var$occupied","$f6ab413e1cc8373c$var$makeSnake","triangles","values","availableNeighbours","speed","offset","isDead","$f6ab413e1cc8373c$var$snakes","si","cb","shouldCancel","cancel","Promise","resolve","requestAnimationFrame","time","$15a201ffde8bbde4$export$a57f5080a3bcc90a","snake","unshift","lastTriangle","delete","last","currentColor","nextColor","$f6ab413e1cc8373c$var$TILE_SIZE"],"version":3,"file":"index.623e22da.js.map"}