{"mappings":"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","sources":["src/lib/geom/Circle.ts","src/lib/geom/Line2.ts","src/lib/assert.ts"],"sourcesContent":["// @flow\nimport Vector2 from './Vector2';\nimport AABB from './AABB';\nimport Line2 from './Line2';\n\nexport default class Circle {\n  static create(x: number, y: number, radius: number): Circle {\n    return new Circle(new Vector2(x, y), radius);\n  }\n  constructor(readonly center: Vector2, readonly radius: number) {}\n\n  get circumference(): number {\n    return 2 * Math.PI * this.radius;\n  }\n\n  getBoundingBox(): AABB {\n    return new AABB(\n      new Vector2(this.center.x, this.center.y),\n      new Vector2(this.radius * 2, this.radius * 2),\n    );\n  }\n\n  // debugDraw(color: string) {\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.strokeStyle = color;\n  //   ctx.lineWidth = 1;\n  //   ctx.beginPath();\n  //   ctx.arc(this.center.x, this.center.y, this.radius, 0, Math.PI * 2, false);\n  //   ctx.stroke();\n  // }\n\n  pointOnCircumference(radians: number): Vector2 {\n    return new Vector2(\n      this.center.x + Math.cos(radians) * this.radius,\n      this.center.y + Math.sin(radians) * this.radius,\n    );\n  }\n\n  containsPoint(point: Vector2): boolean {\n    return point.distanceTo(this.center) < this.radius;\n  }\n\n  intersectsCircle(other: Circle): boolean {\n    return this.center.distanceTo(other.center) < this.radius + other.radius;\n  }\n\n  withRadius(radius: number): Circle {\n    return Circle.create(this.center.x, this.center.y, radius);\n  }\n\n  outerTangentsWith(other: Circle): [Line2, Line2] | undefined {\n    const distance = this.center.distanceTo(other.center);\n    if (distance <= Math.abs(this.radius - other.radius)) {\n      // The circles are coinciding. There are no valid tangents.\n      return undefined;\n    }\n\n    const angle = this.center.angleTo(other.center);\n    const normalAngle = Math.acos((this.radius - other.radius) / distance);\n\n    return [\n      new Line2(\n        this.pointOnCircumference(angle - normalAngle),\n        other.pointOnCircumference(angle - normalAngle),\n      ),\n      new Line2(\n        this.pointOnCircumference(angle + normalAngle),\n        other.pointOnCircumference(angle + normalAngle),\n      ),\n    ];\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport { isWithin } from '../utils';\nimport Vector2 from './Vector2';\n\nconst isSlopeVertical = (slope: number) =>\n  slope === Infinity || slope === -Infinity;\n\nexport default class Line2 {\n  static fromSlopeAndDisplacement(slope: number, displacement: number) {\n    assert(\n      !isSlopeVertical(slope),\n      'cannot create vertical line from displacement',\n    );\n\n    const start = new Vector2(0, displacement);\n    const end = new Vector2(1, slope + displacement);\n    return new Line2(start, end);\n  }\n\n  static fromSlopeAndPoint(slope: number, point: Vector2): Line2 {\n    if (isSlopeVertical(slope)) {\n      return new Line2(point, new Vector2(point.x, point.y + 1));\n    }\n\n    const displacement = point.y - point.x * slope;\n    return Line2.fromSlopeAndDisplacement(slope, displacement);\n  }\n\n  readonly start: Vector2;\n  readonly end: Vector2;\n\n  constructor(a: Vector2, b: Vector2) {\n    this.start = a;\n    this.end = b;\n  }\n\n  getDelta(): Vector2 {\n    return this.end.sub(this.start);\n  }\n\n  get slope(): number {\n    return (this.end.y - this.start.y) / (this.end.x - this.start.x);\n  }\n\n  get angle(): number {\n    return this.start.angleTo(this.end);\n  }\n\n  get length(): number {\n    return this.start.distanceTo(this.end);\n  }\n\n  get displacement(): number {\n    return this.start.y - this.start.x * this.slope;\n  }\n\n  get isVertical(): boolean {\n    return isSlopeVertical(this.slope);\n  }\n\n  get verticalX(): number {\n    assert(this.isVertical, 'verticalX is not defined on non vertical lines');\n    return this.start.x;\n  }\n\n  get perpendicularSlope(): number {\n    if (this.isVertical) return 0;\n    return -1 / this.slope;\n  }\n\n  isParallelTo(other: Line2): boolean {\n    return (this.isVertical && other.isVertical) || this.slope === other.slope;\n  }\n\n  perpendicularLineThroughPoint(point: Vector2): Line2 {\n    return Line2.fromSlopeAndPoint(this.perpendicularSlope, point);\n  }\n\n  pointAtIntersectionWith(other: Line2): Vector2 {\n    assert(!this.isParallelTo(other), 'parallel lines do not intersect');\n\n    let x;\n    if (this.isVertical) {\n      x = this.verticalX;\n    } else if (other.isVertical) {\n      x = other.verticalX;\n    } else {\n      x = (this.displacement - other.displacement) / (other.slope - this.slope);\n    }\n\n    const y = this.isVertical\n      ? other.slope * x + other.displacement\n      : this.slope * x + this.displacement;\n\n    return new Vector2(x, y);\n  }\n\n  pointAtIntersectionConstrained(other: Line2): Vector2 | undefined {\n    if (this.isParallelTo(other)) return undefined;\n    const point = this.pointAtIntersectionWith(other);\n    if (this.isPointWithinBounds(point) && other.isPointWithinBounds(point)) {\n      return point;\n    }\n    return undefined;\n  }\n\n  midpoint(): Vector2 {\n    return new Vector2(\n      (this.start.x + this.end.x) / 2,\n      (this.start.y + this.end.y) / 2,\n    );\n  }\n\n  isPointWithinBounds({ x, y }: Vector2): boolean {\n    return (\n      isWithin(this.start.x, this.end.x, x) &&\n      isWithin(this.start.y, this.end.y, y)\n    );\n  }\n}\n","export function fail(message: string): never {\n  throw new Error(message);\n}\n\nexport function assert(value: unknown, message?: string): asserts value {\n  if (!value) {\n    fail(message || 'Assertion Error');\n  }\n}\n"],"names":["$17c4be4d5edfd707$export$2e2bcd8739ae039","center","radius","key","Math","PI","this","$71uov","default","$39Hjj","x","y","radians","cos","sin","point","distanceTo","other","create","distance","abs","angle","angleTo","normalAngle","acos","$eYUEV","pointOnCircumference","$ed99e959cca51b61$var$isSlopeVertical","slope","Infinity","$ed99e959cca51b61$export$2e2bcd8739ae039","a","b","start","end","sub","$8OvEy","assert","isVertical","fromSlopeAndPoint","perpendicularSlope","isParallelTo","verticalX","displacement","pointAtIntersectionWith","isPointWithinBounds","param","$8qLe2","isWithin","fromSlopeAndDisplacement","$641a9c3625d3ec2b$export$2b62a06a9fee979c","message","Error","$641a9c3625d3ec2b$export$a7a9523472993e97","value"],"version":3,"file":"index.ceef1c51.js.map"}