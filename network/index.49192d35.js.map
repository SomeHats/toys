{"mappings":"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","sources":["src/lib/easings.ts","src/network/ConnectionDirection.ts","src/network/effects/Pulse.ts","src/network/colors.ts","src/network/ConnectionSet.ts","src/network/networkNodes/Consumer.ts","src/lib/scene/SceneSystem.ts","src/network/TravellerFinder.ts","src/network/PathFinder.ts","src/network/networkNodes/Intersection.ts","src/network/Traveller.ts","src/pals/makePal.ts","src/network/Road.ts","src/lib/geom/Path.ts","src/network/Junction.ts","src/network/networkNodes/Producer.ts","src/network/network-main.ts"],"sourcesContent":["import { approxEq } from './utils';\n\n/** n should be between 0 and 1 */\nexport type Easing = (n: number) => number;\n\n// based on https://github.com/servo/servo/blob/0d0cfd030347ab0711b3c0607a9ee07ffe7124cf/components/style/bezier.rs\nclass UnitBezier {\n  private static readonly NEWTON_METHOD_ITERATIONS = 8;\n  private static readonly DEFAULT_EPSILON = 1e-6;\n  private readonly ax: number;\n  private readonly bx: number;\n  private readonly cx: number;\n  private readonly ay: number;\n  private readonly by: number;\n  private readonly cy: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    const cx = 3 * x1;\n    const bx = 3 * (x2 - x1) - cx;\n\n    const cy = 3 * y1;\n    const by = 3 * (y2 - y1) - cy;\n\n    this.ax = 1.0 - cx - bx;\n    this.bx = bx;\n    this.cx = cx;\n    this.ay = 1.0 - cy - by;\n    this.by = by;\n    this.cy = cy;\n  }\n\n  private sampleCurveX(t: number): number {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }\n\n  private sampleCurveY(t: number): number {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }\n\n  private sampleCurveDerivativeX(t: number): number {\n    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n  }\n\n  private solveCurveX(x: number, epsilon: number): number {\n    // Fast path: Use Newton's method.\n    let t = x;\n    for (let i = 0; i < UnitBezier.NEWTON_METHOD_ITERATIONS; i++) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      let dx = this.sampleCurveDerivativeX(t);\n      if (approxEq(dx, 0.0, 1e-6)) {\n        break;\n      }\n      t -= (x2 - x) / dx;\n    }\n\n    // Slow path: Use bisection.\n    let lo = 0;\n    let hi = 1;\n    t = x;\n\n    if (t < lo) {\n      return lo;\n    }\n    if (t > hi) {\n      return hi;\n    }\n\n    while (lo < hi) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      if (x > x2) {\n        lo = t;\n      } else {\n        hi = t;\n      }\n      t = (hi - lo) / 2.0 + lo;\n    }\n\n    return t;\n  }\n\n  solve(x: number, epsilon: number = UnitBezier.DEFAULT_EPSILON): number {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n  }\n}\n\nexport const cubicBezier = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): Easing => {\n  const bezier = new UnitBezier(x1, y1, x2, y2);\n  return (x) => bezier.solve(x);\n};\n\n/**\n * P(t) = (1-t)^3*P0 + 3*t*(1-t)^2*P1 + 3*t^2*(1-t)*P2 + t^3*P3\n * x = 3*t*(1-t)^2*p1x + 3*t^2*(1-t)*p2x + t^3\n * y(t) = 3*t*(1-t)^2*p1y + 3*t^2*(1-t)*p2y + t^3\n *\n *\n * y = 3*u1*(1-x)^2*x + 3*u2*(1-x)*x^2 + x^3\n */\n\n// https://gist.github.com/rezoner/713615dabedb59a15470\n// http://gsgd.co.uk/sandbox/jquery/easing/\nexport const reverse =\n  (easing: (n: number) => number) =>\n  (n: number): number =>\n    easing(1 - n);\n\nexport const linear = (n: number): number => n;\n\nexport const inQuad = (t: number): number => t * t;\n\nexport const outQuad = (t: number): number => t * (2 - t);\n\nexport const inOutQuad = (t: number): number =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\nexport const inCubic = (t: number): number => t * t * t;\n\nexport const outCubic = (t: number): number => --t * t * t + 1;\n\nexport const inOutCubic = (t: number): number =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nexport const inQuart = (t: number): number => t * t * t * t;\n\nexport const outQuart = (t: number): number => 1 - --t * t * t * t;\n\nexport const inOutQuart = (t: number): number =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\nexport const inQuint = (t: number): number => t * t * t * t * t;\n\nexport const outQuint = (t: number): number => 1 + --t * t * t * t * t;\n\nexport const inOutQuint = (t: number): number =>\n  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nexport const inSine = (t: number): number =>\n  -1 * Math.cos((t / 1) * (Math.PI * 0.5)) + 1;\n\nexport const outSine = (t: number): number =>\n  Math.sin((t / 1) * (Math.PI * 0.5));\n\nexport const inOutSine = (t: number): number =>\n  (-1 / 2) * (Math.cos(Math.PI * t) - 1);\n\nexport const inExpo = (t: number): number =>\n  t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n\nexport const outExpo = (t: number): number =>\n  t == 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n\nexport const inOutExpo = (t: number): number => {\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if ((t /= 1 / 2) < 1) return (1 / 2) * Math.pow(2, 10 * (t - 1));\n  return (1 / 2) * (-Math.pow(2, -10 * --t) + 2);\n};\n\nexport const inCirc = (t: number): number => -1 * (Math.sqrt(1 - t * t) - 1);\n\nexport const outCirc = (t: number): number => Math.sqrt(1 - (t = t - 1) * t);\n\nexport const inOutCirc = (t: number): number => {\n  if ((t /= 1 / 2) < 1) return (-1 / 2) * (Math.sqrt(1 - t * t) - 1);\n  return (1 / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1);\n};\n\nexport const inElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return -(\n    a *\n    Math.pow(2, 10 * (t -= 1)) *\n    Math.sin(((t - s) * (2 * Math.PI)) / p)\n  );\n};\n\nexport const outElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return a * Math.pow(2, -10 * t) * Math.sin(((t - s) * (2 * Math.PI)) / p) + 1;\n};\n\nexport const inOutElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if ((t /= 1 / 2) == 2) return 1;\n  if (!p) p = 0.3 * 1.5;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  if (t < 1)\n    return (\n      -0.5 *\n      (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p))\n    );\n  return (\n    a *\n      Math.pow(2, -10 * (t -= 1)) *\n      Math.sin(((t - s) * (2 * Math.PI)) / p) *\n      0.5 +\n    1\n  );\n};\n\nexport const inBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    return 1 * t * t * ((s + 1) * t - s);\n  };\n\nexport const outBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    t = t - 1;\n    return 1 * (t * t * ((s + 1) * t + s) + 1);\n  };\n\nexport const inOutBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    if ((t /= 1 / 2) < 1)\n      return (1 / 2) * (t * t * (((s *= 1.525) + 1) * t - s));\n    return (1 / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  };\n\nexport const inBounce = (t: number): number => {\n  return 1 - outBounce(1 - t);\n};\n\nexport const outBounce = (t: number): number => {\n  if ((t /= 1) < 1 / 2.75) {\n    return 7.5625 * t * t;\n  } else if (t < 2 / 2.75) {\n    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n  } else if (t < 2.5 / 2.75) {\n    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n  } else {\n    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n  }\n};\n\nexport const inOutBounce = (t: number): number => {\n  if (t < 1 / 2) return inBounce(t * 2) * 0.5;\n  return outBounce(t * 2 - 1) * 0.5 + 0.5;\n};\n","enum ConnectionDirection {\n  IN = 'in',\n  OUT = 'out',\n}\n\nexport default ConnectionDirection;\n","import Color from 'color';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport Circle from '../../lib/geom/Circle';\nimport { linear, Easing } from '../../lib/easings';\nimport { lerp } from '../../lib/utils';\n\ntype PulseOptions = {\n  x: number;\n  y: number;\n  startRadius: number;\n  endRadius: number;\n  duration: number;\n  color: Color;\n  easeRadius?: Easing;\n  easeOpacity?: Easing;\n  removeOnComplete?: boolean;\n};\n\nexport default class Pulse extends SceneObject {\n  _circle: Circle;\n  _startRadius: number;\n  _endRadius: number;\n  _duration: number;\n  _color: Color;\n  _progress: number;\n  _easeRadius: Easing;\n  _easeOpacity: Easing;\n  _removeOnComplete: boolean;\n\n  constructor({\n    x,\n    y,\n    startRadius,\n    endRadius,\n    duration,\n    color,\n    easeRadius = linear,\n    easeOpacity = linear,\n    removeOnComplete = false,\n  }: PulseOptions) {\n    super();\n    this._circle = new Circle(x, y, startRadius);\n    this._startRadius = startRadius;\n    this._endRadius = endRadius;\n    this._duration = duration;\n    this._color = color;\n    this._progress = 0;\n    this._easeRadius = easeRadius;\n    this._easeOpacity = easeOpacity;\n    this._removeOnComplete = removeOnComplete;\n  }\n\n  update(deltaTime: number) {\n    const deltaProgress = deltaTime / this._duration;\n    this._progress = Math.min(1, this._progress + deltaProgress);\n    this._circle = this._circle.withRadius(\n      lerp(\n        this._startRadius,\n        this._endRadius,\n        this._easeRadius(this._progress),\n      ),\n    );\n\n    if (this._progress === 1 && this._removeOnComplete) {\n      this.getScene().removeChild(this);\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    const opacity = this._easeOpacity(this._progress);\n    ctx.fillStyle = this._color.fade(opacity).toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n  }\n}\n","import Color from 'color';\n\n// https://coolors.co/f8ffe5-06d6a0-1b9aaa-ef476f-ffc43d\nexport const LIGHT_BG = new Color('#F8FFE5');\nexport const TEAL = new Color('#06D6A0');\nexport const BLUE = new Color('#1B9AAA');\nexport const RED = new Color('#EF476F');\nexport const YELLOW = new Color('#FFC43D');\n","import { sample } from '../lib/utils';\nimport Road from './Road';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class ConnectionSet {\n  incoming: Road[] = [];\n  outgoing: Road[] = [];\n\n  add(target: Road, direction: ConnectionDirection) {\n    switch (direction) {\n      case ConnectionDirection.IN:\n        this.addIncoming(target);\n        break;\n      case ConnectionDirection.OUT:\n        this.addOutgoing(target);\n        break;\n      default:\n        throw new Error(`unknow connection direction ${direction}`);\n    }\n  }\n\n  addIncoming(target: Road) {\n    this.incoming.push(target);\n  }\n\n  addOutgoing(target: Road) {\n    this.outgoing.push(target);\n  }\n\n  sampleIncoming(): Road {\n    return sample(this.incoming);\n  }\n\n  sampleOutgoing(): Road {\n    return sample(this.outgoing);\n  }\n}\n","// @flow\nimport { assert } from '../../lib/assert';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { inBack, reverse, linear } from '../../lib/easings';\nimport { constrain, mapRange } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { RED } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 1000;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst PULSE_RADIUS = 25;\n\nconst CLOCK_FADE_DURATION = 150;\nconst PULSE_DURATION = 500;\n\nconst MAIN_COLOR = RED.lighten(0.2).desaturate(0.5);\nconst CLOCK_COLOR = RED.darken(0.2);\nconst PULSE_COLOR = RED.lighten(0.2).fade(0.4);\n\nexport default class Consumer extends SceneObject implements NetworkNode {\n  isDestination = true;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number = 0;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return this._timer >= this._cooldown;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return [this];\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  consumeTraveller() {\n    assert(this.canConsumeTraveller, 'must be ready to consumer traveller');\n    this._resetTimer();\n    this._pulse();\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius * progress,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        endRadius: RADIUS,\n        startRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: inBack(4),\n        easeOpacity: reverse(linear),\n        removeOnComplete: true,\n      }),\n    );\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport Scene from './Scene';\n\nconst DEFAULT_NAME = '$$AbstractSceneSystem$$';\n\nexport default abstract class SceneSystem {\n  static systemName = DEFAULT_NAME;\n  private scene: Scene | null = null;\n\n  constructor() {\n    assert(\n      this.constructor !== SceneSystem,\n      'SceneSystem is an abstract class that must be extended',\n    );\n    assert(\n      (this.constructor as any).systemName !== DEFAULT_NAME,\n      'classes extending SceneSystem must override SceneSystem.systemName',\n    );\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene is required');\n    return this.scene;\n  }\n\n  afterAddToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeRemoveFromScene(scene: Scene) {\n    this.scene = null;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  beforeDraw(ctx: CanvasRenderingContext2D, time: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterDraw(ctx: CanvasRenderingContext2D, time: number) {}\n}\n","// @flow\nimport Scene from '../lib/scene/Scene';\nimport SceneSystem from '../lib/scene/SceneSystem';\nimport QuadTree from '../lib/QuadTree';\nimport Circle from '../lib/geom/Circle';\nimport AABB from '../lib/geom/AABB';\nimport Traveller from './Traveller';\n\nexport default class TravellerFinder extends SceneSystem {\n  static systemName = 'TravellerFinder';\n\n  _quadTree!: QuadTree<Traveller>;\n\n  removeTraveller(traveller: Traveller) {\n    this._quadTree.remove(traveller);\n  }\n\n  afterAddToScene(scene: Scene) {\n    super.afterAddToScene(scene);\n    this._quadTree = new QuadTree(\n      AABB.fromLeftTopRightBottom(0, 0, scene.width, scene.height),\n      traveller => traveller.position,\n    );\n  }\n\n  beforeUpdate() {\n    const scene = this.getScene();\n    this._quadTree.clear();\n    scene.children.forEach(child => {\n      if (child instanceof Traveller) {\n        this._quadTree.insert(child);\n      }\n    });\n    // this._quadTree.debugDraw('red');\n  }\n\n  findTravellersInCircle(circle: Circle) {\n    return this._quadTree.findItemsInCircle(circle);\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Road from './Road';\nimport { NetworkNode } from './networkNodes/NetworkNode';\n\nconst PathFinder = {\n  getNextRoad(initialNode: NetworkNode, destinationNode: NetworkNode): Road {\n    const remainingNodes = new Set(initialNode.getAllReachableNodes());\n    remainingNodes.add(initialNode);\n    assert(\n      remainingNodes.has(destinationNode),\n      'destination must be reachable',\n    );\n    const bestCosts = new Map();\n    const prevRoads = new Map();\n\n    bestCosts.set(initialNode, 0);\n\n    while (remainingNodes.size) {\n      const { node, cost } = PathFinder._nodeWithShortestDistance(\n        remainingNodes,\n        bestCosts,\n      );\n      remainingNodes.delete(node);\n\n      if (node === destinationNode) {\n        return PathFinder._nextRoadFromRoute(\n          prevRoads,\n          initialNode,\n          destinationNode,\n        );\n      }\n\n      PathFinder._updateNeighbours(node, bestCosts, cost, prevRoads);\n    }\n\n    throw new Error('unreachable i hope');\n  },\n\n  _nodeWithShortestDistance(\n    nodes: Set<NetworkNode>,\n    costs: Map<NetworkNode, number>,\n  ): { node: NetworkNode; cost: number } {\n    let bestCost = Infinity;\n    let bestNode = null;\n\n    nodes.forEach(node => {\n      const cost = costs.get(node);\n      if (cost != null && cost <= bestCost) {\n        bestCost = cost;\n        bestNode = node;\n      }\n    });\n\n    assert(bestNode, 'node must be found');\n    return { node: bestNode, cost: bestCost };\n  },\n  _updateNeighbours(\n    node: NetworkNode,\n    bestCosts: Map<NetworkNode, number>,\n    cost: number,\n    prevRoads: Map<NetworkNode, Road>,\n  ) {\n    node.outgoingConnections.forEach(road => {\n      const nextNode = road.to;\n      const nextNodeCost = bestCosts.get(nextNode);\n      const altNextNodeCost = cost + road.expectedTimeFromStartToEnd;\n      if (nextNodeCost == null || altNextNodeCost <= nextNodeCost) {\n        bestCosts.set(nextNode, altNextNodeCost);\n        prevRoads.set(nextNode, road);\n      }\n    });\n  },\n  _nextRoadFromRoute(\n    prevRoads: Map<NetworkNode, Road>,\n    start: NetworkNode,\n    finish: NetworkNode,\n  ): Road {\n    let node = finish;\n    while (prevRoads.has(node)) {\n      const road = prevRoads.get(node);\n      assert(road, 'road must exist');\n      node = road.from;\n      if (node === start) return road;\n    }\n\n    throw new Error('prev road must be found');\n  },\n};\n\nexport default PathFinder;\n","// @flow\nimport { assert } from '../../lib/assert';\nimport Vector2 from '../../lib/geom/Vector2';\nimport { uniq, flatten } from '../../lib/utils';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport PathFinder from '../PathFinder';\nimport Road from '../Road';\nimport Traveller from '../Traveller';\nimport { NetworkNode } from './NetworkNode';\n\nexport default class Intersection implements NetworkNode {\n  isDestination = false;\n  position: Vector2;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number) {\n    this.position = new Vector2(x, y);\n  }\n\n  get incomingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.outgoing;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return true;\n  }\n\n  consumeTraveller(traveller: Traveller) {\n    const destination = traveller.destination;\n    assert(destination, 'traveller must have destination');\n\n    const nextRoad = PathFinder.getNextRoad(this, destination);\n    assert(\n      this.outgoingConnections.includes(nextRoad),\n      'nextRoad must be from this intersection',\n    );\n\n    traveller.removeFromCurrentRoad();\n    nextRoad.addTravellerAtStart(traveller);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(): Vector2 {\n    return this.position;\n  }\n\n  getClosestOutgoingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.outgoingConnections.forEach(road => {\n      const traveller = road.getTravellerAfterPosition(-1);\n      if (traveller && traveller.positionOnCurrentRoad < shortestDistance) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.positionOnCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getClosestIncomingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.incomingConnections.forEach(road => {\n      const traveller = road.getTravellerBeforePosition(road.length);\n      if (\n        traveller &&\n        traveller.distanceToEndOfCurrentRoad < shortestDistance\n      ) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.distanceToEndOfCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n}\n","import { assert } from '../lib/assert';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { outBack, inBack } from '../lib/easings';\nimport { sample, constrain, mapRange, random } from '../lib/utils';\nimport TravellerFinder from './TravellerFinder';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Intersection from './networkNodes/Intersection';\nimport Road from './Road';\nimport Entity from '../lib/scene/Entity';\nimport { makeAbsolutePal } from '../pals/makePal';\nimport { PalAbsoluteController } from '../pals/PalController';\n\n// const TRAVELLER_COLOR = BLUE.fade(0.4);\n// const TRAVELLER_RADIUS = 14;\nconst MIN_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MAX_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MIN_TRAVELLER_SAFE_RADIUS = 30;\nconst MAX_TRAVELLER_SAFE_RADIUS = 30;\nconst NEARBY_RADIUS = 200;\n\nconst INITIAL_SPEED = 5;\nconst MAX_SPEED = 80;\nconst ACCELERATION = 200;\nconst DECELERATION = -200;\nconst ROAD_END_OVERSHOOT = 0;\n\nconst PATIENCE = 1500;\nconst FORCE_ACCELERATE_DURATION = 100;\n\nconst ENTER_DURATION = 400;\nconst EXIT_DURATION = 400;\n\nconst enterEase = outBack(3);\nconst exitEase = inBack(3);\n\nenum StopReason {\n  STOPPED_FOR_DESTINATION = 'STOPPED_FOR_DESTINATION',\n  STOPPED_FOR_TRAFFIC_IN_FRONT = 'STOPPED_FOR_TRAFFIC_IN_FRONT',\n  STOPPED_FOR_TRAFFIC_NEARBY = 'STOPPED_FOR_TRAFFIC_NEARBY',\n}\n\nexport default class Traveller extends SceneObject {\n  static MAX_SPEED = MAX_SPEED;\n  static StopReason = StopReason;\n\n  comfortableRadius = random(\n    MIN_TRAVELLER_COMFORTABLE_RADIUS,\n    MAX_TRAVELLER_COMFORTABLE_RADIUS,\n  );\n  safeRadius = random(MIN_TRAVELLER_SAFE_RADIUS, MAX_TRAVELLER_SAFE_RADIUS);\n  _currentRoad: Road | null = null;\n  _destination: NetworkNode | null = null;\n  _positionOnCurrentRoad: number = 0;\n  _speed: number = INITIAL_SPEED;\n  _age: number = 0;\n  _exitStartedAt: number | null = null;\n  _stoppedTime: number = 0;\n  _forceAccelerateTimer: number = 0;\n  _stopReason: StopReason | null = null;\n  _stoppedFor: Traveller[] = [];\n  _pal: Entity | null = null;\n\n  get currentRoad(): Road | null {\n    return this._currentRoad;\n  }\n\n  get position(): Vector2 {\n    assert(this._currentRoad, 'currentRoad must be defined');\n    return this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad);\n  }\n\n  // get predictedPositionInDirectionOfTravel(): Vector2 {\n  //   assert(this._currentRoad, 'currentRoad must be defined');\n  //   return this._getPredictedPointForPosition(\n  //     this._currentRoad,\n  //     this._positionOnCurrentRoad + 1,\n  //   );\n  // }\n\n  get predictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition);\n  }\n\n  get predictedStopArea(): Circle {\n    const center = this.predictedStopPoint;\n    return new Circle(center.x, center.y, this.safeRadius);\n  }\n\n  get potentialNextPredictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition + 1);\n  }\n\n  get positionOnCurrentRoad(): number {\n    return this._positionOnCurrentRoad;\n  }\n\n  get distanceToEndOfCurrentRoad(): number {\n    assert(this._currentRoad, 'traveller is not on a road');\n    return this._currentRoad.length - this._positionOnCurrentRoad;\n  }\n\n  get destination(): NetworkNode | null {\n    return this._destination;\n  }\n\n  get speed(): number {\n    return this._speed;\n  }\n\n  get isStopped(): boolean {\n    return this.speed === 0;\n  }\n\n  get stoppedTime(): number {\n    return this._stoppedTime;\n  }\n\n  get stopReason(): StopReason | null {\n    return this._stopReason;\n  }\n\n  isStoppedFor(other: Traveller): boolean {\n    return this._stoppedFor.includes(other);\n  }\n\n  onAddedToRoad(road: Road) {\n    this._currentRoad = road;\n    this._positionOnCurrentRoad = 0;\n    if (!this._destination) {\n      this._pickDestination();\n    }\n  }\n\n  onRemovedFromRoad() {\n    this.getScene()\n      .getSystem(TravellerFinder)\n      .removeTraveller(this);\n    this._currentRoad = null;\n  }\n\n  onRemovedFromScene() {\n    this.removeFromCurrentRoad();\n  }\n\n  removeFromCurrentRoad() {\n    if (this._currentRoad) this._currentRoad.removeTraveller(this);\n  }\n\n  update(dtMilliseconds: number) {\n    this._age += dtMilliseconds;\n    this._stopReason = null;\n    this._stoppedFor = [];\n\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._move(dtMilliseconds, currentRoad);\n\n    const pal = this._getPal();\n    pal\n      .getComponent(PalAbsoluteController)\n      .setPosition(\n        this.position,\n        currentRoad.getAngleAtPosition(this._positionOnCurrentRoad),\n        dtMilliseconds / 1000,\n      );\n    pal.update(dtMilliseconds);\n\n    this._getEnterTransitionScale();\n    // if (window.debugDraw) this._debugDraw();\n\n    this._checkAtEndOfRoad(currentRoad);\n    this._checkExit();\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number) {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._getPal().draw(ctx, elapsedTime);\n\n    // const position = this.position;\n    // const scale =\n    //   this._getEnterTransitionScale() * this._getExitTransitionScale();\n\n    // ctx.beginPath();\n    // ctx.fillStyle = TRAVELLER_COLOR.toString();\n    // ShapeHelpers.circle(ctx, position.x, position.y, TRAVELLER_RADIUS * scale);\n    // ctx.fill();\n  }\n\n  getSortOrder(): number {\n    return this.position.y;\n  }\n\n  get _isExiting(): boolean {\n    return this._exitStartedAt !== null;\n  }\n\n  _getPal(): Entity {\n    if (!this._pal) {\n      this._pal = makeAbsolutePal(this.position);\n    }\n\n    return this._pal;\n  }\n\n  // _debugDraw() {\n  //   const currentRoad = this._currentRoad;\n  //   if (!currentRoad) return;\n\n  //   const predictedStopPoint = this.predictedStopPoint;\n  //   new Circle(\n  //     this.position.x,\n  //     this.position.y,\n  //     this.comfortableRadius\n  //   ).debugDraw(\"rgba(0, 255, 0, 0.4)\");\n  //   new Circle(this.position.x, this.position.y, this.safeRadius).debugDraw(\n  //     this._forceAccelerateTimer ? \"cyan\" : \"red\"\n  //   );\n  //   predictedStopPoint.debugDraw(\"lime\");\n  //   this.predictedStopArea.debugDraw(\"rgba(255, 0, 255, 0.5)\");\n\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.fillText(\n  //     `${this.id} ${Math.round(this._stoppedTime)}`,\n  //     this.position.x,\n  //     this.position.y\n  //   );\n  // }\n\n  _getEnterTransitionScale() {\n    return enterEase(\n      constrain(0, 1, mapRange(0, ENTER_DURATION, 0, 1, this._age)),\n    );\n  }\n\n  _getExitTransitionScale() {\n    if (this._exitStartedAt === null) return 1;\n    return (\n      1 -\n      exitEase(\n        constrain(\n          0,\n          1,\n          mapRange(\n            this._exitStartedAt,\n            this._exitStartedAt + EXIT_DURATION,\n            0,\n            1,\n            this._age,\n          ),\n        ),\n      )\n    );\n  }\n\n  _getPredictedStopPositionIfDecelerating(): number {\n    const timeToStop = -this._speed / DECELERATION;\n    return (\n      this._positionOnCurrentRoad +\n      this._speed * timeToStop +\n      0.5 * DECELERATION * timeToStop * timeToStop\n    );\n  }\n\n  _getPredictedPointForPosition(currentRoad: Road, position: number): Vector2 {\n    if (position <= currentRoad.length) {\n      return currentRoad.getPointAtPosition(position);\n    }\n\n    const overshoot = position - currentRoad.length;\n    const overshootAngle = currentRoad.getAngleAtPosition(currentRoad.length);\n    return Vector2.fromPolar(overshootAngle, overshoot).add(currentRoad.end);\n  }\n\n  _pickDestination() {\n    if (!this._currentRoad) return;\n    const potentialDestinations = this._currentRoad\n      .getAllReachableNodes()\n      .filter(node => node.isDestination);\n    const destination = sample(potentialDestinations);\n    this._destination = destination;\n  }\n\n  _move(dtMilliseconds: number, currentRoad: Road) {\n    const dtSeconds = dtMilliseconds / 1000;\n\n    this._forceAccelerateTimer = constrain(\n      0,\n      FORCE_ACCELERATE_DURATION,\n      this._forceAccelerateTimer - dtMilliseconds,\n    );\n\n    if (\n      this._forceAccelerateTimer <= 0 &&\n      this._shouldDecelerate(currentRoad)\n    ) {\n      this._accelerate(DECELERATION, dtSeconds, currentRoad);\n    } else {\n      this._accelerate(ACCELERATION, dtSeconds, currentRoad);\n    }\n\n    if (this._speed === 0) {\n      this._stoppedTime += dtMilliseconds;\n    } else {\n      this._stoppedTime = 0;\n    }\n  }\n\n  _shouldDecelerate(currentRoad: Road): boolean {\n    const predictedStopPosition = this._getPredictedStopPositionIfDecelerating();\n    if (\n      currentRoad.to === this._destination &&\n      currentRoad.length + ROAD_END_OVERSHOOT < predictedStopPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_DESTINATION;\n      return true;\n    }\n\n    const nextTravellerOnRoad = currentRoad.getTravellerAfterPosition(\n      this._positionOnCurrentRoad,\n    );\n\n    const safeStopAheadPosition =\n      predictedStopPosition + this.comfortableRadius;\n\n    if (\n      nextTravellerOnRoad &&\n      nextTravellerOnRoad.positionOnCurrentRoad < safeStopAheadPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n      this._stoppedFor.push(nextTravellerOnRoad);\n      return true;\n    }\n\n    if (currentRoad.to instanceof Intersection) {\n      const intersection = currentRoad.to;\n      const outgoingTraveller = intersection.getClosestOutgoingTraveller();\n      if (outgoingTraveller) {\n        const outgoingTravellerPosition =\n          currentRoad.length + outgoingTraveller.positionOnCurrentRoad;\n\n        if (outgoingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(outgoingTraveller);\n          return true;\n        }\n      }\n\n      const incomingTraveller = intersection.getClosestIncomingTraveller();\n      if (incomingTraveller && incomingTraveller !== this) {\n        const incomingTravellerPosition =\n          currentRoad.length - incomingTraveller.distanceToEndOfCurrentRoad;\n        if (incomingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(incomingTraveller);\n          return true;\n        }\n      }\n    }\n\n    if (this._shouldDecelerateForNearbyTravellers(currentRoad)) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_NEARBY;\n      return true;\n    }\n\n    // const currentPoint = this.position;\n    // const currentSafeCircle = new Circle(\n    //   currentPoint.x,\n    //   currentPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     currentSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    // const predictedStopPoint = this._getPredictedStopPointIfDecelerating(\n    //   currentRoad,\n    // );\n    // const predictedSafeCircle = new Circle(\n    //   predictedStopPoint.x,\n    //   predictedStopPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     predictedSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    return false;\n  }\n\n  _shouldDecelerateForNearbyTravellers(currentRoad: Road): boolean {\n    const travellerFinder = this.getScene().getSystem(TravellerFinder);\n    const stopArea = this.predictedStopArea;\n    const stopPoint = stopArea.center;\n    const nextStopPoint = this.potentialNextPredictedStopPoint;\n    const searchArea = stopArea.withRadius(NEARBY_RADIUS);\n    const nearbyTravellers = travellerFinder.findTravellersInCircle(searchArea);\n\n    for (const other of nearbyTravellers) {\n      // cannot crash into self\n      if (other === this) continue;\n\n      // if we both started breaking now, we would be a safe distance so we're fine\n      const otherStopArea = other.predictedStopArea;\n      const otherStopPoint = otherStopArea.center;\n      if (!stopArea.intersectsCircle(otherStopArea)) continue;\n\n      // currently we think other will stop at the center of otherStopArea.\n      // otherNextStopPoint is one pixel further forward based other's current\n      // heading\n      const otherNextStopPoint = other.potentialNextPredictedStopPoint;\n\n      // if we're moving away from each other, everything is fine:\n      const currentStopDistance = stopPoint.distanceTo(otherStopArea.center);\n      const nextStopDistance = nextStopPoint.distanceTo(otherNextStopPoint);\n      if (nextStopDistance > currentStopDistance) continue;\n\n      // who is moving in a direction that's headed more towards the other's\n      // stop position? if they're moving towards me but i'm moving more\n      // orthagonally relative to them, they should slow down\n      const approachAmount = stopPoint.distanceTo(otherNextStopPoint);\n      const otherApproachAmount = otherStopPoint.distanceTo(nextStopPoint);\n      if (approachAmount < otherApproachAmount) {\n        continue;\n      }\n\n      // so we know we're moving towards them faster than they're moving\n      // towards us, but how much? If it's barely any and we're not already too\n      // close to them, we could just keep going\n      if (\n        approachAmount - otherApproachAmount <\n        0.15\n        // approachAmount > this.safeRadius * 0.8\n      ) {\n        continue;\n      }\n\n      // if there's a clash... just randomly tie-break\n      if (approachAmount === otherApproachAmount) {\n        return Math.random() < 0.5;\n      }\n\n      // if we've been waiting around for fuckin ever just slam that fuckin\n      // pedal to the floor like ugh (in reality just nudge forward a little)\n      // (unless the other one is stopped to cus otherwise we'll just crash)\n      if (this._stoppedTime > PATIENCE && !other.isStopped) {\n        this._forceAcceleration();\n        return false;\n      }\n\n      // attempt to break deadlocks. i guess this is the equivalent of 'other'\n      // waving at the current traveller to continue\n      if (other.isStoppedFor(this)) continue;\n\n      this._stoppedFor.push(other);\n    }\n\n    if (this._stoppedFor.length) return true;\n\n    return false;\n  }\n\n  // _shouldDecelerateForTravellersInCircle(currentRoad: Road, circle: Circle) {\n  //   const travellerFinder = this.getScene().getSystem(TravellerFinder);\n  //   const overlappingTravellers = travellerFinder.findTravellersInCircle(\n  //     circle,\n  //   );\n\n  //   const currentPosition = this.position;\n  //   const nextPosition = this.predictedPositionInDirectionOfTravel;\n\n  //   const clashingTravellers = overlappingTravellers.filter(other => {\n  //     if (other === this) return false;\n  //     if (other.currentRoad === currentRoad) return false;\n\n  // const currentDistance = currentPosition.distanceTo(other.position);\n  // const nextDistance = nextPosition.distanceTo(other.position);\n\n  // const isGettingCloser = nextDistance < currentDistance;\n  // if (!isGettingCloser) return false;\n\n  // const otherNextPosition = other.predictedPositionInDirectionOfTravel;\n  // const otherNextDistance = currentPosition.distanceTo(otherNextPosition);\n  // const thisMoveDelta = nextDistance - currentDistance;\n  // const otherMoveDelta = otherNextDistance - currentDistance;\n  // if (thisMoveDelta < otherMoveDelta) return true;\n\n  // if (this.isStopped && !other.isStopped) return true;\n\n  // if (this.isStopped && other.isStopped) {\n  //   if (this.stoppedTime === other.stoppedTime && this.id < other.id)\n  //     return false;\n  //   if (this.stoppedTime < other.stoppedTime) return false;\n  // }\n\n  //     return true;\n  //   });\n\n  //   return clashingTravellers.length > 0;\n  // }\n\n  _forceAcceleration() {\n    this._forceAccelerateTimer = FORCE_ACCELERATE_DURATION;\n  }\n\n  _accelerate(acceleration: number, dtSeconds: number, currentRoad: Road) {\n    const lastSpeed = this._speed;\n    this._speed = constrain(\n      0,\n      MAX_SPEED,\n      this._speed + acceleration * dtSeconds,\n    );\n    const avgSpeed = (lastSpeed + this._speed) / 2;\n    this._positionOnCurrentRoad = constrain(\n      0,\n      currentRoad.length,\n      this._positionOnCurrentRoad + avgSpeed * dtSeconds,\n    );\n  }\n\n  _checkAtEndOfRoad(currentRoad: Road) {\n    if (this._positionOnCurrentRoad === currentRoad.length) {\n      if (this._isExiting) return;\n      this._onReachEndOfCurrentRoad(currentRoad);\n    }\n  }\n\n  _checkExit() {\n    if (this._isExiting) {\n      assert(this._exitStartedAt);\n      if (this._age >= this._exitStartedAt + EXIT_DURATION) {\n        this._onExit();\n      }\n    }\n  }\n\n  _onReachEndOfCurrentRoad(currentRoad: Road) {\n    const nextNode = currentRoad.to;\n    const destination = this._destination;\n    if (nextNode.canConsumeTraveller) {\n      nextNode.consumeTraveller(this);\n      if (nextNode === destination) {\n        this._onReachDestination();\n      }\n    }\n  }\n\n  _onReachDestination() {\n    this._exit();\n  }\n\n  _onExit() {\n    this.getScene().removeChild(this);\n  }\n\n  _exit() {\n    this._exitStartedAt = this._age;\n  }\n}\n","import Entity from '../lib/scene/Entity';\nimport { PalTargetController, PalAbsoluteController } from './PalController';\nimport Vector2 from '../lib/geom/Vector2';\nimport { generateRandomPalConfig } from './PalConfig';\nimport PalGeom from './PalGeom';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport PalRenderer from './PalRenderer';\n\nexport function makeTargetPal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalTargetController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n\nexport function makeAbsolutePal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalAbsoluteController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n","// @flow\nimport SceneObject from '../lib/scene/SceneObject';\nimport Path from '../lib/geom/Path';\nimport StraightPathSegment from '../lib/geom/StraightPathSegment';\nimport Vector2 from '../lib/geom/Vector2';\nimport * as ShapeHelpers from '../lib/canvasShapeHelpers';\nimport { YELLOW } from './colors';\nimport ConnectionDirection from './ConnectionDirection';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Junction from './Junction';\nimport Traveller from './Traveller';\n\n// const ROAD_OUTER_COLOR = BLUE;\n// const ROAD_INNER_COLOR = LIGHT_BG;\nconst ROAD_DASH_COLOR = YELLOW.darken(0.2);\n// const ROAD_OUTER_WIDTH = 12;\n// const ROAD_INNER_WIDTH = 13;\nconst ROAD_DASH_WIDTH = 3;\nconst ROAD_IDEAL_DASH = [5, 10];\nconst ROAD_IDEAL_DASH_LENGTH = ROAD_IDEAL_DASH.reduce((a, b) => a + b, 0);\nconst ROAD_DASH_SPEED = 0.05;\n\nexport type RoadOptions = {\n  autoRound?: number;\n  points?: Array<Vector2>;\n  path?: Path;\n};\n\nexport default class Road extends SceneObject {\n  isNode = false;\n  from: NetworkNode;\n  to: NetworkNode;\n  _path: Path;\n  _currentTravellers: Traveller[] = [];\n\n  constructor(\n    from: NetworkNode | Junction,\n    to: NetworkNode | Junction,\n    { points, autoRound, path }: RoadOptions = {},\n  ) {\n    super();\n\n    const angleFrom = points\n      ? from.position.angleTo(points[0])\n      : from.position.angleTo(to.position);\n\n    const angleTo = points\n      ? to.position.angleTo(points[points.length - 1])\n      : to.position.angleTo(from.position);\n\n    if (path) {\n      this._path = path;\n    } else if (points) {\n      this._path = Path.straightThroughPoints(\n        from.getVisualConnectionPointAtAngle(angleFrom),\n        ...points,\n        to.getVisualConnectionPointAtAngle(angleTo),\n      );\n    } else {\n      this._path = new Path().addSegment(\n        new StraightPathSegment(\n          from.getVisualConnectionPointAtAngle(angleFrom),\n          to.getVisualConnectionPointAtAngle(angleTo),\n        ),\n      );\n    }\n\n    if (autoRound != null) {\n      this._path.autoRound(autoRound);\n    }\n\n    if (from instanceof Junction) {\n      this.from = from.connectToRoadAtAngle(\n        this,\n        angleFrom,\n        ConnectionDirection.OUT,\n      );\n    } else {\n      this.from = from;\n      from.connectTo(this, ConnectionDirection.OUT);\n    }\n\n    if (to instanceof Junction) {\n      this.to = to.connectToRoadAtAngle(this, angleTo, ConnectionDirection.IN);\n    } else {\n      this.to = to;\n      to.connectTo(this, ConnectionDirection.IN);\n    }\n  }\n\n  get length(): number {\n    return this._path.getLength();\n  }\n\n  get start(): Vector2 {\n    return this._path.getStart();\n  }\n\n  get end(): Vector2 {\n    return this._path.getEnd();\n  }\n\n  get expectedTimeFromStartToEnd(): number {\n    if (this._currentTravellers.length) {\n      const avgSpeed =\n        this._currentTravellers.reduce(\n          (sum, traveller) => sum + traveller.speed,\n          0,\n        ) / this._currentTravellers.length;\n      return this.length / avgSpeed;\n    }\n\n    return this.length / (Traveller.MAX_SPEED * 0.7);\n  }\n\n  canAddTravellerAtStart(): boolean {\n    const nextTraveller = this.getTravellerAfterPosition(0);\n    if (!nextTraveller) return true;\n    return (\n      nextTraveller.positionOnCurrentRoad > nextTraveller.comfortableRadius\n    );\n  }\n\n  addTravellerAtStart(traveller: Traveller) {\n    this._currentTravellers.push(traveller);\n    traveller.onAddedToRoad(this);\n  }\n\n  removeTraveller(traveller: Traveller): boolean {\n    const index = this._currentTravellers.indexOf(traveller);\n    if (index === -1) return false;\n    this.removeTravellerAtIndex(index);\n    return true;\n  }\n\n  removeTravellerAtIndex(index: number): Traveller {\n    const traveller = this._currentTravellers[index];\n    this._currentTravellers.splice(index, 1);\n    traveller.onRemovedFromRoad();\n    return traveller;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    const nodes = [] as Array<NetworkNode>;\n    if (visited.has(this.to)) return nodes;\n    return [...this.to.getAllReachableNodes(visited), this.to];\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    return this._path.getPointAtPosition(position);\n  }\n\n  getAngleAtPosition(position: number): number {\n    return this._path.getAngleAtPosition(position);\n  }\n\n  getTravellerAfterPosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = traveller.positionOnCurrentRoad - position;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getTravellerBeforePosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = position - traveller.positionOnCurrentRoad;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, time: number) {\n    ctx.beginPath();\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ShapeHelpers.path(ctx, this._path);\n\n    // ctx.strokeStyle = ROAD_OUTER_COLOR.toString();\n    // ctx.lineWidth = ROAD_OUTER_WIDTH;\n    // ctx.stroke();\n\n    // ctx.strokeStyle = ROAD_INNER_COLOR.toString();\n    // ctx.lineWidth = ROAD_INNER_WIDTH;\n    // ctx.stroke();\n\n    const dashScale = this._getLineDashScale();\n    const dashLength = ROAD_IDEAL_DASH_LENGTH * dashScale;\n    ctx.setLineDash(ROAD_IDEAL_DASH.map(length => length * dashScale));\n    ctx.strokeStyle = ROAD_DASH_COLOR.toString();\n    ctx.lineDashOffset = (-time * ROAD_DASH_SPEED * dashScale) % dashLength;\n    ctx.lineWidth = ROAD_DASH_WIDTH;\n    // ctx.strokeStyle = 'black';\n    // ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  _getLineDashScale(): number {\n    const wholeDashCount = Math.floor(this.length / ROAD_IDEAL_DASH_LENGTH);\n    const wholeDashLength = wholeDashCount * ROAD_IDEAL_DASH_LENGTH;\n\n    const roundDownLength = this.length - wholeDashLength;\n    const roundUpLength =\n      wholeDashLength + ROAD_IDEAL_DASH_LENGTH - this.length;\n\n    const dashScale =\n      roundDownLength < roundUpLength\n        ? this.length / wholeDashLength\n        : this.length / (wholeDashLength + ROAD_IDEAL_DASH_LENGTH);\n\n    return dashScale;\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport { constrain, compact } from '../utils';\nimport Circle from './Circle';\nimport Vector2 from './Vector2';\nimport StraightPathSegment from './StraightPathSegment';\nimport CirclePathSegment from './CirclePathSegment';\nimport Line2 from './Line2';\n\nexport interface PathSegment {\n  getStart(): Vector2;\n  getEnd(): Vector2;\n  getLength(): number;\n  getPointAtPosition(position: number): Vector2;\n  getAngleAtPosition(position: number): number;\n}\n\nexport default class Path implements PathSegment {\n  static straightThroughPoints(...points: ReadonlyArray<Vector2>): Path {\n    let [lastPoint, ...remainingPoints] = points;\n    const path = new Path();\n\n    for (const point of remainingPoints) {\n      path.addSegment(new StraightPathSegment(lastPoint, point));\n      lastPoint = point;\n    }\n\n    return path;\n  }\n\n  static segmentAcrossCircle(\n    containingCircle: Circle,\n    entryAngle: number,\n    exitAngle: number,\n  ): CirclePathSegment | StraightPathSegment {\n    entryAngle = entryAngle + Math.PI;\n    const entryPoint = containingCircle.pointOnCircumference(entryAngle);\n    const exitPoint = containingCircle.pointOnCircumference(exitAngle);\n\n    const entryLineNormal = new Line2(\n      containingCircle.center,\n      entryPoint,\n    ).perpendicularLineThroughPoint(entryPoint);\n    const exitLineNormal = new Line2(\n      containingCircle.center,\n      exitPoint,\n    ).perpendicularLineThroughPoint(exitPoint);\n\n    if (entryLineNormal.isParallelTo(exitLineNormal)) {\n      return new StraightPathSegment(entryPoint, exitPoint);\n    }\n\n    const roadCircleCenter = entryLineNormal.pointAtIntersectionWith(\n      exitLineNormal,\n    );\n    const roadCircleRadius = entryPoint.distanceTo(roadCircleCenter);\n\n    // containingCircle.center.debugDraw('lime');\n    // roadCircleCenter.debugDraw('blue');\n    // entryPoint.debugDraw('magenta');\n    // exitPoint.debugDraw('red');\n\n    return new CirclePathSegment(\n      roadCircleCenter,\n      roadCircleRadius,\n      entryPoint.sub(roadCircleCenter).angle,\n      exitPoint.sub(roadCircleCenter).angle,\n    );\n  }\n\n  segments: PathSegment[] = [];\n\n  constructor(...segments: PathSegment[]) {\n    this.addSegments(...segments);\n  }\n\n  getStart(): Vector2 {\n    return this.segments[0].getStart();\n  }\n\n  getEnd(): Vector2 {\n    return this.segments[this.segments.length - 1].getEnd();\n  }\n\n  getLength(): number {\n    return this.segments.reduce(\n      (length, segment) => length + segment.getLength(),\n      0,\n    );\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getPointAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  getAngleAtPosition(position: number): number {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getAngleAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  addSegment(segment: PathSegment): this {\n    const lastSegment = this.segments[this.segments.length - 1];\n    if (lastSegment) {\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        `segments must neatly join together - ${lastSegment\n          .getEnd()\n          .toString()} !== ${segment.getStart().toString()}`,\n      );\n    }\n    this.segments.push(segment);\n    return this;\n  }\n\n  addSegments(...segments: PathSegment[]): this {\n    segments.forEach(segment => this.addSegment(segment));\n    return this;\n  }\n\n  autoRound(radius: number): this {\n    const newSegments = this.segments.map((segment, i): PathSegment | null => {\n      const lastSegment = i === 0 ? null : this.segments[i - 1];\n      if (!lastSegment) {\n        if (segment instanceof StraightPathSegment) return null;\n        return segment;\n      }\n\n      if (!(segment instanceof StraightPathSegment)) return segment;\n      if (!(lastSegment instanceof StraightPathSegment)) return null;\n\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        'segments must join',\n      );\n\n      const entryAngle = lastSegment.angle;\n      const exitAngle = segment.angle;\n      const usableRadius = Math.min(\n        radius,\n        lastSegment.getLength() / 2,\n        segment.getLength() / 2,\n      );\n\n      const containingCircle = new Circle(\n        segment.getStart().x,\n        segment.getStart().y,\n        usableRadius,\n      );\n\n      return Path.segmentAcrossCircle(containingCircle, entryAngle, exitAngle);\n    });\n\n    const compacted = compact(newSegments);\n\n    const start = this.getStart();\n    const end = this.getEnd();\n    let lastPoint = start;\n    this.segments = [];\n\n    compacted.forEach(segment => {\n      if (segment.getStart().equals(lastPoint)) {\n        this.addSegment(segment);\n      } else {\n        this.addSegment(new StraightPathSegment(lastPoint, segment.getStart()));\n        this.addSegment(segment);\n      }\n\n      lastPoint = segment.getEnd();\n    });\n\n    if (!lastPoint.equals(end)) {\n      this.addSegment(new StraightPathSegment(lastPoint, end));\n    }\n\n    return this;\n  }\n}\n","// @flow\nimport { compact } from '../lib/utils';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Scene from '../lib/scene/Scene';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\nimport Path from '../lib/geom/Path';\nimport Road from './Road';\nimport Intersection from './networkNodes/Intersection';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class Junction extends SceneObject {\n  _circle: Circle;\n  _intersectionsByAngle: { [angleString: string]: Intersection } = {};\n  _incomingIntersections: Set<Intersection> = new Set();\n  _outgoingIntersections: Set<Intersection> = new Set();\n  _roads: Road[] = [];\n\n  constructor(x: number, y: number, radius: number) {\n    super();\n    this._circle = new Circle(x, y, radius);\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    this._roads.forEach(road => scene.addChild(road));\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._circle.pointOnCircumference(radians);\n  }\n\n  connectToRoadAtAngle(\n    road: Road,\n    angle: number,\n    direction: ConnectionDirection,\n  ): Intersection {\n    const intersection = this._intersectionAtAngle(angle);\n    intersection.connectTo(road, direction);\n\n    const isIncoming =\n      direction === ConnectionDirection.IN ||\n      this._incomingIntersections.has(intersection);\n\n    const isOutgoing =\n      direction === ConnectionDirection.OUT ||\n      this._outgoingIntersections.has(intersection);\n\n    if (isIncoming) this._incomingIntersections.add(intersection);\n    if (isOutgoing) this._outgoingIntersections.add(intersection);\n\n    this._intersections.forEach(other => {\n      if (other === intersection) return;\n\n      if (isIncoming && this._outgoingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(intersection.position).angle,\n            other.position.sub(this._circle.center).angle,\n          ),\n        );\n\n        this._addRoad(new Road(intersection, other, { path }));\n      }\n\n      if (isOutgoing && this._incomingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(other.position).angle,\n            intersection.position.sub(this._circle.center).angle,\n          ),\n        );\n        this._addRoad(new Road(other, intersection, { path }));\n      }\n    });\n\n    return intersection;\n  }\n\n  _intersectionAtAngle(angle: number): Intersection {\n    const angleStr = angle.toString();\n    if (this._intersectionsByAngle[angleStr]) {\n      return this._intersectionsByAngle[angleStr];\n    }\n\n    const intersection = this._createIntersectionAtAngle(angle);\n    this._intersectionsByAngle[angleStr] = intersection;\n    return intersection;\n  }\n\n  _createIntersectionAtAngle(angle: number): Intersection {\n    const position = this.getVisualConnectionPointAtAngle(angle);\n    return new Intersection(position.x, position.y);\n  }\n\n  get _intersections(): Intersection[] {\n    return compact(\n      Object.keys(this._intersectionsByAngle).map(\n        angle => this._intersectionsByAngle[angle],\n      ),\n    );\n  }\n\n  _addRoad(road: Road) {\n    this._roads.push(road);\n    if (this.hasScene()) {\n      this.getScene().addChild(road);\n    }\n  }\n}\n","// @flow\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { outSine } from '../../lib/easings';\nimport { mapRange, constrain, flatten, uniq } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { TEAL } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Traveller from '../Traveller';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 500;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst CLOCK_RADIUS = RADIUS * 0.7;\nconst PULSE_RADIUS = 35;\n\nconst PULSE_DURATION = 500;\nconst CLOCK_FADE_DURATION = 150;\n\nconst MAIN_COLOR = TEAL.lighten(0.1);\nconst CLOCK_COLOR = TEAL.darken(0.1);\nconst PULSE_COLOR = TEAL.lighten(0.2).fade(0.1);\n\nexport default class Producer extends SceneObject implements NetworkNode {\n  isDestination = false;\n  canConsumeTraveller = false;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n    this._timer = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()) {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  consumeTraveller() {\n    throw new Error('producer cannot consume traveller');\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n    if (this._timer >= this._cooldown) {\n      this._onTimerEnd();\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ctx.arc(\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n      -Math.PI / 2,\n      progress * 2 * Math.PI - Math.PI / 2,\n      false,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = MAIN_COLOR.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      CLOCK_RADIUS,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _onTimerEnd() {\n    const didEmitTraveller = this._attemptEmitTraveller();\n    if (didEmitTraveller) {\n      this._pulse();\n      this._resetTimer();\n    }\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        startRadius: RADIUS,\n        endRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: outSine,\n        removeOnComplete: true,\n      }),\n    );\n  }\n\n  _attemptEmitTraveller(): boolean {\n    const road = this._connectionSet.sampleOutgoing();\n    if (!(road instanceof Road)) return false;\n\n    if (road.canAddTravellerAtStart()) {\n      const traveller = new Traveller();\n      road.addTravellerAtStart(traveller);\n      this.getScene().addChild(traveller);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Scene from '../lib/scene/Scene';\nimport Consumer from './networkNodes/Consumer';\nimport Producer from './networkNodes/Producer';\nimport Road from './Road';\nimport Junction from './Junction';\n// import DebugOverlay from \"./systems/DebugOverlay\";\nimport TravellerFinder from './TravellerFinder';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst ROUND = 50;\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nconst root = document.getElementById('root');\nassert(root, '#root must be present');\nscene.appendTo(root);\n\n// scene.addSystem(new DebugOverlay());\nscene.addSystem(new TravellerFinder());\n\nscenario3();\n\nscene.start();\n\nfunction scenario1() {\n  const producer1 = new Producer(100, 100, 500);\n  // const producer2 = new Consumer(100, 300, 2500);\n  const consumer1 = new Consumer(400, 200, 1500);\n  const consumer2 = new Consumer(250, 200, 1500);\n  scene.addChild(producer1);\n  // scene.addChild(producer2);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n\n  const junction1 = new Junction(250, 100, ROUND);\n  scene.addChild(junction1);\n  scene.addChild(new Road(producer1, junction1));\n  scene.addChild(\n    new Road(junction1, consumer1, {\n      points: [new Vector2(400, 100)],\n      autoRound: ROUND,\n    }),\n  );\n  scene.addChild(new Road(junction1, consumer2));\n\n  // const path2 = new Path();\n  // path2.addSegments(\n  //   new StraightPathSegment(new Vector2(130, 300), new Vector2(380, 300)),\n  //   new CirclePathSegment(new Vector2(380, 280), 20, Math.PI * 0.5, 0),\n  //   new StraightPathSegment(new Vector2(400, 280), new Vector2(400, 230)),\n  // );\n  // const road2 = new Road(producer2, consumer1, path2);\n  // scene.addChild(road2);\n}\n\nfunction scenario2() {\n  const producer = new Producer(100, 300, 500);\n  const junction = new Junction(300, 300, ROUND);\n  const consumer1 = new Consumer(300, 100, 5000);\n  const consumer2 = new Consumer(500, 300, 5000);\n  const consumer3 = new Consumer(300, 500, 5000);\n\n  scene.addChild(new Road(producer, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  scene.addChild(producer);\n  scene.addChild(junction);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n}\n\nfunction scenario3() {\n  const northConsumer = new Consumer(300, 550, 1500);\n  const middleConsumer = new Consumer(100, 450, 1500);\n  const southConsumer = new Consumer(100, 250, 1500);\n  const eastProducer = new Producer(600, 150, 500);\n  const westProducer = new Producer(100, 100, 500);\n  // const westProducer = new Producer(250, 250, 100);\n\n  scene.addChild(northConsumer);\n  scene.addChild(middleConsumer);\n  scene.addChild(southConsumer);\n  scene.addChild(eastProducer);\n  scene.addChild(westProducer);\n\n  const mainJunction = new Junction(300, 150, ROUND);\n  const eastProducerSplit = new Junction(500, 370, ROUND);\n  const southConsumerJoin = new Junction(330, 400, ROUND);\n  scene.addChild(mainJunction);\n  scene.addChild(eastProducerSplit);\n  scene.addChild(southConsumerJoin);\n  scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(eastProducer, eastProducerSplit));\n  scene.addChild(new Road(eastProducerSplit, southConsumerJoin));\n  // scene.addChild(\n  //   new Road(eastProducerSplit, mainJunction, {\n  //     points: [[600, 280], [700, 50], [450, 180], [450, 100], [300, 20]],\n  //     // points: [[400, 100]],\n  //     autoRound: 50,\n  //   }),\n  // );\n  scene.addChild(\n    new Road(eastProducerSplit, mainJunction, {\n      points: [new Vector2(400, 300), new Vector2(500, 50)],\n      autoRound: ROUND,\n    }),\n  );\n\n  // scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(mainJunction, southConsumerJoin));\n  scene.addChild(new Road(southConsumerJoin, northConsumer));\n  scene.addChild(new Road(mainJunction, middleConsumer));\n  scene.addChild(new Road(mainJunction, southConsumer));\n}\n\nfunction scenario4() {\n  const producer1 = new Producer(100, 100, 1000);\n  const producer2 = new Producer(300, 200, 1000);\n  const producer3 = new Producer(100, 300, 1000);\n  // const producer4 = new Producer(400, 100, 1000);\n  const consumer1 = new Consumer(300, 100, 1000);\n  const consumer2 = new Consumer(100, 200, 1000);\n  const consumer3 = new Consumer(300, 300, 1000);\n  // const consumer4 = new Consumer(430, 300, 1000);\n  scene.addChild(producer1);\n  scene.addChild(producer2);\n  scene.addChild(producer3);\n  // scene.addChild(producer4);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n  // scene.addChild(consumer4);\n\n  const junction = new Junction(200, 200, 30);\n  scene.addChild(junction);\n\n  scene.addChild(new Road(producer1, junction));\n  scene.addChild(new Road(producer2, junction));\n  scene.addChild(new Road(producer3, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  // scene.addChild(\n  //   new Road(producer4, consumer4, {\n  //     points: [[400, 250], [415, 250], [415, 150], [430, 150]],\n  //     autoRound: 30,\n  //   }),\n  // );\n}\n\nfunction scenario6() {\n  const producer = new Producer(300, 50, 1500).addTo(scene);\n  const consumer = new Consumer(500, 50, 100).addTo(scene);\n  new Road(producer, consumer, {\n    points: [\n      new Vector2(350, 150),\n      new Vector2(150, 350),\n      new Vector2(400, 500),\n      new Vector2(650, 350),\n      new Vector2(450, 150),\n    ],\n    autoRound: 400,\n  }).addTo(scene);\n}\n"],"names":["$59a0c505bb74e522$var$UnitBezier","x1","y1","x2","y2","cx","bx","cy","by","ax","ay","key","t","this","x","epsilon","i","NEWTON_METHOD_ITERATIONS","sampleCurveX","$8pNpe","approxEq","dx","sampleCurveDerivativeX","lo","hi","param","DEFAULT_EPSILON","sampleCurveY","solveCurveX","ConnectionDirection","$59a0c505bb74e522$export$5523e35ab8ae283a","n","$59a0c505bb74e522$export$101a56202f2aee9f","Math","sin","PI","$59a0c505bb74e522$export$46cc86e91d1dfb63","s","$99b518519a0c3ba5$export$9099ad97b570f7c","SceneObject","y","startRadius","endRadius","duration","color","_easeRadius","easeRadius","_easeOpacity","easeOpacity","_removeOnComplete","removeOnComplete","call","_circle","$a5M8K","default","_startRadius","_endRadius","_duration","_color","_progress","deltaTime","deltaProgress","min","withRadius","lerp","getScene","removeChild","ctx","beginPath","opacity","fillStyle","fade","toString","$ao5QL","circle","center","radius","fill","$bApi3","$3a116eaa35f3b140$export$5aa0848f4abbb9a4","$parcel$interopDefault","$aG1uz","$3a116eaa35f3b140$export$1d121502596d3ac9","$3a116eaa35f3b140$export$5fac07ad2bc2fd13","$ef145c306c90c8a0$var$ConnectionDirection","$ef145c306c90c8a0$export$9099ad97b570f7c","$d9e6ae6a28d855e4$export$9099ad97b570f7c","incoming","outgoing","target","direction","IN","addIncoming","OUT","addOutgoing","Error","concat","push","sample","$50012ad990a1dc22$var$MAIN_COLOR","lighten","desaturate","$50012ad990a1dc22$var$CLOCK_COLOR","darken","$50012ad990a1dc22$var$PULSE_COLOR","$50012ad990a1dc22$export$9099ad97b570f7c","cooldown","isDestination","_timer","_connectionSet","_visualConnectionCircle","_cooldown","radians","pointOnCircumference","Set","add","node","$diH60","assert","canConsumeTraveller","_resetTimer","_pulse","delta","constrain","progress","colorMixAmount","mapRange","bgColor","mix","moveTo","easing","addChildBefore","$f1394be5d7c387ca$var$DEFAULT_NAME","$f1394be5d7c387ca$export$9099ad97b570f7c","scene","constructor","systemName","time","$0a458b2002f0923e$export$9099ad97b570f7c","SceneSystem","apply","arguments","traveller","_quadTree","remove","prototype","$REUuP","$7B1qO","fromLeftTopRightBottom","width","height","position","clear","children","forEach","child","$524f1d0ddc2389e6$export$9099ad97b570f7c","insert","bind","findItemsInCircle","$64d2a1f0bf116509$var$PathFinder","getNextRoad","initialNode","destinationNode","remainingNodes","getAllReachableNodes","has","bestCosts","Map","prevRoads","set","size","ref","_nodeWithShortestDistance","cost","delete","_nextRoadFromRoute","_updateNeighbours","nodes","costs","bestCost","Infinity","bestNode","get","outgoingConnections","road","nextNode","to","nextNodeCost","altNextNodeCost","expectedTimeFromStartToEnd","start","finish","from","$64d2a1f0bf116509$export$9099ad97b570f7c","$f5a5d60428f511fb$export$9099ad97b570f7c","$54lVR","destination","nextRoad","includes","removeFromCurrentRoad","addTravellerAtStart","visited","uniq","flatten","map","bestTraveller","shortestDistance","getTravellerAfterPosition","positionOnCurrentRoad","incomingConnections","getTravellerBeforePosition","length","distanceToEndOfCurrentRoad","StopReason","$524f1d0ddc2389e6$var$DECELERATION","$524f1d0ddc2389e6$var$enterEase","$524f1d0ddc2389e6$var$exitEase","$524f1d0ddc2389e6$var$StopReason","comfortableRadius","random","safeRadius","_currentRoad","_destination","_positionOnCurrentRoad","_speed","_age","_exitStartedAt","_stoppedTime","_forceAccelerateTimer","_stopReason","_stoppedFor","_pal","getPointAtPosition","currentRoad","stopPosition","_getPredictedStopPositionIfDecelerating","_getPredictedPointForPosition","predictedStopPoint","speed","other","_pickDestination","getSystem","removeTraveller","dtMilliseconds","_move","pal","_getPal","getComponent","$6zCnW","PalAbsoluteController","setPosition","getAngleAtPosition","update","_getEnterTransitionScale","_checkAtEndOfRoad","_checkExit","elapsedTime","draw","$ej7qu","addComponent","config","$ecJps","generateRandomPalConfig","$cw897","setAnimationController","$9hDxd","$27vvT","$e0a01ed5a40af034$export$fd5ea85005084744","timeToStop","overshoot","overshootAngle","fromPolar","end","potentialDestinations","filter","dtSeconds","_shouldDecelerate","_accelerate","predictedStopPosition","STOPPED_FOR_DESTINATION","nextTravellerOnRoad","safeStopAheadPosition","STOPPED_FOR_TRAFFIC_IN_FRONT","intersection","outgoingTraveller","getClosestOutgoingTraveller","incomingTraveller","getClosestIncomingTraveller","_shouldDecelerateForNearbyTravellers","STOPPED_FOR_TRAFFIC_NEARBY","travellerFinder","stopArea","predictedStopArea","stopPoint","nextStopPoint","potentialNextPredictedStopPoint","searchArea","nearbyTravellers","findTravellersInCircle","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","otherStopArea","otherStopPoint","intersectsCircle","otherNextStopPoint","currentStopDistance","distanceTo","approachAmount","otherApproachAmount","isStopped","_forceAcceleration","isStoppedFor","err","return","acceleration","lastSpeed","avgSpeed","_isExiting","_onReachEndOfCurrentRoad","_onExit","consumeTraveller","_onReachDestination","_exit","MAX_SPEED","_Path","$c7128419978d06ad$export$9099ad97b570f7c","_len","segments","Array","_key","addSegments","$eUMMJ","toConsumableArray","getStart","getEnd","reduce","segment","getLength","constrained","soFar","lastSegment","equals","addSegment","newSegments","$laB6d","entryAngle","angle","exitAngle","usableRadius","containingCircle","segmentAcrossCircle","compacted","compact","lastPoint","points","_points","toArray","remainingPoints","slice","path","point","entryPoint","exitPoint","entryLineNormal","$7RPk8","perpendicularLineThroughPoint","exitLineNormal","isParallelTo","roadCircleCenter","pointAtIntersectionWith","roadCircleRadius","$bJddX","sub","$8ea3a6d17a83c1b9$export$9099ad97b570f7c","_intersectionsByAngle","_incomingIntersections","_outgoingIntersections","_roads","addChild","_intersectionAtAngle","connectTo","isIncoming","isOutgoing","_intersections","_addRoad","$be544bd7440514dd$export$9099ad97b570f7c","angleStr","_createIntersectionAtAngle","getVisualConnectionPointAtAngle","Object","keys","hasScene","$be544bd7440514dd$var$ROAD_DASH_COLOR","$be544bd7440514dd$var$ROAD_IDEAL_DASH","$be544bd7440514dd$var$ROAD_IDEAL_DASH_LENGTH","a","b","autoRound","isNode","_currentTravellers","angleFrom","angleTo","_this","_path","straightThroughPoints","connectToRoadAtAngle","assertThisInitialized","sum","nextTraveller","onAddedToRoad","index","indexOf","removeTravellerAtIndex","splice","onRemovedFromRoad","bestDistance","distance","lineCap","lineJoin","dashScale","_getLineDashScale","dashLength","setLineDash","strokeStyle","lineDashOffset","lineWidth","stroke","wholeDashLength","floor","$3bf3099501bc8467$var$MAIN_COLOR","$3bf3099501bc8467$var$CLOCK_COLOR","$3bf3099501bc8467$var$PULSE_COLOR","$3bf3099501bc8467$export$9099ad97b570f7c","_onTimerEnd","arc","$3bf3099501bc8467$var$RADIUS","_attemptEmitTraveller","sampleOutgoing","canAddTravellerAtStart","$29085779e87ad61e$var$ROUND","$29085779e87ad61e$var$scene","$i9QUB","window","devicePixelRatio","$29085779e87ad61e$var$root","document","getElementById","appendTo","addSystem","northConsumer","middleConsumer","southConsumer","eastProducer","westProducer","mainJunction","eastProducerSplit","southConsumerJoin","$29085779e87ad61e$var$scenario3"],"version":3,"file":"index.49192d35.js.map"}