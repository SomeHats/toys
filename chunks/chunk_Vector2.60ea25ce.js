import{f as E,e as M,g as m,k as b,n as P,l as x}from"./chunk_assert.a61dfbc1.js";const o={ok(t){return new $(t)},error(t){return new v(t)},collect(t){const r=[];for(const e of t)if(e.isOk())r.push(e.value);else return e;return o.ok(r)}};class y{constructor(){}}class $ extends y{constructor(r){super(),this.value=r}isOk(){return!0}isError(){return!1}unwrap(){return this.value}map(r){return o.ok(r(this.value))}mapErr(r){return this}andThen(r){return r(this.value)}}class v extends y{constructor(r){super(),this.error=r}isOk(){return!1}isError(){return!0}unwrap(r){E(`${r}: ${String(this.error)}`)}map(r){return this}mapErr(r){return o.error(r(this.error))}andThen(r){return this}}class u{constructor(r,e=[]){this.message=r,this.path=e}formatPath(){let r="ROOT";for(const e of r)typeof e=="number"?r+=`[${e}]`:r+=`.${e}`;return r}toString(){return`At ${this.formatPath()}: ${this.message}`}}function w(t){return r=>typeof r===t?o.ok(r):o.error(new u(`Expected ${t}, got ${typeof r}`,[]))}function d(t,r){return new u(t.message,[r,...t.path])}const R=w("string"),p=w("number");function S(t){return r=>Array.isArray(r)?o.collect(r.map((e,n)=>t(e).mapErr(a=>d(a,n)))):o.error(new u(`Expected Array, got ${typeof r}`,[]))}function O(t){return r=>typeof r!="object"?o.error(new u(`Expected object, got ${typeof r}`,[])):r===null?o.error(new u("Expected object, got null",[])):o.collect(M(t).map(([e,n])=>n(m(r,e)).map(a=>[e,a]).mapErr(a=>d(a,e)))).map(e=>Object.fromEntries(e))}function I(t,r){return e=>typeof e!="object"?o.error(new u(`Expected object, got ${typeof e}`,[])):e===null?o.error(new u("Expected object, got null",[])):o.collect(b(e).map(n=>t(n).andThen(a=>r(m(e,a)).map(i=>[a,i])).mapErr(a=>d(a,n)))).map(n=>Object.fromEntries(n))}function T(t,r){return e=>t(e).andThen(r)}const s=class{constructor(t,r){this.x=t,this.y=r}static fromPolar(t,r){return new s(r*Math.cos(t),r*Math.sin(t))}static average(t){return t.reduce((e,n)=>e.add(n),s.ZERO).div(t.length)}static fromVectorLike({x:t,y:r}){return new s(t,r)}static fromEvent({clientX:t,clientY:r}){return new s(t,r)}toString(t){return`Vector2(${t==null?this.x:this.x.toFixed(t)}, ${t==null?this.y:this.y.toFixed(t)})`}get magnitudeSquared(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.magnitudeSquared)}get angle(){return Math.atan2(this.y,this.x)}isInPolygon(t){const{x:r,y:e}=this;let n=!1;for(let a=0,i=t.length-1;a<t.length;i=a++){const{x:l,y:c}=t[a],{x:g,y:f}=t[i];c>e!=f>e&&r<(g-l)*(e-c)/(f-c)+l&&(n=!n)}return n}equals(t){return this===t||this.x===t.x&&this.y===t.y}distanceTo({x:t,y:r}){return Math.hypot(this.x-t,this.y-r)}distanceToSq({x:t,y:r}){const e=this.x-t,n=this.y-r;return e*e+n*n}angleTo(t){return t.sub(this).angle}angleBetween(t){return P(Math.atan2(t.y,t.x)-Math.atan2(this.y,this.x))}dot(t){return this.x*t.x+this.y*t.y}div(t){return new s(this.x/t,this.y/t)}scale(t){return new s(this.x*t,this.y*t)}negate(){return this.scale(-1)}add({x:t,y:r}){return new s(this.x+t,this.y+r)}sub({x:t,y:r}){return new s(this.x-t,this.y-r)}floor(){return new s(Math.floor(this.x),Math.floor(this.y))}ceil(){return new s(Math.ceil(this.x),Math.ceil(this.y))}round(){return new s(Math.round(this.x),Math.round(this.y))}withMagnitude(t){return s.fromPolar(this.angle,t)}normalize(){return this.withMagnitude(1)}withAngle(t){return s.fromPolar(t,this.magnitude)}rotate(t){return this.withAngle(this.angle+t)}rotateAround(t,r){const e=Math.sin(r),n=Math.cos(r),a=this.x-t.x,i=this.y-t.y,l=a*n-i*e,c=a*e+i*n;return new s(l+t.x,c+t.y)}lerp(t,r){return new s(x(this.x,t.x,r),x(this.y,t.y,r))}perpendicular(){return new s(this.y,-this.x)}project(t,r){return t.scale(r).add(this)}};let h=s;h.ZERO=new s(0,0);h.UNIT=new s(1,1);h.X=new s(1,0);h.Y=new s(0,1);h.parse=T(O({x:p,y:p}),({x:t,y:r})=>o.ok(new s(t,r)));export{u as P,o as R,h as V,S as a,T as b,O as c,R as d,I as e,p};
