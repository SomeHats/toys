import{l as ut,s as k,a as l,z as _,m as b,A as tt,B as et,r as Y,C as nt}from"./chunk_assert.10ad1a9b.js";import{S as T,E as _t,a as gt}from"./chunk_Entity.dd44b762.js";import{C as f,L as X}from"./chunk_Circle.00352ec3.js";import{c as P,P as it,g as pt,a as mt,b as ft,d as At,S as m,C as Tt,p as Rt}from"./chunk_PalRenderer.7f9eef87.js";import{l as M,a as st,r as St,o as Ct,b as Pt}from"./chunk_easings.df3dc928.js";import{C as O}from"./chunk_index.dc2a5aeb.js";import{V as D}from"./chunk_Vector2.79af760a.js";import{S as Ot}from"./chunk_SceneSystem.6b6e2d96.js";import{A as S}from"./chunk_AABB.61e1191b.js";class ot extends T{constructor({x:t,y:e,startRadius:n,endRadius:i,duration:o,color:a,easeRadius:r=M,easeOpacity:c=M,removeOnComplete:d=!1}){super(),this._circle=f.create(t,e,n),this._startRadius=n,this._endRadius=i,this._duration=o,this._color=a,this._progress=0,this._easeRadius=r,this._easeOpacity=c,this._removeOnComplete=d}update(t){const e=t/this._duration;this._progress=Math.min(1,this._progress+e),this._circle=this._circle.withRadius(ut(this._startRadius,this._endRadius,this._easeRadius(this._progress))),this._progress===1&&this._removeOnComplete&&this.getScene().removeChild(this)}draw(t){t.beginPath();const e=this._easeOpacity(this._progress);t.fillStyle=this._color.fade(e).toString(),P(t,this._circle.center.x,this._circle.center.y,this._circle.radius),t.fill()}}new O("#F8FFE5");const $=new O("#06D6A0");new O("#1B9AAA");const q=new O("#EF476F"),Et=new O("#FFC43D");var g=(s=>(s.IN="in",s.OUT="out",s))(g||{});class W{constructor(){this.incoming=[],this.outgoing=[]}add(t,e){switch(e){case g.IN:this.addIncoming(t);break;case g.OUT:this.addOutgoing(t);break;default:throw new Error(`unknow connection direction ${e}`)}}addIncoming(t){this.incoming.push(t)}addOutgoing(t){this.outgoing.push(t)}sampleIncoming(){return k(this.incoming)}sampleOutgoing(){return k(this.outgoing)}}const It=1e3,K=20,vt=30,wt=25,bt=150,Dt=500,Ft=q.lighten(.2).desaturate(.5),j=q.darken(.2),Nt=q.lighten(.2).fade(.4);class U extends T{constructor(t,e,n=It){super(),this.isDestination=!0,this._timer=0,this._connectionSet=new W,this._circle=f.create(t,e,K),this._visualConnectionCircle=f.create(t,e,vt),this._cooldown=n}get position(){return this._circle.center}get canConsumeTraveller(){return this._timer>=this._cooldown}get incomingConnections(){return this._connectionSet.incoming}get outgoingConnections(){return this._connectionSet.outgoing}getVisualConnectionPointAtAngle(t){return this._visualConnectionCircle.pointOnCircumference(t)}getAllReachableNodes(t=new Set){return t.add(this),[this]}connectTo(t,e){this._connectionSet.add(t,e)}consumeTraveller(){l(this.canConsumeTraveller,"must be ready to consumer traveller"),this._resetTimer(),this._pulse()}update(t){this._timer=_(0,this._cooldown,this._timer+t)}draw(t){const e=this._timer/this._cooldown,n=_(0,1,b(0,bt,1,0,this._timer)),i=Ft.mix(j,n);t.beginPath(),t.fillStyle=i.toString(),P(t,this._circle.center.x,this._circle.center.y,this._circle.radius),t.fill(),t.beginPath(),t.fillStyle=j.toString(),t.moveTo(this._circle.center.x,this._circle.center.y),P(t,this._circle.center.x,this._circle.center.y,this._circle.radius*e),t.fill()}_resetTimer(){this._timer=0}_pulse(){this.getScene().addChildBefore(this,new ot({x:this._circle.center.x,y:this._circle.center.y,endRadius:K,startRadius:wt,duration:Dt,color:Nt,easeRadius:st(4),easeOpacity:St(M),removeOnComplete:!0}))}}const A=class{constructor(s,t){this._items=[],this._nextItemIndex=0,this._subdivisions=null,this.boundary=s,this._getPosition=t}insert(s){const t=this._getPosition(s);if(!this.boundary.contains(t))return!1;if(this._nextItemIndex<A.NODE_CAPACITY)return this._items[this._nextItemIndex]=s,this._nextItemIndex++,!0;const e=this._getSubdivisions();if(e[0].insert(s)||e[1].insert(s)||e[2].insert(s)||e[3].insert(s))return!0;throw new Error("Couldnt insert item")}remove(s){const t=this._getPosition(s);if(!this.boundary.contains(t))return!1;const e=this._items.indexOf(s);if(e!==-1)return this._items.splice(e,1),this._nextItemIndex--,!0;const n=this._subdivisions;return!!(n&&(n[0].remove(s)||n[1].remove(s)||n[2].remove(s)||n[3].remove(s)))}clear(){for(let s=0;s<this._nextItemIndex;s++)this._items[s]=void 0,this._nextItemIndex=0;this._subdivisions&&this._subdivisions.forEach(s=>s.clear())}findItemsInRect(s){const t=[];if(!this.boundary.intersects(s))return t;for(let n=0;n<this._nextItemIndex;n++){const i=this._items[n];if(i==null)continue;const o=this._getPosition(i);s.contains(o)&&t.push(i)}const e=this._subdivisions;return e&&(e[0].boundary.intersects(s)&&t.push(...e[0].findItemsInRect(s)),e[1].boundary.intersects(s)&&t.push(...e[1].findItemsInRect(s)),e[2].boundary.intersects(s)&&t.push(...e[2].findItemsInRect(s)),e[3].boundary.intersects(s)&&t.push(...e[3].findItemsInRect(s))),t}findItemsInCircle(s){return this.findItemsInRect(s.getBoundingBox()).filter(t=>s.containsPoint(this._getPosition(t)))}_getSubdivisions(){if(this._subdivisions)return this._subdivisions;const s=this.boundary.getCenter(),t=[new A(S.fromLeftTopRightBottom(this.boundary.left,this.boundary.top,s.x,s.y),this._getPosition),new A(S.fromLeftTopRightBottom(s.x,this.boundary.top,this.boundary.right,s.y),this._getPosition),new A(S.fromLeftTopRightBottom(this.boundary.left,s.y,s.x,this.boundary.bottom),this._getPosition),new A(S.fromLeftTopRightBottom(s.x,s.y,this.boundary.right,this.boundary.bottom),this._getPosition)];return this._subdivisions=t,t}};let rt=A;rt.NODE_CAPACITY=4;class F extends Ot{removeTraveller(t){this._quadTree.remove(t)}afterAddToScene(t){super.afterAddToScene(t),this._quadTree=new rt(S.fromLeftTopRightBottom(0,0,t.width,t.height),e=>e.position)}beforeUpdate(){const t=this.getScene();this._quadTree.clear(),t.children.forEach(e=>{e instanceof E&&this._quadTree.insert(e)})}findTravellersInCircle(t){return this._quadTree.findItemsInCircle(t)}}F.systemName="TravellerFinder";const w={getNextRoad(s,t){const e=new Set(s.getAllReachableNodes());e.add(s),l(e.has(t),"destination must be reachable");const n=new Map,i=new Map;for(n.set(s,0);e.size;){const{node:o,cost:a}=w._nodeWithShortestDistance(e,n);if(e.delete(o),o===t)return w._nextRoadFromRoute(i,s,t);w._updateNeighbours(o,n,a,i)}throw new Error("unreachable i hope")},_nodeWithShortestDistance(s,t){let e=1/0,n=null;return s.forEach(i=>{const o=t.get(i);o!=null&&o<=e&&(e=o,n=i)}),l(n,"node must be found"),{node:n,cost:e}},_updateNeighbours(s,t,e,n){s.outgoingConnections.forEach(i=>{const o=i.to,a=t.get(o),r=e+i.expectedTimeFromStartToEnd;(a==null||r<=a)&&(t.set(o,r),n.set(o,i))})},_nextRoadFromRoute(s,t,e){let n=e;for(;s.has(n);){const i=s.get(n);if(l(i,"road must exist"),n=i.from,n===t)return i}throw new Error("prev road must be found")}};class at{constructor(t,e){this.isDestination=!1,this._connectionSet=new W,this.position=new D(t,e)}get incomingConnections(){return this._connectionSet.incoming}get outgoingConnections(){return this._connectionSet.outgoing}get canConsumeTraveller(){return!0}consumeTraveller(t){const e=t.destination;l(e,"traveller must have destination");const n=w.getNextRoad(this,e);l(this.outgoingConnections.includes(n),"nextRoad must be from this intersection"),t.removeFromCurrentRoad(),n.addTravellerAtStart(t)}getAllReachableNodes(t=new Set){return t.add(this),tt(et(this._connectionSet.outgoing.map(e=>e.getAllReachableNodes(t))))}getVisualConnectionPointAtAngle(){return this.position}getClosestOutgoingTraveller(){let t=null,e=1/0;return this.outgoingConnections.forEach(n=>{const i=n.getTravellerAfterPosition(-1);i&&i.positionOnCurrentRoad<e&&(t=i,e=i.positionOnCurrentRoad)}),t}getClosestIncomingTraveller(){let t=null,e=1/0;return this.incomingConnections.forEach(n=>{const i=n.getTravellerBeforePosition(n.length);i&&i.distanceToEndOfCurrentRoad<e&&(t=i,e=i.distanceToEndOfCurrentRoad)}),t}connectTo(t,e){this._connectionSet.add(t,e)}}function Lt(s){const t=new _t;t.addComponent(it,s);const e=pt();return t.addComponent(mt,e).setAnimationController(new ft(e)),t.addComponent(At,e),t}const yt=60,xt=60,Ut=30,Bt=30,kt=200,Mt=5,ct=80,Vt=200,B=-200,$t=0,qt=1500,J=100,Wt=400,z=400,Ht=Ct(3),Yt=st(3);var ht=(s=>(s.STOPPED_FOR_DESTINATION="STOPPED_FOR_DESTINATION",s.STOPPED_FOR_TRAFFIC_IN_FRONT="STOPPED_FOR_TRAFFIC_IN_FRONT",s.STOPPED_FOR_TRAFFIC_NEARBY="STOPPED_FOR_TRAFFIC_NEARBY",s))(ht||{});class E extends T{constructor(){super(...arguments),this.comfortableRadius=Y(yt,xt),this.safeRadius=Y(Ut,Bt),this._currentRoad=null,this._destination=null,this._positionOnCurrentRoad=0,this._speed=Mt,this._age=0,this._exitStartedAt=null,this._stoppedTime=0,this._forceAccelerateTimer=0,this._stopReason=null,this._stoppedFor=[],this._pal=null}get currentRoad(){return this._currentRoad}get position(){return l(this._currentRoad,"currentRoad must be defined"),this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad)}get predictedStopPoint(){const t=this._currentRoad;l(t,"currentRoad must be defined");const e=this._getPredictedStopPositionIfDecelerating();return this._getPredictedPointForPosition(t,e)}get predictedStopArea(){const t=this.predictedStopPoint;return f.create(t.x,t.y,this.safeRadius)}get potentialNextPredictedStopPoint(){const t=this._currentRoad;l(t,"currentRoad must be defined");const e=this._getPredictedStopPositionIfDecelerating();return this._getPredictedPointForPosition(t,e+1)}get positionOnCurrentRoad(){return this._positionOnCurrentRoad}get distanceToEndOfCurrentRoad(){return l(this._currentRoad,"traveller is not on a road"),this._currentRoad.length-this._positionOnCurrentRoad}get destination(){return this._destination}get speed(){return this._speed}get isStopped(){return this.speed===0}get stoppedTime(){return this._stoppedTime}get stopReason(){return this._stopReason}isStoppedFor(t){return this._stoppedFor.includes(t)}onAddedToRoad(t){this._currentRoad=t,this._positionOnCurrentRoad=0,this._destination||this._pickDestination()}onRemovedFromRoad(){this.getScene().getSystem(F).removeTraveller(this),this._currentRoad=null}onRemovedFromScene(){this.removeFromCurrentRoad()}removeFromCurrentRoad(){this._currentRoad&&this._currentRoad.removeTraveller(this)}update(t){this._age+=t,this._stopReason=null,this._stoppedFor=[];const e=this._currentRoad;l(e,"current road must be defined"),this._move(t,e);const n=this._getPal();n.getComponent(it).setPosition(this.position,e.getAngleAtPosition(this._positionOnCurrentRoad),t/1e3),n.update(t),this._getEnterTransitionScale(),this._checkAtEndOfRoad(e),this._checkExit()}draw(t,e){const n=this._currentRoad;l(n,"current road must be defined"),this._getPal().draw(t,e)}getSortOrder(){return this.position.y}get _isExiting(){return this._exitStartedAt!==null}_getPal(){return this._pal||(this._pal=Lt(this.position)),this._pal}_getEnterTransitionScale(){return Ht(_(0,1,b(0,Wt,0,1,this._age)))}_getExitTransitionScale(){return this._exitStartedAt===null?1:1-Yt(_(0,1,b(this._exitStartedAt,this._exitStartedAt+z,0,1,this._age)))}_getPredictedStopPositionIfDecelerating(){const t=-this._speed/B;return this._positionOnCurrentRoad+this._speed*t+.5*B*t*t}_getPredictedPointForPosition(t,e){if(e<=t.length)return t.getPointAtPosition(e);const n=e-t.length,i=t.getAngleAtPosition(t.length);return D.fromPolar(i,n).add(t.end)}_pickDestination(){if(!this._currentRoad)return;const t=this._currentRoad.getAllReachableNodes().filter(n=>n.isDestination),e=k(t);this._destination=e}_move(t,e){const n=t/1e3;this._forceAccelerateTimer=_(0,J,this._forceAccelerateTimer-t),this._forceAccelerateTimer<=0&&this._shouldDecelerate(e)?this._accelerate(B,n,e):this._accelerate(Vt,n,e),this._speed===0?this._stoppedTime+=t:this._stoppedTime=0}_shouldDecelerate(t){const e=this._getPredictedStopPositionIfDecelerating();if(t.to===this._destination&&t.length+$t<e)return this._stopReason="STOPPED_FOR_DESTINATION",!0;const n=t.getTravellerAfterPosition(this._positionOnCurrentRoad),i=e+this.comfortableRadius;if(n&&n.positionOnCurrentRoad<i)return this._stopReason="STOPPED_FOR_TRAFFIC_IN_FRONT",this._stoppedFor.push(n),!0;if(t.to instanceof at){const o=t.to,a=o.getClosestOutgoingTraveller();if(a&&t.length+a.positionOnCurrentRoad<i)return this._stopReason="STOPPED_FOR_TRAFFIC_IN_FRONT",this._stoppedFor.push(a),!0;const r=o.getClosestIncomingTraveller();if(r&&r!==this&&t.length-r.distanceToEndOfCurrentRoad<i)return this._stopReason="STOPPED_FOR_TRAFFIC_IN_FRONT",this._stoppedFor.push(r),!0}return this._shouldDecelerateForNearbyTravellers(t)?(this._stopReason="STOPPED_FOR_TRAFFIC_NEARBY",!0):!1}_shouldDecelerateForNearbyTravellers(t){const e=this.getScene().getSystem(F),n=this.predictedStopArea,i=n.center,o=this.potentialNextPredictedStopPoint,a=n.withRadius(kt),r=e.findTravellersInCircle(a);for(const c of r){if(c===this)continue;const d=c.predictedStopArea,N=d.center;if(!n.intersectsCircle(d))continue;const I=c.potentialNextPredictedStopPoint,L=i.distanceTo(d.center);if(o.distanceTo(I)>L)continue;const y=i.distanceTo(I),x=N.distanceTo(o);if(!(y<x)&&!(y-x<.15)){if(y===x)return Math.random()<.5;if(this._stoppedTime>qt&&!c.isStopped)return this._forceAcceleration(),!1;c.isStoppedFor(this)||this._stoppedFor.push(c)}}return!!this._stoppedFor.length}_forceAcceleration(){this._forceAccelerateTimer=J}_accelerate(t,e,n){const i=this._speed;this._speed=_(0,ct,this._speed+t*e);const o=(i+this._speed)/2;this._positionOnCurrentRoad=_(0,n.length,this._positionOnCurrentRoad+o*e)}_checkAtEndOfRoad(t){if(this._positionOnCurrentRoad===t.length){if(this._isExiting)return;this._onReachEndOfCurrentRoad(t)}}_checkExit(){this._isExiting&&(l(this._exitStartedAt,"Assertion Error: this._exitStartedAt"),this._age>=this._exitStartedAt+z&&this._onExit())}_onReachEndOfCurrentRoad(t){const e=t.to,n=this._destination;e.canConsumeTraveller&&(e.consumeTraveller(this),e===n&&this._onReachDestination())}_onReachDestination(){this._exit()}_onExit(){this.getScene().removeChild(this)}_exit(){this._exitStartedAt=this._age}}E.MAX_SPEED=ct;E.StopReason=ht;class p{constructor(...t){this.segments=[],this.addSegments(...t)}static straightThroughPoints(...t){let[e,...n]=t;const i=new p;for(const o of n)i.addSegment(new m(e,o)),e=o;return i}static segmentAcrossCircle(t,e,n){e=e+Math.PI;const i=t.pointOnCircumference(e),o=t.pointOnCircumference(n),a=new X(t.center,i).perpendicularLineThroughPoint(i),r=new X(t.center,o).perpendicularLineThroughPoint(o);if(a.isParallelTo(r))return new m(i,o);const c=a.pointAtIntersectionWith(r),d=i.distanceTo(c);return new Tt(c,d,i.sub(c).angle(),o.sub(c).angle())}getStart(){return this.segments[0].getStart()}getEnd(){return this.segments[this.segments.length-1].getEnd()}getLength(){return this.segments.reduce((t,e)=>t+e.getLength(),0)}getPointAtPosition(t){const e=_(0,this.getLength(),t);let n=0;for(const i of this.segments){if(e<=n+i.getLength())return i.getPointAtPosition(e-n);n+=i.getLength()}throw new Error("this is supposed to be unreachable oops")}getAngleAtPosition(t){const e=_(0,this.getLength(),t);let n=0;for(const i of this.segments){if(e<=n+i.getLength())return i.getAngleAtPosition(e-n);n+=i.getLength()}throw new Error("this is supposed to be unreachable oops")}addSegment(t){const e=this.segments[this.segments.length-1];return e&&l(e.getEnd().equals(t.getStart()),`segments must neatly join together - ${e.getEnd().toString()} !== ${t.getStart().toString()}`),this.segments.push(t),this}addSegments(...t){return t.forEach(e=>this.addSegment(e)),this}autoRound(t){const e=this.segments.map((r,c)=>{const d=c===0?null:this.segments[c-1];if(!d)return r instanceof m?null:r;if(!(r instanceof m))return r;if(!(d instanceof m))return null;l(d.getEnd().equals(r.getStart()),"segments must join");const N=d.angle(),I=r.angle(),L=Math.min(t,d.getLength()/2,r.getLength()/2),H=f.create(r.getStart().x,r.getStart().y,L);return p.segmentAcrossCircle(H,N,I)}),n=nt(e),i=this.getStart(),o=this.getEnd();let a=i;return this.segments=[],n.forEach(r=>{r.getStart().equals(a)?this.addSegment(r):(this.addSegment(new m(a,r.getStart())),this.addSegment(r)),a=r.getEnd()}),a.equals(o)||this.addSegment(new m(a,o)),this}}class C extends T{constructor(t,e,n){super(),this._intersectionsByAngle={},this._incomingIntersections=new Set,this._outgoingIntersections=new Set,this._roads=[],this._circle=f.create(t,e,n)}get position(){return this._circle.center}onAddedToScene(t){super.onAddedToScene(t),this._roads.forEach(e=>t.addChild(e))}getVisualConnectionPointAtAngle(t){return this._circle.pointOnCircumference(t)}connectToRoadAtAngle(t,e,n){const i=this._intersectionAtAngle(e);i.connectTo(t,n);const o=n===g.IN||this._incomingIntersections.has(i),a=n===g.OUT||this._outgoingIntersections.has(i);return o&&this._incomingIntersections.add(i),a&&this._outgoingIntersections.add(i),this._intersections.forEach(r=>{if(r!==i){if(o&&this._outgoingIntersections.has(r)){const c=new p(p.segmentAcrossCircle(this._circle,this._circle.center.sub(i.position).angle(),r.position.sub(this._circle.center).angle()));this._addRoad(new u(i,r,{path:c}))}if(a&&this._incomingIntersections.has(r)){const c=new p(p.segmentAcrossCircle(this._circle,this._circle.center.sub(r.position).angle(),i.position.sub(this._circle.center).angle()));this._addRoad(new u(r,i,{path:c}))}}}),i}_intersectionAtAngle(t){const e=t.toString();if(this._intersectionsByAngle[e])return this._intersectionsByAngle[e];const n=this._createIntersectionAtAngle(t);return this._intersectionsByAngle[e]=n,n}_createIntersectionAtAngle(t){const e=this.getVisualConnectionPointAtAngle(t);return new at(e.x,e.y)}get _intersections(){return nt(Object.keys(this._intersectionsByAngle).map(t=>this._intersectionsByAngle[t]))}_addRoad(t){this._roads.push(t),this.hasScene()&&this.getScene().addChild(t)}}const Xt=Et.darken(.2),Kt=3,lt=[5,10],R=lt.reduce((s,t)=>s+t,0),jt=.05;class u extends T{constructor(t,e,{points:n,autoRound:i,path:o}={}){super(),this.isNode=!1,this._currentTravellers=[];const a=n?t.position.angleTo(n[0]):t.position.angleTo(e.position),r=n?e.position.angleTo(n[n.length-1]):e.position.angleTo(t.position);o?this._path=o:n?this._path=p.straightThroughPoints(t.getVisualConnectionPointAtAngle(a),...n,e.getVisualConnectionPointAtAngle(r)):this._path=new p().addSegment(new m(t.getVisualConnectionPointAtAngle(a),e.getVisualConnectionPointAtAngle(r))),i!=null&&this._path.autoRound(i),t instanceof C?this.from=t.connectToRoadAtAngle(this,a,g.OUT):(this.from=t,t.connectTo(this,g.OUT)),e instanceof C?this.to=e.connectToRoadAtAngle(this,r,g.IN):(this.to=e,e.connectTo(this,g.IN))}get length(){return this._path.getLength()}get start(){return this._path.getStart()}get end(){return this._path.getEnd()}get expectedTimeFromStartToEnd(){if(this._currentTravellers.length){const t=this._currentTravellers.reduce((e,n)=>e+n.speed,0)/this._currentTravellers.length;return this.length/t}return this.length/(E.MAX_SPEED*.7)}canAddTravellerAtStart(){const t=this.getTravellerAfterPosition(0);return t?t.positionOnCurrentRoad>t.comfortableRadius:!0}addTravellerAtStart(t){this._currentTravellers.push(t),t.onAddedToRoad(this)}removeTraveller(t){const e=this._currentTravellers.indexOf(t);return e===-1?!1:(this.removeTravellerAtIndex(e),!0)}removeTravellerAtIndex(t){const e=this._currentTravellers[t];return this._currentTravellers.splice(t,1),e.onRemovedFromRoad(),e}getAllReachableNodes(t=new Set){const e=[];return t.has(this.to)?e:[...this.to.getAllReachableNodes(t),this.to]}getPointAtPosition(t){return this._path.getPointAtPosition(t)}getAngleAtPosition(t){return this._path.getAngleAtPosition(t)}getTravellerAfterPosition(t){let e=null,n=1/0;return this._currentTravellers.forEach(i=>{const o=i.positionOnCurrentRoad-t;o<=0||o<n&&(n=o,e=i)}),e}getTravellerBeforePosition(t){let e=null,n=1/0;return this._currentTravellers.forEach(i=>{const o=t-i.positionOnCurrentRoad;o<=0||o<n&&(n=o,e=i)}),e}draw(t,e){t.beginPath(),t.lineCap="round",t.lineJoin="round",Rt(t,this._path);const n=this._getLineDashScale(),i=R*n;t.setLineDash(lt.map(o=>o*n)),t.strokeStyle=Xt.toString(),t.lineDashOffset=-e*jt*n%i,t.lineWidth=Kt,t.stroke()}_getLineDashScale(){const e=Math.floor(this.length/R)*R,n=this.length-e,i=e+R-this.length;return n<i?this.length/e:this.length/(e+R)}}const Jt=500,V=20,zt=30,Gt=V*.7,Qt=35,Zt=500,te=150,G=$.lighten(.1),Q=$.darken(.1),ee=$.lighten(.2).fade(.1);class Z extends T{constructor(t,e,n=Jt){super(),this.isDestination=!1,this.canConsumeTraveller=!1,this._connectionSet=new W,this._circle=f.create(t,e,V),this._visualConnectionCircle=f.create(t,e,zt),this._cooldown=n,this._timer=n}get position(){return this._circle.center}get incomingConnections(){return this._connectionSet.incoming}get outgoingConnections(){return this._connectionSet.outgoing}getAllReachableNodes(t=new Set){return t.add(this),tt(et(this._connectionSet.outgoing.map(e=>e.getAllReachableNodes(t))))}getVisualConnectionPointAtAngle(t){return this._visualConnectionCircle.pointOnCircumference(t)}consumeTraveller(){throw new Error("producer cannot consume traveller")}connectTo(t,e){this._connectionSet.add(t,e)}update(t){this._timer=_(0,this._cooldown,this._timer+t),this._timer>=this._cooldown&&this._onTimerEnd()}draw(t){const e=this._timer/this._cooldown,n=_(0,1,b(0,te,1,0,this._timer)),i=G.mix(Q,n);t.beginPath(),t.fillStyle=i.toString(),P(t,this._circle.center.x,this._circle.center.y,this._circle.radius),t.fill(),t.beginPath(),t.fillStyle=Q.toString(),t.moveTo(this._circle.center.x,this._circle.center.y),t.arc(this._circle.center.x,this._circle.center.y,this._circle.radius,-Math.PI/2,e*2*Math.PI-Math.PI/2,!1),t.fill(),t.beginPath(),t.fillStyle=G.toString(),P(t,this._circle.center.x,this._circle.center.y,Gt),t.fill()}_resetTimer(){this._timer=0}_onTimerEnd(){this._attemptEmitTraveller()&&(this._pulse(),this._resetTimer())}_pulse(){this.getScene().addChildBefore(this,new ot({x:this._circle.center.x,y:this._circle.center.y,startRadius:V,endRadius:Qt,duration:Zt,color:ee,easeRadius:Pt,removeOnComplete:!0}))}_attemptEmitTraveller(){const t=this._connectionSet.sampleOutgoing();if(!(t instanceof u))return!1;if(t.canAddTravellerAtStart()){const e=new E;return t.addTravellerAtStart(e),this.getScene().addChild(e),!0}else return!1}}const v=50,h=new gt(800,600,window.devicePixelRatio),dt=document.getElementById("root");l(dt,"#root must be present");h.appendTo(dt);h.addSystem(new F);ne();h.start();function ne(){const s=new U(300,550,1500),t=new U(100,450,1500),e=new U(100,250,1500),n=new Z(600,150,500),i=new Z(100,100,500);h.addChild(s),h.addChild(t),h.addChild(e),h.addChild(n),h.addChild(i);const o=new C(300,150,v),a=new C(500,370,v),r=new C(330,400,v);h.addChild(o),h.addChild(a),h.addChild(r),h.addChild(new u(i,o)),h.addChild(new u(n,a)),h.addChild(new u(a,r)),h.addChild(new u(a,o,{points:[new D(400,300),new D(500,50)],autoRound:v})),h.addChild(new u(o,r)),h.addChild(new u(r,s)),h.addChild(new u(o,t)),h.addChild(new u(o,e))}
