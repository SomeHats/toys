{"mappings":"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","sources":["src/lib/QuadTree.ts"],"sourcesContent":["import AABB from './geom/AABB';\nimport Circle from './geom/Circle';\nimport Vector2 from './geom/Vector2';\n\ntype Subdivisions<T> = [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>];\n\nexport default class QuadTree<T> {\n  static NODE_CAPACITY = 4;\n\n  boundary: AABB;\n  _items: (T | void)[] = [];\n  _nextItemIndex: number = 0;\n  _subdivisions: null | Subdivisions<T> = null;\n  _getPosition: (item: T) => Vector2;\n\n  constructor(boundary: AABB, getPosition: (item: T) => Vector2) {\n    this.boundary = boundary;\n    this._getPosition = getPosition;\n  }\n\n  // debugDraw(color: string) {\n  //   this.boundary.debugDraw(color);\n  //   if (this._subdivisions) {\n  //     this._subdivisions.forEach(subdivision => subdivision.debugDraw(color));\n  //   }\n  // }\n\n  insert(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    if (this._nextItemIndex < QuadTree.NODE_CAPACITY) {\n      this._items[this._nextItemIndex] = item;\n      this._nextItemIndex++;\n      return true;\n    }\n\n    const subdivisions = this._getSubdivisions();\n\n    if (subdivisions[0].insert(item)) return true;\n    if (subdivisions[1].insert(item)) return true;\n    if (subdivisions[2].insert(item)) return true;\n    if (subdivisions[3].insert(item)) return true;\n\n    throw new Error('Couldnt insert item');\n  }\n\n  remove(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    const index = this._items.indexOf(item);\n    if (index !== -1) {\n      this._items.splice(index, 1);\n      this._nextItemIndex--;\n      return true;\n    }\n\n    const subdivisions = this._subdivisions;\n    if (subdivisions) {\n      if (subdivisions[0].remove(item)) return true;\n      if (subdivisions[1].remove(item)) return true;\n      if (subdivisions[2].remove(item)) return true;\n      if (subdivisions[3].remove(item)) return true;\n    }\n\n    return false;\n  }\n\n  clear() {\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      this._items[i] = undefined;\n      this._nextItemIndex = 0;\n    }\n\n    if (this._subdivisions) {\n      this._subdivisions.forEach(subdivision => subdivision.clear());\n    }\n  }\n\n  findItemsInRect(rect: AABB): T[] {\n    const foundItems = [] as Array<T>;\n\n    if (!this.boundary.intersects(rect)) return foundItems;\n\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      const item = this._items[i];\n      if (item == null) continue;\n      const point = this._getPosition(item);\n      if (rect.contains(point)) foundItems.push(item);\n    }\n\n    const subdivisions = this._subdivisions;\n    if (!subdivisions) return foundItems;\n\n    if (subdivisions[0].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[0].findItemsInRect(rect));\n    }\n    if (subdivisions[1].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[1].findItemsInRect(rect));\n    }\n    if (subdivisions[2].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[2].findItemsInRect(rect));\n    }\n    if (subdivisions[3].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[3].findItemsInRect(rect));\n    }\n\n    return foundItems;\n  }\n\n  findItemsInCircle(circle: Circle): T[] {\n    return this.findItemsInRect(circle.getBoundingBox()).filter(item =>\n      circle.containsPoint(this._getPosition(item)),\n    );\n  }\n\n  _getSubdivisions(): Subdivisions<T> {\n    if (this._subdivisions) return this._subdivisions;\n\n    const center = this.boundary.getCenter();\n    const subdivisions: Subdivisions<T> = [\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          this.boundary.top,\n          center.x,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          this.boundary.top,\n          this.boundary.right,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          center.y,\n          center.x,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          center.y,\n          this.boundary.right,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n    ];\n\n    this._subdivisions = subdivisions;\n    return subdivisions;\n  }\n}\n"],"names":["$0c47e8507acec4f1$export$2e2bcd8739ae039","boundary","getPosition","this","_items","_nextItemIndex","_subdivisions","_getPosition","key","item","point","contains","NODE_CAPACITY","subdivisions","_getSubdivisions","insert","Error","index","indexOf","splice","remove","i","undefined","forEach","subdivision","clear","rect","_foundItems","_foundItems1","_foundItems2","_foundItems3","foundItems","intersects","push","apply","$8TSCy","toConsumableArray","findItemsInRect","circle","getBoundingBox","filter","containsPoint","_this","center","getCenter","$71uov","default","fromLeftTopRightBottom","left","top","x","y","right","bottom"],"version":3,"file":"index.e83c993f.js.map"}