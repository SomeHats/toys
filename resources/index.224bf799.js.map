{"mappings":"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","sources":["src/lib/utils.ts","src/lib/geom/Vector2.ts","src/lib/DebugDraw.ts","src/resources/canvas.ts","src/lib/geom/AABB.ts","src/lib/QuadTree.ts","src/resources/resources-main.ts","src/lib/createTriangleGrid.ts"],"sourcesContent":["export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n","import { normalizeAngle, lerp } from '../utils';\n\nexport default class Vector2 {\n  static readonly ZERO = new Vector2(0, 0);\n\n  static fromPolar(angle: number, radius: number) {\n    return new Vector2(radius * Math.cos(angle), radius * Math.sin(angle));\n  }\n\n  static average(points: ReadonlyArray<Vector2>): Vector2 {\n    const sum = points.reduce((memo, p) => memo.add(p), Vector2.ZERO);\n    return sum.div(points.length);\n  }\n\n  static fromVectorLike({ x, y }: { x: number; y: number }): Vector2 {\n    return new Vector2(x, y);\n  }\n\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  toString(): string {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n\n  get magnitudeSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  get magnitude(): number {\n    return Math.sqrt(this.magnitudeSquared);\n  }\n\n  get angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  isInPolygon(polygon: ReadonlyArray<Vector2>): boolean {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const { x, y } = this;\n\n    let isInside = false;\n    for (\n      let currentIdx = 0, previousIdx = polygon.length - 1;\n      currentIdx < polygon.length;\n      previousIdx = currentIdx++\n    ) {\n      const { x: currentX, y: currentY } = polygon[currentIdx];\n      const { x: previousX, y: previousY } = polygon[previousIdx];\n      const doesIntersect =\n        currentY > y != previousY > y &&\n        x <\n          ((previousX - currentX) * (y - currentY)) / (previousY - currentY) +\n            currentX;\n\n      if (doesIntersect) {\n        isInside = !isInside;\n      }\n    }\n\n    return isInside;\n  }\n\n  equals(other: Vector2) {\n    return this === other || (this.x === other.x && this.y === other.y);\n  }\n\n  distanceTo({ x, y }: Vector2): number {\n    const dx = x - this.x;\n    const dy = y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angleTo(other: Vector2): number {\n    return other.sub(this).angle;\n  }\n\n  angleBetween(other: Vector2): number {\n    return normalizeAngle(\n      Math.atan2(other.y, other.x) - Math.atan2(this.y, this.x),\n    );\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  div(scale: number): Vector2 {\n    return new Vector2(this.x / scale, this.y / scale);\n  }\n\n  scale(scale: number): Vector2 {\n    return new Vector2(this.x * scale, this.y * scale);\n  }\n\n  negate(): Vector2 {\n    return this.scale(-1);\n  }\n\n  add({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x + x, this.y + y);\n  }\n\n  sub({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x - x, this.y - y);\n  }\n\n  floor(): Vector2 {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  ceil(): Vector2 {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n\n  round(): Vector2 {\n    return new Vector2(Math.round(this.x), Math.round(this.y));\n  }\n\n  withMagnitude(newMagnitude: number): Vector2 {\n    return Vector2.fromPolar(this.angle, newMagnitude);\n  }\n\n  normalize(): Vector2 {\n    return this.withMagnitude(1);\n  }\n\n  withAngle(newAngle: number): Vector2 {\n    return Vector2.fromPolar(newAngle, this.magnitude);\n  }\n\n  rotate(byAngle: number): Vector2 {\n    return this.withAngle(this.angle + byAngle);\n  }\n\n  lerp(other: Vector2, n: number): Vector2 {\n    return new Vector2(lerp(this.x, other.x, n), lerp(this.y, other.y, n));\n  }\n}\n","import AABB from './geom/AABB';\nimport Vector2 from './geom/Vector2';\n\nconst DEFAULT_DEBUG_COLOR = 'magenta';\nconst LABEL_OFFSET = new Vector2(5, 0);\nconst DEBUG_POINT_SIZE = 3;\nconst HAIRLINE = 0.5;\nconst DEBUG_ARROW_ANGLE = Math.PI * 0.75;\nconst DEBUG_ARROW_SIZE = 5;\n\nexport type StrokeOptions = {\n  strokeWidth?: number;\n  stroke?: string;\n  strokeCap?: 'butt' | 'round' | 'square';\n  strokeDash?: number[];\n  strokeDashOffset?: number;\n  strokeJoin?: 'bevel' | 'round' | 'miter';\n};\n\nexport type FillOptions = {\n  fill?: string;\n};\n\nexport type DebugOptions = {\n  color?: string;\n  label?: string;\n};\n\nexport type StrokeAndFillOptions = StrokeOptions & FillOptions;\n\nexport class DebugDraw {\n  constructor(private readonly ctx: CanvasRenderingContext2D) {}\n\n  public clear(fill?: string) {\n    if (!fill) {\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      return;\n    }\n\n    this.applyFillOptions({ fill });\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n\n  public beginPath() {\n    this.ctx.beginPath();\n  }\n\n  public moveTo({ x, y }: Vector2) {\n    this.ctx.moveTo(x, y);\n  }\n\n  public lineTo({ x, y }: Vector2) {\n    this.ctx.lineTo(x, y);\n  }\n\n  public arc(\n    { x, y }: Vector2,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean,\n  ) {\n    this.ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  public arcTo(p1: Vector2, p2: Vector2, radius: number) {\n    this.ctx.arcTo(p1.x, p1.y, p2.x, p2.y, radius);\n  }\n\n  public applyStrokeOptions({\n    strokeWidth = 1,\n    stroke = undefined,\n    strokeCap = 'butt',\n    strokeDash = [],\n    strokeDashOffset = 0,\n    strokeJoin = 'round',\n  }: StrokeOptions) {\n    if (stroke) {\n      this.ctx.lineWidth = strokeWidth;\n      this.ctx.strokeStyle = stroke;\n      this.ctx.lineCap = strokeCap;\n      this.ctx.setLineDash(strokeDash);\n      this.ctx.lineDashOffset = strokeDashOffset;\n      this.ctx.lineJoin = strokeJoin;\n    }\n  }\n\n  public stroke(options: StrokeOptions) {\n    if (options.stroke) {\n      this.applyStrokeOptions(options);\n      this.ctx.stroke();\n    }\n  }\n\n  public applyFillOptions({ fill = undefined }: FillOptions) {\n    if (fill) {\n      this.ctx.fillStyle = fill;\n    }\n  }\n\n  public fill(options: FillOptions) {\n    if (options.fill) {\n      this.applyFillOptions(options);\n      this.ctx.fill();\n    }\n  }\n\n  public applyStrokeAndFillOptions(options: StrokeAndFillOptions) {\n    this.applyFillOptions(options);\n    this.applyStrokeOptions(options);\n  }\n\n  public strokeAndFill(options: StrokeAndFillOptions) {\n    this.fill(options);\n    this.stroke(options);\n  }\n\n  public getDebugStrokeOptions(\n    color: string = DEFAULT_DEBUG_COLOR,\n  ): StrokeOptions {\n    return { stroke: color, strokeWidth: HAIRLINE };\n  }\n\n  public debugStroke(color: string = DEFAULT_DEBUG_COLOR) {\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n\n  public fillText(text: string, position: Vector2, options: FillOptions = {}) {\n    this.applyFillOptions(options);\n    this.ctx.fillText(text, position.x, position.y);\n  }\n\n  public circle(\n    center: Vector2,\n    radius: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.arc(center, radius, 0, 2 * Math.PI);\n    this.strokeAndFill(options);\n  }\n\n  public ellipse(\n    center: Vector2,\n    radiusX: number,\n    radiusY: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.ctx.ellipse(center.x, center.y, radiusX, radiusY, 0, 0, Math.PI * 2);\n    this.strokeAndFill(options);\n  }\n\n  public debugLabel(\n    label: string | undefined,\n    position: Vector2,\n    color: string,\n  ) {\n    if (label) {\n      this.applyFillOptions({ fill: color });\n      this.fillText(label, position.add(LABEL_OFFSET));\n    }\n  }\n\n  public debugPointX(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.beginPath();\n    this.ctx.moveTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.ctx.moveTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugPointO(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.circle(position, DEBUG_POINT_SIZE, {\n      strokeWidth: HAIRLINE,\n      stroke: color,\n    });\n  }\n\n  public debugArrow(\n    start: Vector2,\n    end: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, Vector2.average([start, end]), color);\n\n    this.ctx.beginPath();\n    this.moveTo(start);\n    this.lineTo(end);\n\n    const vector = end.sub(start);\n    const arrowLeftPoint = vector\n      .rotate(-DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n    const arrowRightPoint = vector\n      .rotate(+DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n\n    this.moveTo(arrowLeftPoint);\n    this.lineTo(end);\n    this.lineTo(arrowRightPoint);\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugVectorAtPoint(\n    vector: Vector2,\n    base: Vector2,\n    options?: DebugOptions,\n  ) {\n    this.debugArrow(base, base.add(vector), options);\n  }\n\n  public polygon(\n    polygon: ReadonlyArray<Vector2>,\n    options: StrokeAndFillOptions = {},\n  ) {\n    this.beginPath();\n    this.moveTo(polygon[polygon.length - 1]);\n    for (const point of polygon) {\n      this.lineTo(point);\n    }\n    this.strokeAndFill(options);\n  }\n\n  public polyLine(points: ReadonlyArray<Vector2>, options: StrokeOptions = {}) {\n    this.beginPath();\n    this.moveTo(points[0]);\n    for (let i = 1; i < points.length; i++) {\n      this.lineTo(points[i]);\n    }\n    this.stroke(options);\n  }\n\n  public debugPolygon(\n    polygon: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polygon[0], color);\n    this.polygon(polygon, this.getDebugStrokeOptions(color));\n  }\n\n  public debugPolyLine(\n    polyLine: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polyLine[0], color);\n    this.polyLine(polyLine, this.getDebugStrokeOptions(color));\n  }\n\n  public aabb(\n    aabb: AABB,\n    opts: StrokeAndFillOptions & { debug?: DebugOptions },\n  ) {\n    if (opts.debug) {\n      this.debugLabel(\n        opts.debug.label,\n        aabb.origin,\n        opts.debug.color || DEFAULT_DEBUG_COLOR,\n      );\n    }\n    this.ctx.beginPath();\n    this.ctx.rect(aabb.left, aabb.top, aabb.width, aabb.height);\n    this.strokeAndFill(opts);\n  }\n}\n","import { DebugDraw } from '../lib/DebugDraw';\n\nexport const canvasEl = document.createElement('canvas');\nexport const ctx = canvasEl.getContext('2d')!;\nexport const width = document.body.clientWidth;\nexport const height = document.body.clientHeight;\nexport const scale = window.devicePixelRatio;\n\ncanvasEl.width = width * scale;\ncanvasEl.height = height * scale;\ncanvasEl.style.width = `${width}px`;\ncanvasEl.style.height = `${height}px`;\nctx.scale(scale, scale);\nexport const canvas = new DebugDraw(ctx);\ndocument.body.appendChild(canvasEl);\n","import Vector2 from './Vector2';\n\nexport default class AABB {\n  static fromLeftTopRightBottom(\n    left: number,\n    top: number,\n    right: number,\n    bottom: number,\n  ): AABB {\n    return new AABB(\n      new Vector2(left, top),\n      new Vector2(right - left, bottom - top),\n    );\n  }\n\n  constructor(public readonly origin: Vector2, public readonly size: Vector2) {\n    Object.freeze(this);\n  }\n\n  contains({ x, y }: Vector2): boolean {\n    return (\n      this.left <= x && x <= this.right && this.top <= y && y <= this.bottom\n    );\n  }\n\n  intersects(other: AABB): boolean {\n    return !(\n      this.right < other.left ||\n      this.left > other.right ||\n      this.bottom < other.top ||\n      this.top > other.bottom\n    );\n  }\n\n  getCenter(): Vector2 {\n    return this.origin.add(this.size.scale(0.5));\n  }\n\n  get left(): number {\n    return this.origin.x;\n  }\n\n  get right(): number {\n    return this.origin.x + this.size.x;\n  }\n\n  get top(): number {\n    return this.origin.y;\n  }\n\n  get bottom(): number {\n    return this.origin.y + this.size.y;\n  }\n\n  get width(): number {\n    return this.size.x;\n  }\n\n  get height(): number {\n    return this.size.y;\n  }\n}\n","import AABB from './geom/AABB';\nimport Circle from './geom/Circle';\nimport Vector2 from './geom/Vector2';\n\ntype Subdivisions<T> = [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>];\n\nexport default class QuadTree<T> {\n  static NODE_CAPACITY = 4;\n\n  boundary: AABB;\n  _items: (T | void)[] = [];\n  _nextItemIndex: number = 0;\n  _subdivisions: null | Subdivisions<T> = null;\n  _getPosition: (item: T) => Vector2;\n\n  constructor(boundary: AABB, getPosition: (item: T) => Vector2) {\n    this.boundary = boundary;\n    this._getPosition = getPosition;\n  }\n\n  // debugDraw(color: string) {\n  //   this.boundary.debugDraw(color);\n  //   if (this._subdivisions) {\n  //     this._subdivisions.forEach(subdivision => subdivision.debugDraw(color));\n  //   }\n  // }\n\n  insert(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    if (this._nextItemIndex < QuadTree.NODE_CAPACITY) {\n      this._items[this._nextItemIndex] = item;\n      this._nextItemIndex++;\n      return true;\n    }\n\n    const subdivisions = this._getSubdivisions();\n\n    if (subdivisions[0].insert(item)) return true;\n    if (subdivisions[1].insert(item)) return true;\n    if (subdivisions[2].insert(item)) return true;\n    if (subdivisions[3].insert(item)) return true;\n\n    throw new Error('Couldnt insert item');\n  }\n\n  remove(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    const index = this._items.indexOf(item);\n    if (index !== -1) {\n      this._items.splice(index, 1);\n      this._nextItemIndex--;\n      return true;\n    }\n\n    const subdivisions = this._subdivisions;\n    if (subdivisions) {\n      if (subdivisions[0].remove(item)) return true;\n      if (subdivisions[1].remove(item)) return true;\n      if (subdivisions[2].remove(item)) return true;\n      if (subdivisions[3].remove(item)) return true;\n    }\n\n    return false;\n  }\n\n  clear() {\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      this._items[i] = undefined;\n      this._nextItemIndex = 0;\n    }\n\n    if (this._subdivisions) {\n      this._subdivisions.forEach(subdivision => subdivision.clear());\n    }\n  }\n\n  findItemsInRect(rect: AABB): T[] {\n    const foundItems = [] as Array<T>;\n\n    if (!this.boundary.intersects(rect)) return foundItems;\n\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      const item = this._items[i];\n      if (item == null) continue;\n      const point = this._getPosition(item);\n      if (rect.contains(point)) foundItems.push(item);\n    }\n\n    const subdivisions = this._subdivisions;\n    if (!subdivisions) return foundItems;\n\n    if (subdivisions[0].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[0].findItemsInRect(rect));\n    }\n    if (subdivisions[1].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[1].findItemsInRect(rect));\n    }\n    if (subdivisions[2].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[2].findItemsInRect(rect));\n    }\n    if (subdivisions[3].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[3].findItemsInRect(rect));\n    }\n\n    return foundItems;\n  }\n\n  findItemsInCircle(circle: Circle): T[] {\n    return this.findItemsInRect(circle.getBoundingBox()).filter(item =>\n      circle.containsPoint(this._getPosition(item)),\n    );\n  }\n\n  _getSubdivisions(): Subdivisions<T> {\n    if (this._subdivisions) return this._subdivisions;\n\n    const center = this.boundary.getCenter();\n    const subdivisions: Subdivisions<T> = [\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          this.boundary.top,\n          center.x,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          this.boundary.top,\n          this.boundary.right,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          center.y,\n          center.x,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          center.y,\n          this.boundary.right,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n    ];\n\n    this._subdivisions = subdivisions;\n    return subdivisions;\n  }\n}\n","import { canvas, width, height } from './canvas';\nimport createTriangleGrid, { Triangle } from '../lib/createTriangleGrid';\nimport QuadTree from '../lib/QuadTree';\nimport AABB from '../lib/geom/AABB';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\n\nconst TILE_SIZE = 30;\n\nconst triangles = createTriangleGrid(TILE_SIZE, width, height);\nconst triangleQuadTree = new QuadTree<Triangle>(\n  new AABB(\n    new Vector2(-TILE_SIZE, -TILE_SIZE),\n    new Vector2(width + TILE_SIZE, height + TILE_SIZE),\n  ),\n  triangle => triangle.center,\n);\nfor (const triangle of triangles.values()) {\n  triangleQuadTree.insert(triangle);\n}\n\nconst items = triangleQuadTree.findItemsInRect(\n  new AABB(new Vector2(100, 100), new Vector2(200, 200)),\n  // new Circle(width * 0.75, height * 0.35, TILE_SIZE * 8),\n);\n\nconsole.log(items);\n\nfor (const wood of items) {\n  // canvas.polygon(wood.points, {} });\n  canvas.debugPolygon(wood.points);\n}\n\n// for (const triangle of triangles.values()) {\n//   console.log(triangle);\n// }\n","import Vector2 from '../lib/geom/Vector2';\nimport { getId, compact, intersection } from '../lib/utils';\nimport Intersection from '../network/networkNodes/Intersection';\n\ntype TriangleGeom = [Vector2, Vector2, Vector2];\ntype IntermediateTriangle = {\n  id: string;\n  points: TriangleGeom;\n};\n\nexport type TriangleNeighbour = {\n  triangle: Triangle;\n  sharedPoints: [Vector2, Vector2];\n};\nexport type Triangle = {\n  id: string;\n  center: Vector2;\n  points: TriangleGeom;\n  neighbours: TriangleNeighbour[];\n  ix: number;\n  iy: number;\n};\n\nexport default function createTriangleGrid(\n  tileSize: number,\n  width: number,\n  height: number,\n): Map<string, Triangle> {\n  const tileHeight = (tileSize * Math.sqrt(3)) / 2;\n  const points: Vector2[][] = [];\n  const trianglePoints: IntermediateTriangle[][] = [];\n  for (let iy = 0; iy * tileHeight < height + tileHeight; iy++) {\n    const pointRow: Vector2[] = [];\n    points.push(pointRow);\n    const triangleRow: IntermediateTriangle[] = [];\n    trianglePoints.push(triangleRow);\n    for (let ix = 0; ix * tileSize < width + tileSize; ix++) {\n      const xOffset = iy % 2 === 0 ? -tileSize / 2 : 0;\n      const point = new Vector2(ix * tileSize + xOffset, iy * tileHeight);\n      pointRow.push(point);\n\n      if (iy !== 0 && ix !== 0) {\n        if (iy % 2 === 0) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix - 1]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix - 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        } else if (points[iy - 1][ix + 1]) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix + 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        }\n      }\n    }\n  }\n\n  const trianglesById = new Map<string, Triangle>();\n  for (let iy = 0; iy < trianglePoints.length; iy++) {\n    for (let ix = 0; ix < trianglePoints[iy].length; ix++) {\n      const triangle = trianglePoints[iy][ix];\n      const center = Vector2.average(triangle.points);\n\n      const neighbours = compact(\n        ix % 2 === 0\n          ? iy % 2 === 0\n            ? [\n                // 2,2\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix - 1],\n              ]\n            : [\n                // 2,3\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix + 1],\n              ]\n          : iy % 2 === 0\n          ? [\n              // 3,2\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix - 1],\n            ]\n          : [\n              //3,3\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix + 1],\n            ],\n      );\n\n      const fullTriangle = triangle as Triangle;\n      fullTriangle.center = center;\n      fullTriangle.neighbours = neighbours.map(neighbourTriangle => ({\n        triangle: neighbourTriangle,\n        sharedPoints: intersection(triangle.points, neighbourTriangle.points),\n      })) as TriangleNeighbour[];\n      fullTriangle.ix = ix;\n      fullTriangle.iy = iy;\n\n      trianglesById.set(fullTriangle.id, fullTriangle);\n    }\n  }\n\n  return trianglesById;\n}\n"],"names":["$15a201ffde8bbde4$export$3a89f8d6f6bf6c9f","a","b","n","$15a201ffde8bbde4$export$bc86dfbf7795668c","a1","a2","a1Items","Set","result","item","has","add","Array","from","$15a201ffde8bbde4$export$218c8c3169c024d2","prefix","Math","random","toString","slice","$db8edb9c8035529a$export$2e2bcd8739ae039","angle","radius","cos","sin","points","reduce","memo","p","ZERO","div","length","x","y","this","magnitudeSquared","magnitude","sqrt","atan2","isInPolygon","polygon","isInside","currentIdx","previousIdx","currentX","currentY","previousX","previousY","equals","other","distanceTo","x1","y1","dx","dy","angleTo","other1","sub","angleBetween","other2","min","max","size","$15a201ffde8bbde4$export$9013bf5175691fac","PI","dot","other3","scale","scale1","negate","x2","y2","x3","y3","floor","ceil","round","withMagnitude","newMagnitude","fromPolar","normalize","withAngle","newAngle","rotate","byAngle","lerp","other4","x4","y4","$870293e39def1396$var$LABEL_OFFSET","$870293e39def1396$var$DEBUG_ARROW_ANGLE","$5f8d49cabfe4e574$export$38c8a1558598a89e","document","createElement","$5f8d49cabfe4e574$export$39f92e86d1722f3a","getContext","$5f8d49cabfe4e574$export$7e3df82ee760448c","body","clientWidth","$5f8d49cabfe4e574$export$ac607276a8fe9f0a","clientHeight","$5f8d49cabfe4e574$export$dcdf75081b88279d","window","devicePixelRatio","width","height","style","$5f8d49cabfe4e574$export$67ea982130081db","clear","fill","applyFillOptions","ctx","fillRect","canvas","clearRect","beginPath","moveTo","lineTo","arc","startAngle","endAngle","anticlockwise","arcTo","p1","p2","radius1","applyStrokeOptions","strokeWidth","stroke","strokeCap","strokeDash","strokeDashOffset","strokeJoin","lineWidth","strokeStyle","lineCap","setLineDash","lineDashOffset","lineJoin","options","fill1","fillStyle","options1","applyStrokeAndFillOptions","options2","strokeAndFill","options3","getDebugStrokeOptions","color","debugStroke","color1","fillText","text","position","options4","circle","center","radius2","options5","ellipse","center1","radiusX","radiusY","options6","debugLabel","label","position1","color2","debugPointX","position2","color3","label1","debugPointO","position3","color4","label2","debugArrow","start","end","color5","label3","average","vector","arrowLeftPoint","arrowRightPoint","debugVectorAtPoint","base","options7","options8","point","polyLine","options9","i","debugPolygon","polygon1","color6","label4","debugPolyLine","color7","label5","aabb","opts","debug","origin","rect","left","top","appendChild","$615946a1704d0ee5$export$2e2bcd8739ae039","right","bottom","contains","intersects","getCenter","Object","freeze","$20c335d199682e1f$export$2e2bcd8739ae039","insert","item2","_getPosition","boundary","_nextItemIndex","NODE_CAPACITY","_items","subdivisions","_getSubdivisions","Error","remove","item1","index","indexOf","splice","_subdivisions","undefined","forEach","subdivision","findItemsInRect","foundItems","push","findItemsInCircle","getBoundingBox","filter","containsPoint","fromLeftTopRightBottom","getPosition","$ffe3d8c8d1239c8d$var$triangles","tileSize","tileHeight","trianglePoints","iy","pointRow","triangleRow","ix","triangle1","id","triangle2","trianglesById","Map","iy1","ref","ref1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","ref10","ref11","triangle","neighbours","fullTriangle","map","neighbourTriangle","sharedPoints","set","$dd4ecc289fc2ac4a$export$2e2bcd8739ae039","$ffe3d8c8d1239c8d$var$triangleQuadTree","values","$ffe3d8c8d1239c8d$var$items","console","log","wood"],"version":3,"file":"index.224bf799.js.map"}