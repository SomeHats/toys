{"mappings":"6kBAGA,MAAMA,EAAsB,SAOEC,EAI5BC,WACE,OAAsB,OAAfC,KAAKC,MAGdC,WAEE,OADAC,EAAAC,OAAOJ,KAAKC,MAAO,yBACZD,KAAKC,MAGdI,KAAKC,EAA+BC,IACpCC,OAAOC,IAEPC,MAAMT,GAEJ,OADAA,EAAMU,SAASX,MACRA,KAGTY,eAAeC,GACbb,KAAKC,MAAQY,EAGfC,qBACEd,KAAKC,MAAQ,KAGfc,eACE,OAAO,gBAnCO,IAAIC,EAKPhB,KACbiB,IANoBD,EAMMhB,KAAKkB,YAAYF,KALtCnB,EAAoBmB,KAAOnB,EAAoBmB,GAAQ,GACtD,GAAIA,KAAQnB,EAAoBmB,QAGzBhB,KAELC,MAAsB,uDCN1BkB,EAyBIC,aAAaC,GACnB,QAASrB,KAAKsB,GAAKD,EAAIrB,KAAKuB,IAAMF,EAAIrB,KAAKwB,IAAMH,EAG3CI,aAAaC,GACnB,QAAS1B,KAAK2B,GAAKD,EAAI1B,KAAK4B,IAAMF,EAAI1B,KAAK6B,IAAMH,EAG3CI,uBAAuBC,GAC7B,OAAQ,EAAM/B,KAAKsB,GAAKS,EAAI,EAAM/B,KAAKuB,IAAMQ,EAAI/B,KAAKwB,GAGhDQ,YAAYC,EAAWC,GAE7B,IAAIC,EAAIF,EACR,IAAK,IAAIG,EAAI,EAAGA,EAAIjB,EAAWkB,yBAA0BD,IAAK,CAC5D,IAAIE,EAAKtC,KAAKoB,aAAae,GAC3B,GAAII,EAAAC,SAASF,EAAIL,EAAGC,GAClB,OAAOC,EAET,IAAIM,EAAKzC,KAAK8B,uBAAuBK,GACrC,GAAII,EAAAC,SAASC,EAAI,EAAK,MACpB,MAEFN,IAAMG,EAAKL,GAAKQ,EAIlB,IAAIC,EAAK,EACLC,EAAK,EAGT,GAFAR,EAAIF,EAEAE,EAAIO,EACN,OAAOA,EAET,GAAIP,EAAIQ,EACN,OAAOA,OAGFD,EAAKC,GAAI,CACd,IAAIL,EAAKtC,KAAKoB,aAAae,GAC3B,GAAII,EAAAC,SAASF,EAAIL,EAAGC,GAClB,OAAOC,EAELF,EAAIK,EACNI,EAAKP,EAELQ,EAAKR,EAEPA,GAAKQ,EAAKD,GAAM,EAAMA,EAGxB,OAAOP,EAGTS,MAAMC,EAAWC,EAAkB3B,EAAW4B,iBAC5C,OAAO/C,KAAKyB,aAAazB,KAAKgC,YAAYa,EAAGC,gBAvEnCE,EAAYC,EAAYC,EAAYC,GAC9C,MAAM3B,EAAK,EAAIwB,EACTzB,EAAK,GAAK2B,EAAKF,GAAMxB,EAErBK,EAAK,EAAIoB,EACTrB,EAAK,GAAKuB,EAAKF,GAAMpB,EAE3B7B,KAAKsB,GAAK,EAAME,EAAKD,EACrBvB,KAAKuB,GAAKA,EACVvB,KAAKwB,GAAKA,EACVxB,KAAK2B,GAAK,EAAME,EAAKD,EACrB5B,KAAK4B,GAAKA,EACV5B,KAAK6B,GAAKA,GAtBRV,EACoBkB,yBAA2B,EAD/ClB,EAEoB4B,gBAAkB,KAmFrC,MA0BMK,EAAUC,GAAsBA,EAiChCC,EAAWnB,GACtBoB,KAAKC,IAAKrB,EAAI,GAAgB,GAAVoB,KAAKE,KA0FdC,EAAM,CAChBC,EAAY,UACZxB,GACQ,EAAIA,EAAIA,IAAMwB,EAAI,GAAKxB,EAAIwB,6DCjOjBC,UAAc9D,EAkCjCU,OAAOqD,GACL,MAAMC,EAAgBD,EAAY7D,KAAK+D,UACvC/D,KAAKgE,UAAYT,KAAKU,IAAI,EAAGjE,KAAKgE,UAAYF,GAC9C9D,KAAKkE,QAAUlE,KAAKkE,QAAQC,WAC1B5B,EAAA6B,KACEpE,KAAKqE,aACLrE,KAAKsE,WACLtE,KAAKuE,YAAYvE,KAAKgE,aAIH,IAAnBhE,KAAKgE,WAAmBhE,KAAKwE,mBAC/BxE,KAAKE,WAAWuE,YAAYzE,MAIhCK,KAAKC,GACHA,EAAIoE,YACJ,MAAMC,EAAU3E,KAAK4E,aAAa5E,KAAKgE,WACvC1D,EAAIuE,UAAY7E,KAAK8E,OAAOC,KAAKJ,GAASK,WAC1CC,EAAAC,OACE5E,EACAN,KAAKkE,QAAQiB,OAAOC,EACpBpF,KAAKkE,QAAQiB,OAAOE,EACpBrF,KAAKkE,QAAQoB,QAEfhF,EAAIiF,oBAjDOH,EACXA,EAACC,EACDA,EAACG,YACDA,EAAWC,UACXA,EAASC,SACTA,EAAQC,MACRA,EAAKC,WACLA,EAAaxC,EAAMyC,YACnBA,EAAczC,EAAM0C,iBACpBA,GAAmB,IAEnBC,QACA/F,KAAKkE,QAAU,IAAI8B,EAAAC,QAAOb,EAAGC,EAAGG,GAChCxF,KAAKqE,aAAemB,EACpBxF,KAAKsE,WAAamB,EAClBzF,KAAK+D,UAAY2B,EACjB1F,KAAK8E,OAASa,EACd3F,KAAKgE,UAAY,EACjBhE,KAAKuE,YAAcqB,EACnB5F,KAAK4E,aAAeiB,EACpB7F,KAAKwE,kBAAoBsB,oBC/CL,IAAII,EAAAC,GAAJ,CAAU,WAA3B,MACMC,EAAO,IAAIF,EAAAC,GAAJ,CAAU,WAEjBE,GADO,IAAIH,EAAAC,GAAJ,CAAU,WACX,IAAID,EAAAC,GAAJ,CAAU,YAChBG,EAAS,IAAIJ,EAAAC,GAAJ,CAAU,iBCP3BI,gBAAAA,EAAAC,IAAAA,EAAmB,KACpB,GAAG,KADFD,EAEA,IAAG,UAGRE,EAAeD,QCDME,EAInBC,IAAIC,EAAcC,GAChB,OAAQA,GACN,KAAKJ,EAAoBK,GACvB9G,KAAK+G,YAAYH,GACjB,MACF,KAAKH,EAAoBO,IACvBhH,KAAKiH,YAAYL,GACjB,cAEA,MAAM,IAAIM,MAAK,+BAAgCL,MAIrDE,YAAYI,GACVnH,KAAKoH,SAASC,KAAKF,GAGrBF,YAAYK,GACVtH,KAAKuH,SAASF,KAAKC,GAGrBE,iBACE,OAAOjF,EAAAkF,OAAOzH,KAAKoH,UAGrBM,iBACE,OAAOnF,EAAAkF,OAAOzH,KAAKuH,wBA9BRvH,KACboH,SAAmB,GADNpH,KAEbuH,SAAmB,ICSrB,MASMI,EAAatB,EAAIuB,QAAQ,IAAKC,WAAW,IACzCC,EAAczB,EAAI0B,OAAO,IACzBC,EAAc3B,EAAIuB,QAAQ,IAAK7C,KAAK,UAErBkD,UAAiBnI,EAehCoI,eACF,OAAOlI,KAAKkE,QAAQiB,OAGlBgD,0BACF,OAAOnI,KAAKoI,QAAUpI,KAAKqI,UAGzBC,0BACF,OAAOtI,KAAKuI,eAAenB,SAGzBoB,0BACF,OAAOxI,KAAKuI,eAAehB,SAG7BkB,gCAAgCC,GAC9B,OAAO1I,KAAK2I,wBAAwBC,qBAAqBF,GAG3DG,qBAAqBC,EAA4B,IAAIC,KAEnD,OADAD,EAAQnC,IAAI3G,MACL,CAACA,MAGVgJ,UAAUC,EAAYpC,GACpB7G,KAAKuI,eAAe5B,IAAIsC,EAAMpC,GAGhCqC,mBACE/I,EAAAC,OAAOJ,KAAKmI,oBAAqB,uCACjCnI,KAAKmJ,cACLnJ,KAAKoJ,SAGP5I,OAAOC,GACLT,KAAKoI,OAAS7F,EAAA8G,UAAU,EAAGrJ,KAAKqI,UAAWrI,KAAKoI,OAAS3H,GAG3DJ,KAAKC,GACH,MAAMgJ,EAAWtJ,KAAKoI,OAASpI,KAAKqI,UAC9BkB,EAAiBhH,EAAA8G,UACrB,EACA,EACA9G,EAAAiH,SAAS,EAlEa,IAkEW,EAAG,EAAGxJ,KAAKoI,SAExCqB,EAAU9B,EAAW+B,IAAI5B,EAAayB,GAE5CjJ,EAAIoE,YACJpE,EAAIuE,UAAY4E,EAAQzE,WACxBC,EAAAC,OACE5E,EACAN,KAAKkE,QAAQiB,OAAOC,EACpBpF,KAAKkE,QAAQiB,OAAOE,EACpBrF,KAAKkE,QAAQoB,QAEfhF,EAAIiF,OAEJjF,EAAIoE,YACJpE,EAAIuE,UAAYiD,EAAY9C,WAC5B1E,EAAIqJ,OAAO3J,KAAKkE,QAAQiB,OAAOC,EAAGpF,KAAKkE,QAAQiB,OAAOE,GACtDJ,EAAAC,OACE5E,EACAN,KAAKkE,QAAQiB,OAAOC,EACpBpF,KAAKkE,QAAQiB,OAAOE,EACpBrF,KAAKkE,QAAQoB,OAASgE,GAExBhJ,EAAIiF,OAGN4D,cACEnJ,KAAKoI,OAAS,EAGhBgB,SLLkB,IACjBQ,EKKC5J,KAAKE,WAAW2J,eACd7J,KACA,IAAI4D,EAAM,CACRwB,EAAGpF,KAAKkE,QAAQiB,OAAOC,EACvBC,EAAGrF,KAAKkE,QAAQiB,OAAOE,EACvBI,UA1GO,GA2GPD,YAzGa,GA0GbE,SAvGe,IAwGfC,MAAOqC,EACPpC,WAAYlC,EAAO,GACnBmC,aLfL+D,EKe0BxG,ELd1BC,GACCuG,EAAO,EAAIvG,IKcPyC,kBAAkB,iBA7FZV,EAAWC,EAAWyE,EArBX,KAsBrB/D,QATW/F,KACb+J,eAAgB,EADH/J,KAKboI,OAAiB,EALJpI,KAMbuI,eAAgC,IAAI7B,EAIlC1G,KAAKkE,QAAU,IAAI8B,EAAAC,QAAOb,EAAGC,EArBlB,IAsBXrF,KAAK2I,wBAA0B,IAAI3C,EAAAC,QAAOb,EAAGC,EArBhB,IAsB7BrF,KAAKqI,UAAYyB,qHClCSE,EAe5B9J,WAEE,OADAC,EAAAC,OAAOJ,KAAKC,MAAO,qBACZD,KAAKC,MAGdgK,gBAAgBhK,GACdD,KAAKC,MAAQA,EAIfiK,sBAAsBrJ,GACpBb,KAAKC,MAAQ,KAIfkK,aAAa1J,IAGb2J,YAAYC,IAGZC,WAAWhK,EAA+BiK,IAG1CC,UAAUC,EAA+BC,kBAvC5B1K,KAELC,MAAsB,KAG5BE,EAAAC,OACEJ,KAAKkB,cAAgB8I,EACrB,0DAEF7J,EAAAC,OAXiB,4BAYdJ,KAAKkB,YAAoByJ,WAC1B,uEAXwBX,EACrBW,WAHY,iDCEAC,EAqBnBC,OAAOC,GACL,MAAMC,EAAQ/K,KAAKgL,aAAaF,GAChC,IAAK9K,KAAKiL,SAASC,SAASH,GAAQ,OAAO,EAE3C,GAAI/K,KAAKmL,eAAiBP,EAASQ,cAGjC,OAFApL,KAAKqL,OAAOrL,KAAKmL,gBAAkBL,EACnC9K,KAAKmL,kBACE,EAGT,MAAMG,EAAetL,KAAKuL,mBAE1B,GAAID,EAAa,GAAGT,OAAOC,GAAO,OAAO,EACzC,GAAIQ,EAAa,GAAGT,OAAOC,GAAO,OAAO,EACzC,GAAIQ,EAAa,GAAGT,OAAOC,GAAO,OAAO,EACzC,GAAIQ,EAAa,GAAGT,OAAOC,GAAO,OAAO,EAEzC,MAAM,IAAI5D,MAAM,uBAGlBsE,OAAOC,GACL,MAAMV,EAAQ/K,KAAKgL,aAAaS,GAChC,IAAKzL,KAAKiL,SAASC,SAASH,GAAQ,OAAO,EAE3C,MAAMW,EAAQ1L,KAAKqL,OAAOM,QAAQF,GAClC,IAAc,IAAVC,EAGF,OAFA1L,KAAKqL,OAAOO,OAAOF,EAAO,GAC1B1L,KAAKmL,kBACE,EAGT,MAAMG,EAAetL,KAAK6L,cAC1B,GAAIP,EAAc,CAChB,GAAIA,EAAa,GAAGE,OAAOC,GAAO,OAAO,EACzC,GAAIH,EAAa,GAAGE,OAAOC,GAAO,OAAO,EACzC,GAAIH,EAAa,GAAGE,OAAOC,GAAO,OAAO,EACzC,GAAIH,EAAa,GAAGE,OAAOC,GAAO,OAAO,EAG3C,OAAO,EAGTK,QACE,IAAK,IAAI1J,EAAI,EAAGA,EAAIpC,KAAKmL,eAAgB/I,IACvCpC,KAAKqL,OAAOjJ,QAAK2J,EACjB/L,KAAKmL,eAAiB,EAGpBnL,KAAK6L,eACP7L,KAAK6L,cAAcG,SAAQC,GAAeA,EAAYH,UAI1DI,gBAAgBC,GACd,MAAMC,EAAa,GAEnB,IAAKpM,KAAKiL,SAASoB,WAAWF,GAAO,OAAOC,EAE5C,IAAK,IAAIhK,EAAI,EAAGA,EAAIpC,KAAKmL,eAAgB/I,IAAK,CAC5C,MAAMkK,EAAOtM,KAAKqL,OAAOjJ,GACzB,GAAY,MAARkK,EAAc,SAClB,MAAMvB,EAAQ/K,KAAKgL,aAAasB,GAC5BH,EAAKjB,SAASH,IAAQqB,EAAW/E,KAAKiF,GAG5C,MAAMhB,EAAetL,KAAK6L,cAC1B,OAAKP,GAEDA,EAAa,GAAGL,SAASoB,WAAWF,IACtCC,EAAW/E,QAAQiE,EAAa,GAAGY,gBAAgBC,IAEjDb,EAAa,GAAGL,SAASoB,WAAWF,IACtCC,EAAW/E,QAAQiE,EAAa,GAAGY,gBAAgBC,IAEjDb,EAAa,GAAGL,SAASoB,WAAWF,IACtCC,EAAW/E,QAAQiE,EAAa,GAAGY,gBAAgBC,IAEjDb,EAAa,GAAGL,SAASoB,WAAWF,IACtCC,EAAW/E,QAAQiE,EAAa,GAAGY,gBAAgBC,IAG9CC,GAfmBA,EAkB5BG,kBAAkBrH,GAChB,OAAOlF,KAAKkM,gBAAgBhH,EAAOsH,kBAAkBC,QAAOH,GAC1DpH,EAAOwH,cAAc1M,KAAKgL,aAAasB,MAI3Cf,mBACE,GAAIvL,KAAK6L,cAAe,OAAO7L,KAAK6L,cAEpC,MAAM1G,EAASnF,KAAKiL,SAAS0B,YACvBrB,EAAgC,CACpC,IAAIV,EACFgC,EAAA3G,QAAK4G,uBACH7M,KAAKiL,SAAS6B,KACd9M,KAAKiL,SAAS8B,IACd5H,EAAOC,EACPD,EAAOE,GAETrF,KAAKgL,cAEP,IAAIJ,EACFgC,EAAA3G,QAAK4G,uBACH1H,EAAOC,EACPpF,KAAKiL,SAAS8B,IACd/M,KAAKiL,SAAS+B,MACd7H,EAAOE,GAETrF,KAAKgL,cAEP,IAAIJ,EACFgC,EAAA3G,QAAK4G,uBACH7M,KAAKiL,SAAS6B,KACd3H,EAAOE,EACPF,EAAOC,EACPpF,KAAKiL,SAASgC,QAEhBjN,KAAKgL,cAEP,IAAIJ,EACFgC,EAAA3G,QAAK4G,uBACH1H,EAAOC,EACPD,EAAOE,EACPrF,KAAKiL,SAAS+B,MACdhN,KAAKiL,SAASgC,QAEhBjN,KAAKgL,eAKT,OADAhL,KAAK6L,cAAgBP,EACdA,cAlJGL,EAAgBiC,GATflN,KAIbqL,OAAuB,GAJVrL,KAKbmL,eAAyB,EALZnL,KAMb6L,cAAwC,KAItC7L,KAAKiL,SAAWA,EAChBjL,KAAKgL,aAAekC,GAXHtC,EACZQ,cAAgB,qBCCJ+B,UAAwBnD,EAK3CoD,gBAAgBC,GACdrN,KAAKsN,UAAU9B,OAAO6B,GAGxBpD,gBAAgBhK,GACd8F,MAAMkE,gBAAgBhK,GACtBD,KAAKsN,UAAY,IAAI1C,EACnBgC,EAAA3G,QAAK4G,uBAAuB,EAAG,EAAG5M,EAAMsN,MAAOtN,EAAMuN,SACrDC,GAAaA,EAAUvF,WAI3BiC,eACE,MAAMlK,EAAQD,KAAKE,WACnBF,KAAKsN,UAAUxB,QACf7L,EAAMyN,SAAS1B,SAAQ2B,IACjBA,aAAiBC,GACnB5N,KAAKsN,UAAUzC,OAAO8C,MAM5BE,uBAAuB3I,GACrB,OAAOlF,KAAKsN,UAAUf,kBAAkBrH,IA7BvBiI,EACZxC,WAAa,sECJtB,MAAMmD,EAAa,CACjBC,YAAYC,EAA0BC,GACpC,MAAMC,EAAiB,IAAInF,IAAIiF,EAAYnF,wBAC3CqF,EAAevH,IAAIqH,GACnB7N,EAAAC,OACE8N,EAAeC,IAAIF,GACnB,iCAEF,MAAMG,EAAY,IAAIC,IAChBC,EAAY,IAAID,QAEtBD,EAAUG,IAAIP,EAAa,GAEpBE,EAAeM,MAAM,CAC1B,MAAOvF,KAACA,EAAIwF,KAAEA,GAASX,EAAWY,0BAChCR,EACAE,GAIF,GAFAF,EAAeS,OAAO1F,GAElBA,IAASgF,EACX,OAAOH,EAAWc,mBAChBN,EACAN,EACAC,GAIJH,EAAWe,kBAAkB5F,EAAMmF,EAAWK,EAAMH,GAGtD,MAAM,IAAIpH,MAAM,uBAGlBwH,0BACEI,EACAC,GAEA,IAAIC,EAAWC,EAAAA,EACXC,EAAW,KAWf,OATAJ,EAAM9C,SAAQ/C,IACZ,MAAMwF,EAAOM,EAAMI,IAAIlG,GACX,MAARwF,GAAgBA,GAAQO,IAC1BA,EAAWP,EACXS,EAAWjG,MAIf9I,EAAAC,OAAO8O,EAAU,sBACV,CAAEjG,KAAMiG,EAAUT,KAAMO,IAEjCH,kBACE5F,EACAmF,EACAK,EACAH,GAEArF,EAAKT,oBAAoBwD,SAAQoD,IAC/B,MAAMC,EAAWD,EAAKE,GAChBC,EAAenB,EAAUe,IAAIE,GAC7BG,EAAkBf,EAAOW,EAAKK,4BAChB,MAAhBF,GAAwBC,GAAmBD,KAC7CnB,EAAUG,IAAIc,EAAUG,GACxBlB,EAAUC,IAAIc,EAAUD,QAI9BR,mBACEN,EACAoB,EACAC,GAEA,IAAI1G,EAAO0G,OACJrB,EAAUH,IAAIlF,IAAO,CAC1B,MAAMmG,EAAOd,EAAUa,IAAIlG,GAG3B,GAFA9I,EAAAC,OAAOgP,EAAM,mBACbnG,EAAOmG,EAAKQ,KACR3G,IAASyG,EAAO,OAAON,EAG7B,MAAM,IAAIlI,MAAM,iCAIpB2I,EAAe/B,QC/EMgC,EASfxH,0BACF,OAAOtI,KAAKuI,eAAenB,SAGzBoB,0BACF,OAAOxI,KAAKuI,eAAehB,SAGzBY,0BACF,OAAO,EAGTe,iBAAiBmE,GACf,MAAM0C,EAAc1C,EAAU0C,YAC9B5P,EAAAC,OAAO2P,EAAa,mCAEpB,MAAMC,EAAWH,EAAW9B,YAAY/N,KAAM+P,GAC9C5P,EAAAC,OACEJ,KAAKwI,oBAAoByH,SAASD,GAClC,2CAGF3C,EAAU6C,wBACVF,EAASG,oBAAoB9C,GAG/BxE,qBAAqBC,EAA4B,IAAIC,KAEnD,OADAD,EAAQnC,IAAI3G,MACLuC,EAAA6N,KACL7N,EAAA8N,QACErQ,KAAKuI,eAAehB,SAAS+I,KAAIlB,GAC/BA,EAAKvG,qBAAqBC,OAMlCL,kCACE,OAAOzI,KAAKkI,SAGdqI,8BACE,IAAIC,EAAgB,KAChBC,EAAmBxB,EAAAA,EASvB,OARAjP,KAAKwI,oBAAoBwD,SAAQoD,IAC/B,MAAM3B,EAAY2B,EAAKsB,2BAA0B,GAC7CjD,GAAaA,EAAUkD,sBAAwBF,IACjDD,EAAgB/C,EAChBgD,EAAmBhD,EAAUkD,0BAI1BH,EAGTI,8BACE,IAAIJ,EAAgB,KAChBC,EAAmBxB,EAAAA,EAYvB,OAXAjP,KAAKsI,oBAAoB0D,SAAQoD,IAC/B,MAAM3B,EAAY2B,EAAKyB,2BAA2BzB,EAAK0B,QAErDrD,GACAA,EAAUsD,2BAA6BN,IAEvCD,EAAgB/C,EAChBgD,EAAmBhD,EAAUsD,+BAI1BP,EAGTxH,UAAUC,EAAYpC,GACpB7G,KAAKuI,eAAe5B,IAAIsC,EAAMpC,eA7EpBzB,EAAWC,GALVrF,KACb+J,eAAgB,EADH/J,KAGbuI,eAAgC,IAAI7B,EAGlC1G,KAAKkI,SAAW,IAAI8I,EAAA/K,QAAQb,EAAGC,wCCdd4L,UAA0BC,EAAAjL,QAQ7ClF,eACE,OAAOf,KAAKmR,eAAenR,KAAKoR,oBAPhCA,EACQD,GAERpL,MAAMqL,QAFED,eAAAA,SCKSE,UAAevR,EAMlCwR,aACEC,KACGC,GAEHrR,EAAAC,QACGJ,KAAKyR,mBAAmBtD,IAAIoD,GAAS,sBAChBA,EAAUvQ,uBAElC,MAAM0Q,EAAW,IAAIH,EAAUvR,QAASwR,GAExC,OADAxR,KAAKyR,mBAAmBlD,IAAIgD,EAAWG,GAChCA,EAGTC,aACEC,GAEA,OAAO5R,KAAKyR,mBAAmBtD,IAAIyD,GAGrCC,aAAkCC,GAChC,MAAMJ,EAAW1R,KAAKyR,mBAAmBtC,IAAI2C,GAG7C,OAFA3R,EAAAC,OAAOsR,EAAQ,mBAAqBI,EAAU9Q,eAC9Cb,EAAAC,OAAOsR,aAAoBI,EAAW,uBAC/BJ,EAGTK,gBAAqCC,GACnC,MAAMN,EAAW1R,KAAK6R,aAAaG,GAGnC,OAFAhS,KAAKyR,mBAAmB9C,OAAOqD,GAC/BN,EAASO,WACFP,EAGTrR,KAAKC,EAA+BC,GAClC,IAAK,MAAMgR,KAAavR,KAAKyR,mBAAmBS,SAC9CX,EAAUjH,WAAWhK,EAAKC,GAE5B,IAAK,MAAM4R,KAAanS,KAAKyR,mBAAmBS,SAC9CC,EAAU9R,KAAKC,EAAKC,GAEtB,IAAK,MAAM6R,KAAapS,KAAKyR,mBAAmBS,SAC9CE,EAAU5H,UAAUlK,EAAKC,GAG7BC,OAAOC,GACL,IAAK,MAAM8Q,KAAavR,KAAKyR,mBAAmBS,SAC9CX,EAAUpH,aAAa1J,GAEzB,IAAK,MAAM4R,KAAarS,KAAKyR,mBAAmBS,SAC9CG,EAAU7R,OAAOC,GAEnB,IAAK,MAAM6R,KAAatS,KAAKyR,mBAAmBS,SAC9CI,EAAUlI,YAAY3J,GAI1BG,eAAeX,GACb8F,MAAMnF,eAAeX,GACrB,IAAK,MAAMsR,KAAavR,KAAKyR,mBAAmBS,SAC9CX,EAAU3Q,eAAeX,GAI7Ba,qBACE,MAAMb,EAAQD,KAAKE,WACnB6F,MAAMjF,qBACN,IAAK,MAAMyQ,KAAavR,KAAKyR,mBAAmBS,SAC9CX,EAAUzQ,mBAAmBb,GAIjCc,eACE,OAAIf,KAAK2R,aAAaV,GACbjR,KAAK6R,aAAaZ,GAAmBlQ,eAErCgF,MAAMhF,6CAjFJf,KACLyR,mBAAqB,IAAIpD,uFCInC,MAkBMkE,EbqNc,EACjB5O,EAAY,UACZxB,GAEQ,IADPA,GAAQ,GACQA,IAAMwB,EAAI,GAAKxB,EAAIwB,GAAK,GazN1B6O,CAAQ,GACpBC,EAAW/O,EAAO,SAEnBgP,GAAAA,EAAAC,IAAAA,EAAU,KACU,wBAAvB,0BADGD,EAEyB,6BAA5B,+BAFGA,EAGuB,2BAA1B,mCAGmB9E,UAAkB9N,EAqBjC8S,kBACF,OAAO5S,KAAK6S,aAGV3K,eAEF,OADA/H,EAAAC,OAAOJ,KAAK6S,aAAc,+BACnB7S,KAAK6S,aAAaC,mBAAmB9S,KAAK+S,wBAW/CC,yBACF,MAAMJ,EAAc5S,KAAK6S,aACzB1S,EAAAC,OAAOwS,EAAa,+BACpB,MAAMK,EAAejT,KAAKkT,0CAC1B,OAAOlT,KAAKmT,8BAA8BP,EAAaK,GAGrDG,wBACF,MAAMjO,EAASnF,KAAKgT,mBACpB,OAAO,IAAIhN,EAAAC,QAAOd,EAAOC,EAAGD,EAAOE,EAAGrF,KAAKqT,YAGzCC,sCACF,MAAMV,EAAc5S,KAAK6S,aACzB1S,EAAAC,OAAOwS,EAAa,+BACpB,MAAMK,EAAejT,KAAKkT,0CAC1B,OAAOlT,KAAKmT,8BAA8BP,EAAaK,EAAe,GAGpEtC,4BACF,OAAO3Q,KAAK+S,uBAGVhC,iCAEF,OADA5Q,EAAAC,OAAOJ,KAAK6S,aAAc,8BACnB7S,KAAK6S,aAAa/B,OAAS9Q,KAAK+S,uBAGrChD,kBACF,OAAO/P,KAAKuT,aAGVC,YACF,OAAOxT,KAAKyT,OAGVC,gBACF,OAAsB,IAAf1T,KAAKwT,MAGVG,kBACF,OAAO3T,KAAK4T,aAGVC,iBACF,OAAO7T,KAAK8T,YAGdC,aAAaC,GACX,OAAOhU,KAAKiU,YAAYhE,SAAS+D,GAGnCE,cAAc9E,GACZpP,KAAK6S,aAAezD,EACpBpP,KAAK+S,uBAAyB,EACzB/S,KAAKuT,cACRvT,KAAKmU,mBAITC,oBACEpU,KAAKE,WACFmU,UAAUlH,GACVC,gBAAgBpN,MACnBA,KAAK6S,aAAe,KAGtB/R,qBACEd,KAAKkQ,wBAGPA,wBACMlQ,KAAK6S,cAAc7S,KAAK6S,aAAazF,gBAAgBpN,MAG3DQ,OAAO8T,GACLtU,KAAKuU,MAAQD,EACbtU,KAAK8T,YAAc,KACnB9T,KAAKiU,YAAc,GAEnB,MAAMrB,EAAc5S,KAAK6S,aACzB1S,EAAAC,OAAOwS,EAAa,gCAEpB5S,KAAKwU,MAAMF,EAAgB1B,GAE3B,MAAM6B,EAAMzU,KAAK0U,UACjBD,EACG5C,aAAa8C,EAAAC,uBACbC,YACC7U,KAAKkI,SACL0K,EAAYkC,mBAAmB9U,KAAK+S,wBACpCuB,EAAiB,KAErBG,EAAIjU,OAAO8T,GAEXtU,KAAK+U,2BAGL/U,KAAKgV,kBAAkBpC,GACvB5S,KAAKiV,aAGP5U,KAAKC,EAA+BC,GAClC,MAAMqS,EAAc5S,KAAK6S,aACzB1S,EAAAC,OAAOwS,EAAa,gCAEpB5S,KAAK0U,UAAUrU,KAAKC,EAAKC,GAY3BQ,eACE,OAAOf,KAAKkI,SAAS7C,EAGnB6P,iBACF,OAA+B,OAAxBlV,KAAKmV,eAGdT,UAKE,OAJK1U,KAAKoV,OACRpV,KAAKoV,cC/LqBlN,GAC9B,MAAMuM,EAAM,IAAIpD,EAChBoD,EAAInD,aAAaqD,EAAAC,sBAAuB1M,GACxC,MAAMmN,EAASC,EAAAC,0BAIf,OAHad,EAAInD,aAAakE,EAAAvP,QAASoP,GAClCI,uBAAuB,IAAIC,EAAAzP,QAA2BoP,IAC3DZ,EAAInD,aAAaqE,EAAA1P,QAAaoP,GACvBZ,EDwLSmB,CAAgB5V,KAAKkI,WAG5BlI,KAAKoV,KA2BdL,2BACE,OAAOxC,EACLhQ,EAAA8G,UAAU,EAAG,EAAG9G,EAAAiH,SAAS,EAlNR,IAkN2B,EAAG,EAAGxJ,KAAKuU,QAI3DsB,0BACE,OAA4B,OAAxB7V,KAAKmV,eAAgC,EAEvC,EACA1C,EACElQ,EAAA8G,UACE,EACA,EACA9G,EAAAiH,SACExJ,KAAKmV,eACLnV,KAAKmV,eA/NK,IAgOV,EACA,EACAnV,KAAKuU,QAOfrB,0CACE,MAAM4C,GAAc9V,KAAKyT,QAjPR,IAkPjB,OACEzT,KAAK+S,uBACL/S,KAAKyT,OAASqC,GACd,IAAqBA,EAAaA,EAItC3C,8BAA8BP,EAAmB1K,GAC/C,GAAIA,GAAY0K,EAAY9B,OAC1B,OAAO8B,EAAYE,mBAAmB5K,GAGxC,MAAM6N,EAAY7N,EAAW0K,EAAY9B,OACnCkF,EAAiBpD,EAAYkC,mBAAmBlC,EAAY9B,QAClE,OAAOE,EAAA/K,QAAQgQ,UAAUD,EAAgBD,GAAWpP,IAAIiM,EAAYsD,KAGtE/B,mBACE,IAAKnU,KAAK6S,aAAc,OACxB,MAAMsD,EAAwBnW,KAAK6S,aAChChK,uBACA4D,QAAOxD,GAAQA,EAAKc,gBACjBgG,EAAcxN,EAAAkF,OAAO0O,GAC3BnW,KAAKuT,aAAexD,EAGtByE,MAAM4B,EAAwBC,GAC5B,MAAMC,EAAYF,EAAiB,IAEnCpW,KAAKuW,sBAAwBhU,EAAA8G,UAC3B,EA5Q4B,IA8Q5BrJ,KAAKuW,sBAAwBH,GAI7BpW,KAAKuW,uBAAyB,GAC9BvW,KAAKwW,kBAAkBH,GAEvBrW,KAAKyW,aAzRU,IAyRgBH,EAAWD,GAE1CrW,KAAKyW,YA5RU,IA4RgBH,EAAWD,GAGxB,IAAhBrW,KAAKyT,OACPzT,KAAK4T,cAAgBwC,EAErBpW,KAAK4T,aAAe,EAIxB4C,kBAAkBE,GAChB,MAAMC,EAAwB3W,KAAKkT,0CACnC,GACEwD,EAAYpH,KAAOtP,KAAKuT,cACxBmD,EAAY5F,OAxSS,EAwSqB6F,EAG1C,OADA3W,KAAK8T,YAAcnB,EAAWiE,yBACvB,EAGT,MAAMC,EAAsBH,EAAYhG,0BACtC1Q,KAAK+S,wBAGD+D,EACJH,EAAwB3W,KAAK+W,kBAE/B,GACEF,GACAA,EAAoBlG,sBAAwBmG,EAI5C,OAFA9W,KAAK8T,YAAcnB,EAAWqE,6BAC9BhX,KAAKiU,YAAY5M,KAAKwP,IACf,EAGT,GAAIH,EAAYpH,cAAcQ,EAAc,CAC1C,MAAMmH,EAAeP,EAAYpH,GAC3B4H,EAAoBD,EAAa1G,8BACvC,GAAI2G,EAAmB,CAIrB,GAFER,EAAY5F,OAASoG,EAAkBvG,sBAETmG,EAG9B,OAFA9W,KAAK8T,YAAcnB,EAAWqE,6BAC9BhX,KAAKiU,YAAY5M,KAAK6P,IACf,EAIX,MAAMC,EAAoBF,EAAarG,8BACvC,GAAIuG,GAAqBA,IAAsBnX,KAAM,CAGnD,GADE0W,EAAY5F,OAASqG,EAAkBpG,2BACT+F,EAG9B,OAFA9W,KAAK8T,YAAcnB,EAAWqE,6BAC9BhX,KAAKiU,YAAY5M,KAAK8P,IACf,GAKb,QAAInX,KAAKoX,qCAAqCV,KAC5C1W,KAAK8T,YAAcnB,EAAW0E,4BACvB,GAsCXD,qCAAqCE,GACnC,MAAMC,EAAkBvX,KAAKE,WAAWmU,UAAUlH,GAC5CqK,EAAWxX,KAAKoT,kBAChBqE,EAAYD,EAASrS,OACrBuS,EAAgB1X,KAAKsT,gCACrBqE,EAAaH,EAASrT,WA3YV,KA4YZyT,EAAmBL,EAAgB1J,uBAAuB8J,GAEhE,IAAK,MAAM3D,KAAS4D,EAAkB,CAEpC,GAAI5D,IAAUhU,KAAM,SAGpB,MAAM6X,EAAgB7D,EAAMZ,kBACtB0E,EAAiBD,EAAc1S,OACrC,IAAKqS,EAASO,iBAAiBF,GAAgB,SAK/C,MAAMG,EAAqBhE,EAAMV,gCAG3B2E,EAAsBR,EAAUS,WAAWL,EAAc1S,QAE/D,GADyBuS,EAAcQ,WAAWF,GAC3BC,EAAqB,SAK5C,MAAME,EAAiBV,EAAUS,WAAWF,GACtCI,EAAsBN,EAAeI,WAAWR,GACtD,KAAIS,EAAiBC,MAQnBD,EAAiBC,EACjB,KAFF,CASA,GAAID,IAAmBC,EACrB,OAAO7U,KAAK8U,SAAW,GAMzB,GAAIrY,KAAK4T,aArbE,OAqb0BI,EAAMN,UAEzC,OADA1T,KAAKsY,sBACE,EAKLtE,EAAMD,aAAa/T,OAEvBA,KAAKiU,YAAY5M,KAAK2M,IAGxB,QAAIhU,KAAKiU,YAAYnD,OA4CvBwH,qBACEtY,KAAKuW,sBA7eyB,IAgfhCE,YAAY8B,EAAsBjC,EAAmBkC,GACnD,MAAMC,EAAYzY,KAAKyT,OACvBzT,KAAKyT,OAASlR,EAAA8G,UACZ,EAzfY,GA2fZrJ,KAAKyT,OAAS8E,EAAejC,GAE/B,MAAMoC,GAAYD,EAAYzY,KAAKyT,QAAU,EAC7CzT,KAAK+S,uBAAyBxQ,EAAA8G,UAC5B,EACAmP,EAAY1H,OACZ9Q,KAAK+S,uBAAyB2F,EAAWpC,GAI7CtB,kBAAkB2D,GAChB,GAAI3Y,KAAK+S,yBAA2B4F,EAAY7H,OAAQ,CACtD,GAAI9Q,KAAKkV,WAAY,OACrBlV,KAAK4Y,yBAAyBD,IAIlC1D,aACMjV,KAAKkV,aACP/U,EAAAC,OAAOJ,KAAKmV,gBACRnV,KAAKuU,MAAQvU,KAAKmV,eAtgBN,KAugBdnV,KAAK6Y,WAKXD,yBAAyBE,GACvB,MAAMzJ,EAAWyJ,EAAYxJ,GACvBS,EAAc/P,KAAKuT,aACrBlE,EAASlH,sBACXkH,EAASnG,iBAAiBlJ,MACtBqP,IAAaU,GACf/P,KAAK+Y,uBAKXA,sBACE/Y,KAAKgZ,QAGPH,UACE7Y,KAAKE,WAAWuE,YAAYzE,MAG9BgZ,QACEhZ,KAAKmV,eAAiBnV,KAAKuU,mCArhBhBvU,KAIb+W,kBAAoBxU,EAAA8V,OA/BmB,GACA,IA0B1BrY,KAQbqT,WAAa9Q,EAAA8V,OAjCmB,GACA,IAwBnBrY,KASb6S,aAA4B,KATf7S,KAUbuT,aAAmC,KAVtBvT,KAWb+S,uBAAiC,EAXpB/S,KAYbyT,OAjCoB,EAqBPzT,KAabuU,KAAe,EAbFvU,KAcbmV,eAAgC,KAdnBnV,KAeb4T,aAAuB,EAfV5T,KAgBbuW,sBAAgC,EAhBnBvW,KAiBb8T,YAAiC,KAjBpB9T,KAkBbiU,YAA2B,GAlBdjU,KAmBboV,KAAsB,MAnBHxH,EACZqL,UArBS,GAoBGrL,EAEZ8E,WAAaC,0FE5BDuG,kCACaC,GAC9B,IAAKC,KAAcC,GAAmBF,EACtC,MAAMG,EAAO,IAAIJ,EAEjB,IAAK,MAAMnO,KAASsO,EAClBC,EAAKC,WAAW,IAAIC,EAAAvT,QAAoBmT,EAAWrO,IACnDqO,EAAYrO,EAGd,OAAOuO,6BAIPG,EACAC,EACAC,GAEAD,GAA0BnW,KAAKE,GAC/B,MAAMmW,EAAaH,EAAiB7Q,qBAAqB8Q,GACnDG,EAAYJ,EAAiB7Q,qBAAqB+Q,GAElDG,EAAkB,IAAIC,EAAA9T,QAC1BwT,EAAiBtU,OACjByU,GACAI,8BAA8BJ,GAC1BK,EAAiB,IAAIF,EAAA9T,QACzBwT,EAAiBtU,OACjB0U,GACAG,8BAA8BH,GAEhC,GAAIC,EAAgBI,aAAaD,GAC/B,OAAO,IAAIT,EAAAvT,QAAoB2T,EAAYC,GAG7C,MAAMM,EAAmBL,EAAgBM,wBACvCH,GAEII,EAAmBT,EAAW1B,WAAWiC,GAO/C,OAAO,IAAIG,EAAArU,QACTkU,EACAE,EACAT,EAAWW,IAAIJ,GAAkBK,MACjCX,EAAUU,IAAIJ,GAAkBK,OAUpCC,WACE,OAAOza,KAAK0a,SAAS,GAAGD,WAG1BE,SACE,OAAO3a,KAAK0a,SAAS1a,KAAK0a,SAAS5J,OAAS,GAAG6J,SAGjDC,YACE,OAAO5a,KAAK0a,SAASG,QAAM,CACxB/J,EAAQgK,IAAYhK,EAASgK,EAAQF,aACtC,GAIJ9H,mBAAmB5K,GACjB,MAAM6S,EAAcxY,EAAA8G,UAAU,EAAGrJ,KAAK4a,YAAa1S,GACnD,IAAI8S,EAAQ,EACZ,IAAK,MAAMF,KAAW9a,KAAK0a,SAAU,CACnC,GAAIK,GAAeC,EAAQF,EAAQF,YACjC,OAAOE,EAAQhI,mBAAmBiI,EAAcC,GAElDA,GAASF,EAAQF,YAEnB,MAAM,IAAI1T,MAAM,2CAGlB4N,mBAAmBmG,GACjB,MAAMF,EAAcxY,EAAA8G,UAAU,EAAGrJ,KAAK4a,YAAaK,GACnD,IAAID,EAAQ,EACZ,IAAK,MAAMF,KAAW9a,KAAK0a,SAAU,CACnC,GAAIK,GAAeC,EAAQF,EAAQF,YACjC,OAAOE,EAAQhG,mBAAmBiG,EAAcC,GAElDA,GAASF,EAAQF,YAEnB,MAAM,IAAI1T,MAAM,2CAGlBqS,WAAW2B,GACT,MAAMC,EAAcnb,KAAK0a,SAAS1a,KAAK0a,SAAS5J,OAAS,GAUzD,OATIqK,GACFhb,EAAAC,OACE+a,EAAYR,SAASS,OAAOF,EAAQT,YAAQ,wCACJU,EACrCR,SACA3V,kBAAkBkW,EAAQT,WAAWzV,cAG5ChF,KAAK0a,SAASrT,KAAK6T,GACZlb,KAGTqb,eAAeX,GAEb,OADAA,EAAS1O,SAAQ8O,GAAW9a,KAAKuZ,WAAWuB,KACrC9a,KAGTsb,UAAUhW,GACR,MAAMiW,EAAcvb,KAAK0a,SAASpK,KAAG,CAAEwK,EAAS1Y,KAC9C,MAAM+Y,EAAoB,IAAN/Y,EAAU,KAAOpC,KAAK0a,SAAStY,EAAI,GACvD,IAAK+Y,EACH,OAAIL,aAAmBtB,EAAAvT,QAA4B,KAC5C6U,EAGT,KAAMA,aAAmBtB,EAAAvT,SAAsB,OAAO6U,EACtD,KAAMK,aAAuB3B,EAAAvT,SAAsB,OAAO,KAE1D9F,EAAAC,OACE+a,EAAYR,SAASS,OAAON,EAAQL,YACpC,sBAGF,MAAMe,EAAaL,EAAYX,MACzBiB,EAAYX,EAAQN,MACpBkB,EAAenY,KAAKU,IACxBqB,EACA6V,EAAYP,YAAc,EAC1BE,EAAQF,YAAc,GAGlBe,EAAmB,IAAI3V,EAAAC,QAC3B6U,EAAQL,WAAWrV,EACnB0V,EAAQL,WAAWpV,EACnBqW,GAGF,OAAOxC,EAAK0C,oBAAoBD,EAAkBH,EAAYC,MAG1DI,EAAYtZ,EAAAuZ,QAAQP,GAEpB7L,EAAQ1P,KAAKya,WACbvE,EAAMlW,KAAK2a,SACjB,IAAIvB,EAAY1J,EAkBhB,OAjBA1P,KAAK0a,SAAW,GAEhBmB,EAAU7P,SAAQ8O,IACZA,EAAQL,WAAWW,OAAOhC,IAG5BpZ,KAAKuZ,WAAW,IAAIC,EAAAvT,QAAoBmT,EAAW0B,EAAQL,aAF3Dza,KAAKuZ,WAAWuB,GAMlB1B,EAAY0B,EAAQH,YAGjBvB,EAAUgC,OAAOlF,IACpBlW,KAAKuZ,WAAW,IAAIC,EAAAvT,QAAoBmT,EAAWlD,IAG9ClW,oBArHM+b,GAvDF/b,KAqDb0a,SAA0B,GAGxB1a,KAAKqb,eAAeU,8DC9DHC,UAAiBlc,EAYhCoI,eACF,OAAOlI,KAAKkE,QAAQiB,OAGtBvE,eAAeX,GACb8F,MAAMnF,eAAeX,GACrBD,KAAKic,OAAOjQ,SAAQoD,GAAQnP,EAAMU,SAASyO,KAG7C3G,gCAAgCC,GAC9B,OAAO1I,KAAKkE,QAAQ0E,qBAAqBF,GAG3CwT,qBACE9M,EACAoL,EACA3T,GAEA,MAAMoQ,EAAejX,KAAKmc,qBAAqB3B,GAC/CvD,EAAajO,UAAUoG,EAAMvI,GAE7B,MAAMuV,EACJvV,IAAcJ,EAAoBK,IAClC9G,KAAKqc,uBAAuBlO,IAAI8I,GAE5BqF,EACJzV,IAAcJ,EAAoBO,KAClChH,KAAKuc,uBAAuBpO,IAAI8I,GAgClC,OA9BImF,GAAYpc,KAAKqc,uBAAuB1V,IAAIsQ,GAC5CqF,GAAYtc,KAAKuc,uBAAuB5V,IAAIsQ,GAEhDjX,KAAKwc,eAAexQ,SAAQgI,IAC1B,GAAIA,IAAUiD,EAAd,CAEA,GAAImF,GAAcpc,KAAKuc,uBAAuBpO,IAAI6F,GAAQ,CACxD,MAAMsF,EAAO,IAAIJ,EACfA,EAAK0C,oBACH5b,KAAKkE,QACLlE,KAAKkE,QAAQiB,OAAOoV,IAAItD,EAAa/O,UAAUsS,MAC/CxG,EAAM9L,SAASqS,IAAIva,KAAKkE,QAAQiB,QAAQqV,QAI5Cxa,KAAKyc,SAAS,IAAIC,GAAKzF,EAAcjD,EAAO,MAAEsF,KAGhD,GAAIgD,GAActc,KAAKqc,uBAAuBlO,IAAI6F,GAAQ,CACxD,MAAMsF,EAAO,IAAIJ,EACfA,EAAK0C,oBACH5b,KAAKkE,QACLlE,KAAKkE,QAAQiB,OAAOoV,IAAIvG,EAAM9L,UAAUsS,MACxCvD,EAAa/O,SAASqS,IAAIva,KAAKkE,QAAQiB,QAAQqV,QAGnDxa,KAAKyc,SAAS,IAAIC,GAAK1I,EAAOiD,EAAc,MAAEqC,UAI3CrC,EAGTkF,qBAAqBQ,GACnB,MAAMC,EAAWD,EAAM3X,WACvB,GAAIhF,KAAK6c,sBAAsBD,GAC7B,OAAO5c,KAAK6c,sBAAsBD,GAGpC,MAAM3F,EAAejX,KAAK8c,2BAA2BH,GAErD,OADA3c,KAAK6c,sBAAsBD,GAAY3F,EAChCA,EAGT6F,2BAA2BC,GACzB,MAAM7U,EAAWlI,KAAKyI,gCAAgCsU,GACtD,OAAO,IAAIjN,EAAa5H,EAAS9C,EAAG8C,EAAS7C,GAG3CmX,qBACF,OAAOja,EAAAuZ,QACLkB,OAAOC,KAAKjd,KAAK6c,uBAAuBvM,KACtCkK,GAASxa,KAAK6c,sBAAsBrC,MAK1CiC,SAASS,GACPld,KAAKic,OAAO5U,KAAK6V,GACbld,KAAKD,YACPC,KAAKE,WAAWS,SAASuc,eA9FjB9X,EAAWC,EAAWC,GAChCS,QARW/F,KAEb6c,sBAAiE,GAFpD7c,KAGbqc,uBAA4C,IAAItT,IAHnC/I,KAIbuc,uBAA4C,IAAIxT,IAJnC/I,KAKbic,OAAiB,GAIfjc,KAAKkE,QAAU,IAAI8B,EAAAC,QAAOb,EAAGC,EAAGC,ICNpC,MAAM6X,GAAkB7W,EAAOyB,OAAO,IAIhCqV,GAAkB,CAAC,EAAG,IACtBC,GAAyBD,GAAgBvC,QAAM,CAAEyC,EAAGC,IAAMD,EAAIC,GAAG,SASlDb,WAAa5c,EA8D5BgR,aACF,OAAO9Q,KAAKwd,MAAM5C,YAGhBlL,YACF,OAAO1P,KAAKwd,MAAM/C,WAGhBvE,UACF,OAAOlW,KAAKwd,MAAM7C,SAGhBlL,iCACF,GAAIzP,KAAKyd,mBAAmB3M,OAAQ,CAClC,MAAM4H,EACJ1Y,KAAKyd,mBAAmB5C,QAAM,CAC3B6C,EAAKjQ,IAAciQ,EAAMjQ,EAAU+F,OACpC,GACExT,KAAKyd,mBAAmB3M,OAC9B,OAAO9Q,KAAK8Q,OAAS4H,EAGvB,OAAO1Y,KAAK8Q,QAAgC,GAAtBlD,EAAUqL,WAGlC0E,yBACE,MAAMC,EAAgB5d,KAAK0Q,0BAA0B,GACrD,OAAKkN,GAEHA,EAAcjN,sBAAwBiN,EAAc7G,kBAIxD5G,oBAAoB0N,GAClB7d,KAAKyd,mBAAmBpW,KAAKwW,GAC7BA,EAAU3J,cAAclU,MAG1BoN,gBAAgBC,GACd,MAAM3B,EAAQ1L,KAAKyd,mBAAmB9R,QAAQ0B,GAC9C,OAAc,IAAV3B,IACJ1L,KAAK8d,uBAAuBpS,IACrB,GAGToS,uBAAuBpS,GACrB,MAAM+B,EAAYzN,KAAKyd,mBAAmB/R,GAG1C,OAFA1L,KAAKyd,mBAAmB7R,OAAOF,EAAO,GACtC+B,EAAU2G,oBACH3G,EAGT5E,qBAAqBC,EAA4B,IAAIC,KAEnD,OAAID,EAAQqF,IAAInO,KAAKsP,IADP,GAEP,IAAItP,KAAKsP,GAAGzG,qBAAqBC,GAAU9I,KAAKsP,IAGzDwD,mBAAmB5K,GACjB,OAAOlI,KAAKwd,MAAM1K,mBAAmB5K,GAGvC4M,mBAAmBmG,GACjB,OAAOjb,KAAKwd,MAAM1I,mBAAmBmG,GAGvCvK,0BAA0BqN,GACxB,IAAIvN,EAAgB,KAChBwN,EAAe/O,EAAAA,EAWnB,OATAjP,KAAKyd,mBAAmBzR,SAAQyB,IAC9B,MAAMwQ,EAAWxQ,EAAUkD,sBAAwBoN,EAC/CE,GAAY,GACZA,EAAWD,IACbA,EAAeC,EACfzN,EAAgB/C,MAIb+C,EAGTK,2BAA2BqN,GACzB,IAAI1N,EAAgB,KAChBwN,EAAe/O,EAAAA,EAWnB,OATAjP,KAAKyd,mBAAmBzR,SAAQyB,IAC9B,MAAMwQ,EAAWC,EAAWzQ,EAAUkD,sBAClCsN,GAAY,GACZA,EAAWD,IACbA,EAAeC,EACfzN,EAAgB/C,MAIb+C,EAGTnQ,KAAKC,EAA+BiK,GAClCjK,EAAIoE,YACJpE,EAAI6d,QAAU,QACd7d,EAAI8d,SAAW,QACfnZ,EAAAqU,KAAkBhZ,EAAKN,KAAKwd,OAU5B,MAAMa,EAAYre,KAAKse,oBACjBC,EAAalB,GAAyBgB,EAC5C/d,EAAIke,YAAYpB,GAAgB9M,KAAIQ,GAAUA,EAASuN,KACvD/d,EAAIme,YAActB,GAAgBnY,WAClC1E,EAAIoe,eA1LgB,KA0LGnU,EAAyB8T,EAAaE,EAC7Dje,EAAIqe,UA9LgB,EAiMpBre,EAAIse,SAGNN,oBACE,MACMO,EADiBtb,KAAKub,MAAM9e,KAAK8Q,OAASuM,IACPA,GAWzC,OATwBrd,KAAK8Q,OAAS+N,EAEpCA,EAAkBxB,GAAyBrd,KAAK8Q,OAI5C9Q,KAAK8Q,OAAS+N,EACd7e,KAAK8Q,QAAU+N,EAAkBxB,gBA5LvCzN,EACAN,GACC6J,OAACA,EAAMmC,UAAEA,EAAShC,KAAEA,GAAsB,IAE3CvT,QAZW/F,KACb+e,QAAS,EADI/e,KAKbyd,mBAAkC,GAShC,MAAMuB,EAAY7F,EACdvJ,EAAK1H,SAAS+W,QAAQ9F,EAAO,IAC7BvJ,EAAK1H,SAAS+W,QAAQ3P,EAAGpH,UAEvB+W,EAAU9F,EACZ7J,EAAGpH,SAAS+W,QAAQ9F,EAAOA,EAAOrI,OAAS,IAC3CxB,EAAGpH,SAAS+W,QAAQrP,EAAK1H,UAG3BlI,KAAKwd,MADHlE,IAEOH,EACID,EAAKgG,sBAChBtP,EAAKnH,gCAAgCuW,MAClC7F,EACH7J,EAAG7G,gCAAgCwW,KAGxB,IAAI/F,GAAOK,WACtB,IAAIC,EAAAvT,QACF2J,EAAKnH,gCAAgCuW,GACrC1P,EAAG7G,gCAAgCwW,MAKxB,MAAb3D,GACFtb,KAAKwd,MAAMlC,UAAUA,GAGnB1L,aAAgBoM,EAClBhc,KAAK4P,KAAOA,EAAKsM,qBACflc,KACAgf,EACAvY,EAAoBO,MAGtBhH,KAAK4P,KAAOA,EACZA,EAAK5G,UAAUhJ,KAAMyG,EAAoBO,MAGvCsI,aAAc0M,EAChBhc,KAAKsP,GAAKA,EAAG4M,qBAAqBlc,KAAMif,EAASxY,EAAoBK,KAErE9G,KAAKsP,GAAKA,EACVA,EAAGtG,UAAUhJ,KAAMyG,EAAoBK,MCvE7C,MAUMqY,GAAa/Y,EAAKwB,QAAQ,IAC1BwX,GAAchZ,EAAK2B,OAAO,IAC1BsX,GAAcjZ,EAAKwB,QAAQ,IAAK7C,KAAK,UAEtBua,WAAiBxf,EAiBhCoI,eACF,OAAOlI,KAAKkE,QAAQiB,OAGlBmD,0BACF,OAAOtI,KAAKuI,eAAenB,SAGzBoB,0BACF,OAAOxI,KAAKuI,eAAehB,SAG7BsB,qBAAqBC,EAA4B,IAAIC,KAEnD,OADAD,EAAQnC,IAAI3G,MACLuC,EAAA6N,KACL7N,EAAA8N,QACErQ,KAAKuI,eAAehB,SAAS+I,KAAIlB,GAC/BA,EAAKvG,qBAAqBC,OAMlCL,gCAAgCC,GAC9B,OAAO1I,KAAK2I,wBAAwBC,qBAAqBF,GAG3DQ,mBACE,MAAM,IAAIhC,MAAM,qCAGlB8B,UAAUC,EAAYpC,GACpB7G,KAAKuI,eAAe5B,IAAIsC,EAAMpC,GAGhCrG,OAAOC,GACLT,KAAKoI,OAAS7F,EAAA8G,UAAU,EAAGrJ,KAAKqI,UAAWrI,KAAKoI,OAAS3H,GACrDT,KAAKoI,QAAUpI,KAAKqI,WACtBrI,KAAKuf,cAITlf,KAAKC,GACH,MAAMgJ,EAAWtJ,KAAKoI,OAASpI,KAAKqI,UAE9BkB,EAAiBhH,EAAA8G,UACrB,EACA,EACA9G,EAAAiH,SAAS,EAvEa,IAuEW,EAAG,EAAGxJ,KAAKoI,SAExCqB,EAAU0V,GAAWzV,IAAI0V,GAAa7V,GAE5CjJ,EAAIoE,YACJpE,EAAIuE,UAAY4E,EAAQzE,WACxBC,EAAAC,OACE5E,EACAN,KAAKkE,QAAQiB,OAAOC,EACpBpF,KAAKkE,QAAQiB,OAAOE,EACpBrF,KAAKkE,QAAQoB,QAEfhF,EAAIiF,OAEJjF,EAAIoE,YACJpE,EAAIuE,UAAYua,GAAYpa,WAC5B1E,EAAIqJ,OAAO3J,KAAKkE,QAAQiB,OAAOC,EAAGpF,KAAKkE,QAAQiB,OAAOE,GACtD/E,EAAIkf,IACFxf,KAAKkE,QAAQiB,OAAOC,EACpBpF,KAAKkE,QAAQiB,OAAOE,EACpBrF,KAAKkE,QAAQoB,QACZ/B,KAAKE,GAAK,EACA,EAAX6F,EAAe/F,KAAKE,GAAKF,KAAKE,GAAK,GACnC,GAEFnD,EAAIiF,OAEJjF,EAAIoE,YACJpE,EAAIuE,UAAYsa,GAAWna,WAC3BC,EAAAC,OACE5E,EACAN,KAAKkE,QAAQiB,OAAOC,EACpBpF,KAAKkE,QAAQiB,OAAOE,EA3GLoa,IA8GjBnf,EAAIiF,OAGN4D,cACEnJ,KAAKoI,OAAS,EAGhBmX,cAC2Bvf,KAAK0f,0BAE5B1f,KAAKoJ,SACLpJ,KAAKmJ,eAITC,SACEpJ,KAAKE,WAAW2J,eACd7J,KACA,IAAI4D,EAAM,CACRwB,EAAGpF,KAAKkE,QAAQiB,OAAOC,EACvBC,EAAGrF,KAAKkE,QAAQiB,OAAOE,EACvBG,YArIO,GAsIPC,UAnIa,GAoIbC,SAlIe,IAmIfC,MAAO0Z,GACPzZ,WAAYtC,EACZwC,kBAAkB,KAKxB4Z,wBACE,MAAMtQ,EAAOpP,KAAKuI,eAAeb,iBACjC,KAAM0H,aAAgBsN,IAAO,OAAO,EAEpC,GAAItN,EAAKuO,yBAA0B,CACjC,MAAMlQ,EAAY,IAAIG,EAGtB,OAFAwB,EAAKe,oBAAoB1C,GACzBzN,KAAKE,WAAWS,SAAS8M,IAClB,EAEP,OAAO,cApICrI,EAAWC,EAAWyE,EAvBX,KAwBrB/D,QAVW/F,KACb+J,eAAgB,EADH/J,KAEbmI,qBAAsB,EAFTnI,KAObuI,eAAgC,IAAI7B,EAIlC1G,KAAKkE,QAAU,IAAI8B,EAAAC,QAAOb,EAAGC,EAvBlB,IAwBXrF,KAAK2I,wBAA0B,IAAI3C,EAAAC,QAAOb,EAAGC,EAvBhB,IAwB7BrF,KAAKqI,UAAYyB,EACjB9J,KAAKoI,OAAS0B,gBChClB,MAEM6V,GAAQ,UCwBRpS,YACF,OAAOvN,KAAK4f,OAAOrS,MAAQvN,KAAK6f,aAG9BrS,aACF,OAAOxN,KAAK4f,OAAOpS,OAASxN,KAAK6f,aAG/BC,kBACF,OAAO9f,KAAK6f,aAGVE,gBACF,OAA4B,OAArB/f,KAAKggB,aAAwBhgB,KAAKigB,WAGvCF,cAAUG,GACZ/f,EAAAC,OACuB,OAArBJ,KAAKggB,YACL,8CAEFhgB,KAAKigB,WAAaC,EAGhBxS,eACF,OAAO1N,KAAKmgB,UAGdC,SAASC,GACPA,EAAQC,YAAYtgB,KAAK4f,QAG3BW,UAAUC,GACR,OAAOxgB,KAAKygB,eAAetS,IAAIqS,GAGjCnM,UAAiCqM,GAC/B,MAAMC,EAAS3gB,KAAKygB,eAAetR,IAAIuR,GAGvC,OAFAvgB,EAAAC,OAAOugB,EAAM,WAAaD,EAAW/V,wBACrCxK,EAAAC,OAAOugB,aAAkBD,EAAY,iCAC9BC,EAGTC,UAAUD,GACRxgB,EAAAC,QACGJ,KAAKugB,UAAUI,EAAOzf,aACvB,wCAEFlB,KAAKygB,eAAelS,IAAIoS,EAAOzf,YAAoByf,GACnDA,EAAO1W,gBAAgBjK,MAGzB6gB,aAAaC,GACI9gB,KAAKqU,UAAUyM,GACvB5W,sBAAsBlK,MAC7BA,KAAKygB,eAAe9R,OAAOmS,GAG7BngB,SAASogB,GACP/gB,KAAKmgB,UAAU9Y,KAAK0Z,GACpBA,EAAMngB,eAAeZ,MAGvB6J,eAAemX,EAA0BC,GACvC,MAAMvV,EAAQ1L,KAAKmgB,UAAUxU,QAAQqV,GACrC7gB,EAAAC,QAAiB,IAAVsL,EAAc,gCAErB1L,KAAKkhB,gBAAgBxV,EAAOuV,GAG9BE,cAAcC,EAA0BC,GACtC,MAAM3V,EAAQ1L,KAAKmgB,UAAUxU,QAAQyV,GACrCjhB,EAAAC,QAAiB,IAAVsL,EAAc,gCAErB1L,KAAKkhB,gBAAgBxV,EAAQ,EAAG2V,GAGlCH,gBAAgBxV,EAAe4V,GAC7BthB,KAAKmgB,UAAUvU,OAAOF,EAAO,EAAG4V,GAChCA,EAAM1gB,eAAeZ,MAGvByE,YAAY8c,GACV,MAAM7V,EAAQ1L,KAAKmgB,UAAUxU,QAAQ4V,GACrC,OAAc,IAAV7V,IAEJ1L,KAAKwhB,mBAAmB9V,IACjB,GAGT8V,mBAAmBC,GACjB,MAAM9T,EAAQ3N,KAAKmgB,UAAUsB,GAG7B,OAFAzhB,KAAKmgB,UAAUvU,OAAO6V,EAAO,GAC7B9T,EAAM7M,qBACC6M,EAGTnN,OAAOC,GACL,IAAK,IAAI2B,EAAI,EAAGA,EAjIC,EAiIiBA,IAAK,CACrC,IAAK,MAAMue,KAAU3gB,KAAKygB,eAAevO,SACvCyO,EAAOxW,aAAa1J,GAEtBT,KAAKmgB,UAAUnU,SAAS2B,GAAUA,EAAMnN,OAAOC,KAC/C,IAAK,MAAMihB,KAAU1hB,KAAKygB,eAAevO,SACvCwP,EAAOtX,YAAY3J,IAKzBJ,KAAKshB,GACH3hB,KAAKM,IAAIshB,OACT5hB,KAAKM,IAAIuhB,MAAM7hB,KAAK6f,aAAc7f,KAAK6f,cACvC7f,KAAKM,IAAIwhB,UAAU,EAAG,EAAG9hB,KAAKuN,MAAOvN,KAAKwN,QAE1C,IAAK,MAAMmT,KAAU3gB,KAAKygB,eAAevO,SACvCyO,EAAOrW,WAAWtK,KAAKM,IAAKqhB,GAE9B3hB,KAAKmgB,UACF4B,MAAI,CAAEzE,EAAGC,IAAMD,EAAEvc,eAAiBwc,EAAExc,iBACpCiL,SAAS2B,GAAUA,EAAMtN,KAAKL,KAAKM,IAAKqhB,KAC3C,IAAK,MAAMK,KAAUhiB,KAAKygB,eAAevO,SACvC8P,EAAOxX,UAAUxK,KAAKM,IAAKqhB,GAG7B3hB,KAAKM,IAAI2hB,UAGXvS,QACE1P,KAAKigB,YAAa,EAClBjgB,KAAKggB,YAAckC,OAAOC,sBAAsBniB,KAAKoiB,OAGvDC,OAC2B,OAArBriB,KAAKggB,cACPkC,OAAOI,qBAAqBtiB,KAAKggB,aACjChgB,KAAKggB,YAAc,MAErBhgB,KAAKigB,YAAa,EAClBjgB,KAAKuiB,gBAAkB,KAkBzBC,wBACE,IAAIC,GAAgB,EACpBC,SAASC,iBAAiB,oBAAkB,KACtCD,SAASE,QAAU5iB,KAAK+f,YAC1B0C,GAAgB,EAChBziB,KAAKqiB,QAEHI,IAAkBC,SAASE,SAC7BH,GAAgB,EAChBziB,KAAK0P,wBAnLCnC,EAAeC,EAAgBsS,EAAsB,GAVpD9f,KAILmgB,UAA2B,GAJtBngB,KAKLigB,YAAsB,EALjBjgB,KAMLggB,YAA6B,KANxBhgB,KAOLuiB,gBAAiC,KAP5BviB,KAQLygB,eAAiB,IAAIpS,IARhBrO,KAqKboiB,MAAS7hB,IACPA,GA/KU,EAgLV,MAAMgiB,EAAkBviB,KAAKuiB,gBAC7B,GAAwB,OAApBA,EAA0B,CAC5B,MAAM1e,EAAYtD,EAAcgiB,EAC5BviB,KAAK+f,YACP/f,KAAKQ,OAAOqD,GACZ7D,KAAKK,KAAKE,IAIdP,KAAKuiB,gBAAkBhiB,EACvBP,KAAKggB,YAAckC,OAAOC,sBAAsBniB,KAAKoiB,QAtKrDpiB,KAAK4f,OAAS8C,SAASG,cAAc,UACrC7iB,KAAK4f,OAAOrS,MAAQA,EAAQuS,EAC5B9f,KAAK4f,OAAOpS,OAASA,EAASsS,EAC9B9f,KAAK4f,OAAOkD,MAAMvV,MAAK,GAAMA,MAC7BvN,KAAK4f,OAAOkD,MAAMtV,OAAM,GAAMA,MAC9B,MAAMlN,EAAMN,KAAK4f,OAAOmD,WAAW,MACnC5iB,EAAAC,OAAOE,EAAK,OACZN,KAAKM,IAAMA,EACXN,KAAK6f,aA3BK,EA2BUC,EAEpB9f,KAAKwiB,0BDrBe,IAAK,IAAKN,OAAOc,kBACnCC,GAAOP,SAASQ,eAAe,QACrC/iB,EAAAC,OAAO6iB,GAAM,yBACbtD,GAAMS,SAAS6C,IAGftD,GAAMiB,UAAU,IAAIzT,cAyDlB,MAAMgW,EAAgB,IAAIlb,EAAS,IAAK,IAAK,MACvCmb,EAAiB,IAAInb,EAAS,IAAK,IAAK,MACxCob,EAAgB,IAAIpb,EAAS,IAAK,IAAK,MACvCqb,EAAe,IAAIhE,GAAS,IAAK,IAAK,KACtCiE,EAAe,IAAIjE,GAAS,IAAK,IAAK,KAG5CK,GAAMhf,SAASwiB,GACfxD,GAAMhf,SAASyiB,GACfzD,GAAMhf,SAAS0iB,GACf1D,GAAMhf,SAAS2iB,GACf3D,GAAMhf,SAAS4iB,GAEf,MAAMC,EAAe,IAAIxH,EAAS,IAAK,IA9E3B,IA+ENyH,EAAoB,IAAIzH,EAAS,IAAK,IA/EhC,IAgFN0H,EAAoB,IAAI1H,EAAS,IAAK,IAhFhC,IAiFZ2D,GAAMhf,SAAS6iB,GACf7D,GAAMhf,SAAS8iB,GACf9D,GAAMhf,SAAS+iB,GACf/D,GAAMhf,SAAS,IAAI+b,GAAK6G,EAAcC,IACtC7D,GAAMhf,SAAS,IAAI+b,GAAK4G,EAAcG,IACtC9D,GAAMhf,SAAS,IAAI+b,GAAK+G,EAAmBC,IAQ3C/D,GAAMhf,SACJ,IAAI+b,GAAK+G,EAAmBD,EAAc,CACxCrK,OAAQ,CAAC,IAAInI,EAAA/K,QAAQ,IAAK,KAAM,IAAI+K,EAAA/K,QAAQ,IAAK,KACjDqV,UAjGQ,MAsGZqE,GAAMhf,SAAS,IAAI+b,GAAK8G,EAAcE,IACtC/D,GAAMhf,SAAS,IAAI+b,GAAKgH,EAAmBP,IAC3CxD,GAAMhf,SAAS,IAAI+b,GAAK8G,EAAcJ,IACtCzD,GAAMhf,SAAS,IAAI+b,GAAK8G,EAAcH,IA/FxCM,GAEAhE,GAAMjQ","sources":["src/lib/scene/SceneObject.ts","src/lib/easings.ts","src/network/effects/Pulse.ts","src/network/colors.ts","src/network/ConnectionDirection.ts","src/network/ConnectionSet.ts","src/network/networkNodes/Consumer.ts","src/lib/scene/SceneSystem.ts","src/lib/QuadTree.ts","src/network/TravellerFinder.ts","src/network/PathFinder.ts","src/network/networkNodes/Intersection.ts","src/lib/scene/SortOrderProvider.ts","src/lib/scene/Entity.ts","src/network/Traveller.ts","src/pals/makePal.ts","src/lib/geom/Path.ts","src/network/Junction.ts","src/network/Road.ts","src/network/networkNodes/Producer.ts","src/network/network-main.ts","src/lib/scene/Scene.ts"],"sourcesContent":["import { assert } from '../assert';\nimport Scene from './Scene';\n\nconst constructorIdCounts = {} as Record<string, number>;\n\nconst getNextCount = (name: string): string => {\n  if (!constructorIdCounts[name]) constructorIdCounts[name] = 0;\n  return `${name}@${constructorIdCounts[name]++}`;\n};\n\nexport default abstract class SceneObject {\n  id: string = getNextCount(this.constructor.name);\n  private scene: Scene | null = null;\n\n  hasScene(): boolean {\n    return this.scene !== null;\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene must be present');\n    return this.scene;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {}\n  update(delta: number): void {}\n\n  addTo(scene: Scene): this {\n    scene.addChild(this);\n    return this;\n  }\n\n  onAddedToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  onRemovedFromScene() {\n    this.scene = null;\n  }\n\n  getSortOrder(): number {\n    return 0;\n  }\n}\n","import { approxEq } from './utils';\n\n/** n should be between 0 and 1 */\nexport type Easing = (n: number) => number;\n\n// based on https://github.com/servo/servo/blob/0d0cfd030347ab0711b3c0607a9ee07ffe7124cf/components/style/bezier.rs\nclass UnitBezier {\n  private static readonly NEWTON_METHOD_ITERATIONS = 8;\n  private static readonly DEFAULT_EPSILON = 1e-6;\n  private readonly ax: number;\n  private readonly bx: number;\n  private readonly cx: number;\n  private readonly ay: number;\n  private readonly by: number;\n  private readonly cy: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    const cx = 3 * x1;\n    const bx = 3 * (x2 - x1) - cx;\n\n    const cy = 3 * y1;\n    const by = 3 * (y2 - y1) - cy;\n\n    this.ax = 1.0 - cx - bx;\n    this.bx = bx;\n    this.cx = cx;\n    this.ay = 1.0 - cy - by;\n    this.by = by;\n    this.cy = cy;\n  }\n\n  private sampleCurveX(t: number): number {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }\n\n  private sampleCurveY(t: number): number {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }\n\n  private sampleCurveDerivativeX(t: number): number {\n    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n  }\n\n  private solveCurveX(x: number, epsilon: number): number {\n    // Fast path: Use Newton's method.\n    let t = x;\n    for (let i = 0; i < UnitBezier.NEWTON_METHOD_ITERATIONS; i++) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      let dx = this.sampleCurveDerivativeX(t);\n      if (approxEq(dx, 0.0, 1e-6)) {\n        break;\n      }\n      t -= (x2 - x) / dx;\n    }\n\n    // Slow path: Use bisection.\n    let lo = 0;\n    let hi = 1;\n    t = x;\n\n    if (t < lo) {\n      return lo;\n    }\n    if (t > hi) {\n      return hi;\n    }\n\n    while (lo < hi) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      if (x > x2) {\n        lo = t;\n      } else {\n        hi = t;\n      }\n      t = (hi - lo) / 2.0 + lo;\n    }\n\n    return t;\n  }\n\n  solve(x: number, epsilon: number = UnitBezier.DEFAULT_EPSILON): number {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n  }\n}\n\nexport const cubicBezier = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): Easing => {\n  const bezier = new UnitBezier(x1, y1, x2, y2);\n  return (x) => bezier.solve(x);\n};\n\n/**\n * P(t) = (1-t)^3*P0 + 3*t*(1-t)^2*P1 + 3*t^2*(1-t)*P2 + t^3*P3\n * x = 3*t*(1-t)^2*p1x + 3*t^2*(1-t)*p2x + t^3\n * y(t) = 3*t*(1-t)^2*p1y + 3*t^2*(1-t)*p2y + t^3\n *\n *\n * y = 3*u1*(1-x)^2*x + 3*u2*(1-x)*x^2 + x^3\n */\n\n// https://gist.github.com/rezoner/713615dabedb59a15470\n// http://gsgd.co.uk/sandbox/jquery/easing/\nexport const reverse =\n  (easing: (n: number) => number) =>\n  (n: number): number =>\n    easing(1 - n);\n\nexport const linear = (n: number): number => n;\n\nexport const inQuad = (t: number): number => t * t;\n\nexport const outQuad = (t: number): number => t * (2 - t);\n\nexport const inOutQuad = (t: number): number =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\nexport const inCubic = (t: number): number => t * t * t;\n\nexport const outCubic = (t: number): number => --t * t * t + 1;\n\nexport const inOutCubic = (t: number): number =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nexport const inQuart = (t: number): number => t * t * t * t;\n\nexport const outQuart = (t: number): number => 1 - --t * t * t * t;\n\nexport const inOutQuart = (t: number): number =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\nexport const inQuint = (t: number): number => t * t * t * t * t;\n\nexport const outQuint = (t: number): number => 1 + --t * t * t * t * t;\n\nexport const inOutQuint = (t: number): number =>\n  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nexport const inSine = (t: number): number =>\n  -1 * Math.cos((t / 1) * (Math.PI * 0.5)) + 1;\n\nexport const outSine = (t: number): number =>\n  Math.sin((t / 1) * (Math.PI * 0.5));\n\nexport const inOutSine = (t: number): number =>\n  (-1 / 2) * (Math.cos(Math.PI * t) - 1);\n\nexport const inExpo = (t: number): number =>\n  t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n\nexport const outExpo = (t: number): number =>\n  t == 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n\nexport const inOutExpo = (t: number): number => {\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if ((t /= 1 / 2) < 1) return (1 / 2) * Math.pow(2, 10 * (t - 1));\n  return (1 / 2) * (-Math.pow(2, -10 * --t) + 2);\n};\n\nexport const inCirc = (t: number): number => -1 * (Math.sqrt(1 - t * t) - 1);\n\nexport const outCirc = (t: number): number => Math.sqrt(1 - (t = t - 1) * t);\n\nexport const inOutCirc = (t: number): number => {\n  if ((t /= 1 / 2) < 1) return (-1 / 2) * (Math.sqrt(1 - t * t) - 1);\n  return (1 / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1);\n};\n\nexport const inElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return -(\n    a *\n    Math.pow(2, 10 * (t -= 1)) *\n    Math.sin(((t - s) * (2 * Math.PI)) / p)\n  );\n};\n\nexport const outElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return a * Math.pow(2, -10 * t) * Math.sin(((t - s) * (2 * Math.PI)) / p) + 1;\n};\n\nexport const inOutElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if ((t /= 1 / 2) == 2) return 1;\n  if (!p) p = 0.3 * 1.5;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  if (t < 1)\n    return (\n      -0.5 *\n      (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p))\n    );\n  return (\n    a *\n      Math.pow(2, -10 * (t -= 1)) *\n      Math.sin(((t - s) * (2 * Math.PI)) / p) *\n      0.5 +\n    1\n  );\n};\n\nexport const inBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    return 1 * t * t * ((s + 1) * t - s);\n  };\n\nexport const outBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    t = t - 1;\n    return 1 * (t * t * ((s + 1) * t + s) + 1);\n  };\n\nexport const inOutBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    if ((t /= 1 / 2) < 1)\n      return (1 / 2) * (t * t * (((s *= 1.525) + 1) * t - s));\n    return (1 / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  };\n\nexport const inBounce = (t: number): number => {\n  return 1 - outBounce(1 - t);\n};\n\nexport const outBounce = (t: number): number => {\n  if ((t /= 1) < 1 / 2.75) {\n    return 7.5625 * t * t;\n  } else if (t < 2 / 2.75) {\n    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n  } else if (t < 2.5 / 2.75) {\n    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n  } else {\n    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n  }\n};\n\nexport const inOutBounce = (t: number): number => {\n  if (t < 1 / 2) return inBounce(t * 2) * 0.5;\n  return outBounce(t * 2 - 1) * 0.5 + 0.5;\n};\n","import Color from 'color';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport Circle from '../../lib/geom/Circle';\nimport { linear, Easing } from '../../lib/easings';\nimport { lerp } from '../../lib/utils';\n\ntype PulseOptions = {\n  x: number;\n  y: number;\n  startRadius: number;\n  endRadius: number;\n  duration: number;\n  color: Color;\n  easeRadius?: Easing;\n  easeOpacity?: Easing;\n  removeOnComplete?: boolean;\n};\n\nexport default class Pulse extends SceneObject {\n  _circle: Circle;\n  _startRadius: number;\n  _endRadius: number;\n  _duration: number;\n  _color: Color;\n  _progress: number;\n  _easeRadius: Easing;\n  _easeOpacity: Easing;\n  _removeOnComplete: boolean;\n\n  constructor({\n    x,\n    y,\n    startRadius,\n    endRadius,\n    duration,\n    color,\n    easeRadius = linear,\n    easeOpacity = linear,\n    removeOnComplete = false,\n  }: PulseOptions) {\n    super();\n    this._circle = new Circle(x, y, startRadius);\n    this._startRadius = startRadius;\n    this._endRadius = endRadius;\n    this._duration = duration;\n    this._color = color;\n    this._progress = 0;\n    this._easeRadius = easeRadius;\n    this._easeOpacity = easeOpacity;\n    this._removeOnComplete = removeOnComplete;\n  }\n\n  update(deltaTime: number) {\n    const deltaProgress = deltaTime / this._duration;\n    this._progress = Math.min(1, this._progress + deltaProgress);\n    this._circle = this._circle.withRadius(\n      lerp(\n        this._startRadius,\n        this._endRadius,\n        this._easeRadius(this._progress),\n      ),\n    );\n\n    if (this._progress === 1 && this._removeOnComplete) {\n      this.getScene().removeChild(this);\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    const opacity = this._easeOpacity(this._progress);\n    ctx.fillStyle = this._color.fade(opacity).toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n  }\n}\n","import Color from 'color';\n\n// https://coolors.co/f8ffe5-06d6a0-1b9aaa-ef476f-ffc43d\nexport const LIGHT_BG = new Color('#F8FFE5');\nexport const TEAL = new Color('#06D6A0');\nexport const BLUE = new Color('#1B9AAA');\nexport const RED = new Color('#EF476F');\nexport const YELLOW = new Color('#FFC43D');\n","enum ConnectionDirection {\n  IN = 'in',\n  OUT = 'out',\n}\n\nexport default ConnectionDirection;\n","import { sample } from '../lib/utils';\nimport Road from './Road';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class ConnectionSet {\n  incoming: Road[] = [];\n  outgoing: Road[] = [];\n\n  add(target: Road, direction: ConnectionDirection) {\n    switch (direction) {\n      case ConnectionDirection.IN:\n        this.addIncoming(target);\n        break;\n      case ConnectionDirection.OUT:\n        this.addOutgoing(target);\n        break;\n      default:\n        throw new Error(`unknow connection direction ${direction}`);\n    }\n  }\n\n  addIncoming(target: Road) {\n    this.incoming.push(target);\n  }\n\n  addOutgoing(target: Road) {\n    this.outgoing.push(target);\n  }\n\n  sampleIncoming(): Road {\n    return sample(this.incoming);\n  }\n\n  sampleOutgoing(): Road {\n    return sample(this.outgoing);\n  }\n}\n","// @flow\nimport { assert } from '../../lib/assert';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { inBack, reverse, linear } from '../../lib/easings';\nimport { constrain, mapRange } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { RED } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 1000;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst PULSE_RADIUS = 25;\n\nconst CLOCK_FADE_DURATION = 150;\nconst PULSE_DURATION = 500;\n\nconst MAIN_COLOR = RED.lighten(0.2).desaturate(0.5);\nconst CLOCK_COLOR = RED.darken(0.2);\nconst PULSE_COLOR = RED.lighten(0.2).fade(0.4);\n\nexport default class Consumer extends SceneObject implements NetworkNode {\n  isDestination = true;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number = 0;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return this._timer >= this._cooldown;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return [this];\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  consumeTraveller() {\n    assert(this.canConsumeTraveller, 'must be ready to consumer traveller');\n    this._resetTimer();\n    this._pulse();\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius * progress,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        endRadius: RADIUS,\n        startRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: inBack(4),\n        easeOpacity: reverse(linear),\n        removeOnComplete: true,\n      }),\n    );\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport Scene from './Scene';\n\nconst DEFAULT_NAME = '$$AbstractSceneSystem$$';\n\nexport default abstract class SceneSystem {\n  static systemName = DEFAULT_NAME;\n  private scene: Scene | null = null;\n\n  constructor() {\n    assert(\n      this.constructor !== SceneSystem,\n      'SceneSystem is an abstract class that must be extended',\n    );\n    assert(\n      (this.constructor as any).systemName !== DEFAULT_NAME,\n      'classes extending SceneSystem must override SceneSystem.systemName',\n    );\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene is required');\n    return this.scene;\n  }\n\n  afterAddToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeRemoveFromScene(scene: Scene) {\n    this.scene = null;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  beforeDraw(ctx: CanvasRenderingContext2D, time: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterDraw(ctx: CanvasRenderingContext2D, time: number) {}\n}\n","import AABB from './geom/AABB';\nimport Circle from './geom/Circle';\nimport Vector2 from './geom/Vector2';\n\ntype Subdivisions<T> = [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>];\n\nexport default class QuadTree<T> {\n  static NODE_CAPACITY = 4;\n\n  boundary: AABB;\n  _items: (T | void)[] = [];\n  _nextItemIndex: number = 0;\n  _subdivisions: null | Subdivisions<T> = null;\n  _getPosition: (item: T) => Vector2;\n\n  constructor(boundary: AABB, getPosition: (item: T) => Vector2) {\n    this.boundary = boundary;\n    this._getPosition = getPosition;\n  }\n\n  // debugDraw(color: string) {\n  //   this.boundary.debugDraw(color);\n  //   if (this._subdivisions) {\n  //     this._subdivisions.forEach(subdivision => subdivision.debugDraw(color));\n  //   }\n  // }\n\n  insert(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    if (this._nextItemIndex < QuadTree.NODE_CAPACITY) {\n      this._items[this._nextItemIndex] = item;\n      this._nextItemIndex++;\n      return true;\n    }\n\n    const subdivisions = this._getSubdivisions();\n\n    if (subdivisions[0].insert(item)) return true;\n    if (subdivisions[1].insert(item)) return true;\n    if (subdivisions[2].insert(item)) return true;\n    if (subdivisions[3].insert(item)) return true;\n\n    throw new Error('Couldnt insert item');\n  }\n\n  remove(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    const index = this._items.indexOf(item);\n    if (index !== -1) {\n      this._items.splice(index, 1);\n      this._nextItemIndex--;\n      return true;\n    }\n\n    const subdivisions = this._subdivisions;\n    if (subdivisions) {\n      if (subdivisions[0].remove(item)) return true;\n      if (subdivisions[1].remove(item)) return true;\n      if (subdivisions[2].remove(item)) return true;\n      if (subdivisions[3].remove(item)) return true;\n    }\n\n    return false;\n  }\n\n  clear() {\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      this._items[i] = undefined;\n      this._nextItemIndex = 0;\n    }\n\n    if (this._subdivisions) {\n      this._subdivisions.forEach(subdivision => subdivision.clear());\n    }\n  }\n\n  findItemsInRect(rect: AABB): T[] {\n    const foundItems = [] as Array<T>;\n\n    if (!this.boundary.intersects(rect)) return foundItems;\n\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      const item = this._items[i];\n      if (item == null) continue;\n      const point = this._getPosition(item);\n      if (rect.contains(point)) foundItems.push(item);\n    }\n\n    const subdivisions = this._subdivisions;\n    if (!subdivisions) return foundItems;\n\n    if (subdivisions[0].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[0].findItemsInRect(rect));\n    }\n    if (subdivisions[1].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[1].findItemsInRect(rect));\n    }\n    if (subdivisions[2].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[2].findItemsInRect(rect));\n    }\n    if (subdivisions[3].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[3].findItemsInRect(rect));\n    }\n\n    return foundItems;\n  }\n\n  findItemsInCircle(circle: Circle): T[] {\n    return this.findItemsInRect(circle.getBoundingBox()).filter(item =>\n      circle.containsPoint(this._getPosition(item)),\n    );\n  }\n\n  _getSubdivisions(): Subdivisions<T> {\n    if (this._subdivisions) return this._subdivisions;\n\n    const center = this.boundary.getCenter();\n    const subdivisions: Subdivisions<T> = [\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          this.boundary.top,\n          center.x,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          this.boundary.top,\n          this.boundary.right,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          center.y,\n          center.x,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          center.y,\n          this.boundary.right,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n    ];\n\n    this._subdivisions = subdivisions;\n    return subdivisions;\n  }\n}\n","// @flow\nimport Scene from '../lib/scene/Scene';\nimport SceneSystem from '../lib/scene/SceneSystem';\nimport QuadTree from '../lib/QuadTree';\nimport Circle from '../lib/geom/Circle';\nimport AABB from '../lib/geom/AABB';\nimport Traveller from './Traveller';\n\nexport default class TravellerFinder extends SceneSystem {\n  static systemName = 'TravellerFinder';\n\n  _quadTree!: QuadTree<Traveller>;\n\n  removeTraveller(traveller: Traveller) {\n    this._quadTree.remove(traveller);\n  }\n\n  afterAddToScene(scene: Scene) {\n    super.afterAddToScene(scene);\n    this._quadTree = new QuadTree(\n      AABB.fromLeftTopRightBottom(0, 0, scene.width, scene.height),\n      traveller => traveller.position,\n    );\n  }\n\n  beforeUpdate() {\n    const scene = this.getScene();\n    this._quadTree.clear();\n    scene.children.forEach(child => {\n      if (child instanceof Traveller) {\n        this._quadTree.insert(child);\n      }\n    });\n    // this._quadTree.debugDraw('red');\n  }\n\n  findTravellersInCircle(circle: Circle) {\n    return this._quadTree.findItemsInCircle(circle);\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Road from './Road';\nimport { NetworkNode } from './networkNodes/NetworkNode';\n\nconst PathFinder = {\n  getNextRoad(initialNode: NetworkNode, destinationNode: NetworkNode): Road {\n    const remainingNodes = new Set(initialNode.getAllReachableNodes());\n    remainingNodes.add(initialNode);\n    assert(\n      remainingNodes.has(destinationNode),\n      'destination must be reachable',\n    );\n    const bestCosts = new Map();\n    const prevRoads = new Map();\n\n    bestCosts.set(initialNode, 0);\n\n    while (remainingNodes.size) {\n      const { node, cost } = PathFinder._nodeWithShortestDistance(\n        remainingNodes,\n        bestCosts,\n      );\n      remainingNodes.delete(node);\n\n      if (node === destinationNode) {\n        return PathFinder._nextRoadFromRoute(\n          prevRoads,\n          initialNode,\n          destinationNode,\n        );\n      }\n\n      PathFinder._updateNeighbours(node, bestCosts, cost, prevRoads);\n    }\n\n    throw new Error('unreachable i hope');\n  },\n\n  _nodeWithShortestDistance(\n    nodes: Set<NetworkNode>,\n    costs: Map<NetworkNode, number>,\n  ): { node: NetworkNode; cost: number } {\n    let bestCost = Infinity;\n    let bestNode = null;\n\n    nodes.forEach(node => {\n      const cost = costs.get(node);\n      if (cost != null && cost <= bestCost) {\n        bestCost = cost;\n        bestNode = node;\n      }\n    });\n\n    assert(bestNode, 'node must be found');\n    return { node: bestNode, cost: bestCost };\n  },\n  _updateNeighbours(\n    node: NetworkNode,\n    bestCosts: Map<NetworkNode, number>,\n    cost: number,\n    prevRoads: Map<NetworkNode, Road>,\n  ) {\n    node.outgoingConnections.forEach(road => {\n      const nextNode = road.to;\n      const nextNodeCost = bestCosts.get(nextNode);\n      const altNextNodeCost = cost + road.expectedTimeFromStartToEnd;\n      if (nextNodeCost == null || altNextNodeCost <= nextNodeCost) {\n        bestCosts.set(nextNode, altNextNodeCost);\n        prevRoads.set(nextNode, road);\n      }\n    });\n  },\n  _nextRoadFromRoute(\n    prevRoads: Map<NetworkNode, Road>,\n    start: NetworkNode,\n    finish: NetworkNode,\n  ): Road {\n    let node = finish;\n    while (prevRoads.has(node)) {\n      const road = prevRoads.get(node);\n      assert(road, 'road must exist');\n      node = road.from;\n      if (node === start) return road;\n    }\n\n    throw new Error('prev road must be found');\n  },\n};\n\nexport default PathFinder;\n","// @flow\nimport { assert } from '../../lib/assert';\nimport Vector2 from '../../lib/geom/Vector2';\nimport { uniq, flatten } from '../../lib/utils';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport PathFinder from '../PathFinder';\nimport Road from '../Road';\nimport Traveller from '../Traveller';\nimport { NetworkNode } from './NetworkNode';\n\nexport default class Intersection implements NetworkNode {\n  isDestination = false;\n  position: Vector2;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number) {\n    this.position = new Vector2(x, y);\n  }\n\n  get incomingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.outgoing;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return true;\n  }\n\n  consumeTraveller(traveller: Traveller) {\n    const destination = traveller.destination;\n    assert(destination, 'traveller must have destination');\n\n    const nextRoad = PathFinder.getNextRoad(this, destination);\n    assert(\n      this.outgoingConnections.includes(nextRoad),\n      'nextRoad must be from this intersection',\n    );\n\n    traveller.removeFromCurrentRoad();\n    nextRoad.addTravellerAtStart(traveller);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(): Vector2 {\n    return this.position;\n  }\n\n  getClosestOutgoingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.outgoingConnections.forEach(road => {\n      const traveller = road.getTravellerAfterPosition(-1);\n      if (traveller && traveller.positionOnCurrentRoad < shortestDistance) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.positionOnCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getClosestIncomingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.incomingConnections.forEach(road => {\n      const traveller = road.getTravellerBeforePosition(road.length);\n      if (\n        traveller &&\n        traveller.distanceToEndOfCurrentRoad < shortestDistance\n      ) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.distanceToEndOfCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n}\n","import Component from './Component';\nimport Entity from './Entity';\n\nexport default class SortOrderProvider extends Component {\n  constructor(\n    entity: Entity,\n    private getSortOrderFn: (entity: Entity) => number,\n  ) {\n    super(entity);\n  }\n\n  getSortOrder(): number {\n    return this.getSortOrderFn(this.entity);\n  }\n}\n","import SceneObject from './SceneObject';\nimport Component from './Component';\nimport { assert } from '../assert';\nimport SortOrderProvider from './SortOrderProvider';\nimport Scene from './Scene';\n\ntype ComponentClass<T extends Component, Args extends unknown[]> = {\n  name: string;\n  new (entity: Entity, ...args: Args): T;\n};\n\nexport default class Entity extends SceneObject {\n  private componentInstances = new Map<\n    ComponentClass<Component, any>,\n    Component\n  >();\n\n  addComponent<T extends Component, Args extends unknown[]>(\n    component: ComponentClass<T, Args>,\n    ...args: Args\n  ): T {\n    assert(\n      !this.componentInstances.has(component),\n      `component instance ${component.name} already exists`,\n    );\n    const instance = new component(this, ...args);\n    this.componentInstances.set(component, instance);\n    return instance;\n  }\n\n  hasComponent<T extends Component>(\n    component: ComponentClass<T, any[]>,\n  ): boolean {\n    return this.componentInstances.has(component);\n  }\n\n  getComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.componentInstances.get(component);\n    assert(instance, `no instance for ${component.name} exists`);\n    assert(instance instanceof component, 'wrong instance type');\n    return instance;\n  }\n\n  removeComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.getComponent(component);\n    this.componentInstances.delete(component);\n    instance.onRemove();\n    return instance;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeDraw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.draw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterDraw(ctx, elapsedTime);\n    }\n  }\n  update(delta: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeUpdate(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.update(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterUpdate(delta);\n    }\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    for (const component of this.componentInstances.values()) {\n      component.onAddedToScene(scene);\n    }\n  }\n\n  onRemovedFromScene() {\n    const scene = this.getScene();\n    super.onRemovedFromScene();\n    for (const component of this.componentInstances.values()) {\n      component.onRemovedFromScene(scene);\n    }\n  }\n\n  getSortOrder() {\n    if (this.hasComponent(SortOrderProvider)) {\n      return this.getComponent(SortOrderProvider).getSortOrder();\n    } else {\n      return super.getSortOrder();\n    }\n  }\n}\n","import { assert } from '../lib/assert';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { outBack, inBack } from '../lib/easings';\nimport { sample, constrain, mapRange, random } from '../lib/utils';\nimport TravellerFinder from './TravellerFinder';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Intersection from './networkNodes/Intersection';\nimport Road from './Road';\nimport Entity from '../lib/scene/Entity';\nimport { makeAbsolutePal } from '../pals/makePal';\nimport { PalAbsoluteController } from '../pals/PalController';\n\n// const TRAVELLER_COLOR = BLUE.fade(0.4);\n// const TRAVELLER_RADIUS = 14;\nconst MIN_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MAX_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MIN_TRAVELLER_SAFE_RADIUS = 30;\nconst MAX_TRAVELLER_SAFE_RADIUS = 30;\nconst NEARBY_RADIUS = 200;\n\nconst INITIAL_SPEED = 5;\nconst MAX_SPEED = 80;\nconst ACCELERATION = 200;\nconst DECELERATION = -200;\nconst ROAD_END_OVERSHOOT = 0;\n\nconst PATIENCE = 1500;\nconst FORCE_ACCELERATE_DURATION = 100;\n\nconst ENTER_DURATION = 400;\nconst EXIT_DURATION = 400;\n\nconst enterEase = outBack(3);\nconst exitEase = inBack(3);\n\nenum StopReason {\n  STOPPED_FOR_DESTINATION = 'STOPPED_FOR_DESTINATION',\n  STOPPED_FOR_TRAFFIC_IN_FRONT = 'STOPPED_FOR_TRAFFIC_IN_FRONT',\n  STOPPED_FOR_TRAFFIC_NEARBY = 'STOPPED_FOR_TRAFFIC_NEARBY',\n}\n\nexport default class Traveller extends SceneObject {\n  static MAX_SPEED = MAX_SPEED;\n  static StopReason = StopReason;\n\n  comfortableRadius = random(\n    MIN_TRAVELLER_COMFORTABLE_RADIUS,\n    MAX_TRAVELLER_COMFORTABLE_RADIUS,\n  );\n  safeRadius = random(MIN_TRAVELLER_SAFE_RADIUS, MAX_TRAVELLER_SAFE_RADIUS);\n  _currentRoad: Road | null = null;\n  _destination: NetworkNode | null = null;\n  _positionOnCurrentRoad: number = 0;\n  _speed: number = INITIAL_SPEED;\n  _age: number = 0;\n  _exitStartedAt: number | null = null;\n  _stoppedTime: number = 0;\n  _forceAccelerateTimer: number = 0;\n  _stopReason: StopReason | null = null;\n  _stoppedFor: Traveller[] = [];\n  _pal: Entity | null = null;\n\n  get currentRoad(): Road | null {\n    return this._currentRoad;\n  }\n\n  get position(): Vector2 {\n    assert(this._currentRoad, 'currentRoad must be defined');\n    return this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad);\n  }\n\n  // get predictedPositionInDirectionOfTravel(): Vector2 {\n  //   assert(this._currentRoad, 'currentRoad must be defined');\n  //   return this._getPredictedPointForPosition(\n  //     this._currentRoad,\n  //     this._positionOnCurrentRoad + 1,\n  //   );\n  // }\n\n  get predictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition);\n  }\n\n  get predictedStopArea(): Circle {\n    const center = this.predictedStopPoint;\n    return new Circle(center.x, center.y, this.safeRadius);\n  }\n\n  get potentialNextPredictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition + 1);\n  }\n\n  get positionOnCurrentRoad(): number {\n    return this._positionOnCurrentRoad;\n  }\n\n  get distanceToEndOfCurrentRoad(): number {\n    assert(this._currentRoad, 'traveller is not on a road');\n    return this._currentRoad.length - this._positionOnCurrentRoad;\n  }\n\n  get destination(): NetworkNode | null {\n    return this._destination;\n  }\n\n  get speed(): number {\n    return this._speed;\n  }\n\n  get isStopped(): boolean {\n    return this.speed === 0;\n  }\n\n  get stoppedTime(): number {\n    return this._stoppedTime;\n  }\n\n  get stopReason(): StopReason | null {\n    return this._stopReason;\n  }\n\n  isStoppedFor(other: Traveller): boolean {\n    return this._stoppedFor.includes(other);\n  }\n\n  onAddedToRoad(road: Road) {\n    this._currentRoad = road;\n    this._positionOnCurrentRoad = 0;\n    if (!this._destination) {\n      this._pickDestination();\n    }\n  }\n\n  onRemovedFromRoad() {\n    this.getScene()\n      .getSystem(TravellerFinder)\n      .removeTraveller(this);\n    this._currentRoad = null;\n  }\n\n  onRemovedFromScene() {\n    this.removeFromCurrentRoad();\n  }\n\n  removeFromCurrentRoad() {\n    if (this._currentRoad) this._currentRoad.removeTraveller(this);\n  }\n\n  update(dtMilliseconds: number) {\n    this._age += dtMilliseconds;\n    this._stopReason = null;\n    this._stoppedFor = [];\n\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._move(dtMilliseconds, currentRoad);\n\n    const pal = this._getPal();\n    pal\n      .getComponent(PalAbsoluteController)\n      .setPosition(\n        this.position,\n        currentRoad.getAngleAtPosition(this._positionOnCurrentRoad),\n        dtMilliseconds / 1000,\n      );\n    pal.update(dtMilliseconds);\n\n    this._getEnterTransitionScale();\n    // if (window.debugDraw) this._debugDraw();\n\n    this._checkAtEndOfRoad(currentRoad);\n    this._checkExit();\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number) {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._getPal().draw(ctx, elapsedTime);\n\n    // const position = this.position;\n    // const scale =\n    //   this._getEnterTransitionScale() * this._getExitTransitionScale();\n\n    // ctx.beginPath();\n    // ctx.fillStyle = TRAVELLER_COLOR.toString();\n    // ShapeHelpers.circle(ctx, position.x, position.y, TRAVELLER_RADIUS * scale);\n    // ctx.fill();\n  }\n\n  getSortOrder(): number {\n    return this.position.y;\n  }\n\n  get _isExiting(): boolean {\n    return this._exitStartedAt !== null;\n  }\n\n  _getPal(): Entity {\n    if (!this._pal) {\n      this._pal = makeAbsolutePal(this.position);\n    }\n\n    return this._pal;\n  }\n\n  // _debugDraw() {\n  //   const currentRoad = this._currentRoad;\n  //   if (!currentRoad) return;\n\n  //   const predictedStopPoint = this.predictedStopPoint;\n  //   new Circle(\n  //     this.position.x,\n  //     this.position.y,\n  //     this.comfortableRadius\n  //   ).debugDraw(\"rgba(0, 255, 0, 0.4)\");\n  //   new Circle(this.position.x, this.position.y, this.safeRadius).debugDraw(\n  //     this._forceAccelerateTimer ? \"cyan\" : \"red\"\n  //   );\n  //   predictedStopPoint.debugDraw(\"lime\");\n  //   this.predictedStopArea.debugDraw(\"rgba(255, 0, 255, 0.5)\");\n\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.fillText(\n  //     `${this.id} ${Math.round(this._stoppedTime)}`,\n  //     this.position.x,\n  //     this.position.y\n  //   );\n  // }\n\n  _getEnterTransitionScale() {\n    return enterEase(\n      constrain(0, 1, mapRange(0, ENTER_DURATION, 0, 1, this._age)),\n    );\n  }\n\n  _getExitTransitionScale() {\n    if (this._exitStartedAt === null) return 1;\n    return (\n      1 -\n      exitEase(\n        constrain(\n          0,\n          1,\n          mapRange(\n            this._exitStartedAt,\n            this._exitStartedAt + EXIT_DURATION,\n            0,\n            1,\n            this._age,\n          ),\n        ),\n      )\n    );\n  }\n\n  _getPredictedStopPositionIfDecelerating(): number {\n    const timeToStop = -this._speed / DECELERATION;\n    return (\n      this._positionOnCurrentRoad +\n      this._speed * timeToStop +\n      0.5 * DECELERATION * timeToStop * timeToStop\n    );\n  }\n\n  _getPredictedPointForPosition(currentRoad: Road, position: number): Vector2 {\n    if (position <= currentRoad.length) {\n      return currentRoad.getPointAtPosition(position);\n    }\n\n    const overshoot = position - currentRoad.length;\n    const overshootAngle = currentRoad.getAngleAtPosition(currentRoad.length);\n    return Vector2.fromPolar(overshootAngle, overshoot).add(currentRoad.end);\n  }\n\n  _pickDestination() {\n    if (!this._currentRoad) return;\n    const potentialDestinations = this._currentRoad\n      .getAllReachableNodes()\n      .filter(node => node.isDestination);\n    const destination = sample(potentialDestinations);\n    this._destination = destination;\n  }\n\n  _move(dtMilliseconds: number, currentRoad: Road) {\n    const dtSeconds = dtMilliseconds / 1000;\n\n    this._forceAccelerateTimer = constrain(\n      0,\n      FORCE_ACCELERATE_DURATION,\n      this._forceAccelerateTimer - dtMilliseconds,\n    );\n\n    if (\n      this._forceAccelerateTimer <= 0 &&\n      this._shouldDecelerate(currentRoad)\n    ) {\n      this._accelerate(DECELERATION, dtSeconds, currentRoad);\n    } else {\n      this._accelerate(ACCELERATION, dtSeconds, currentRoad);\n    }\n\n    if (this._speed === 0) {\n      this._stoppedTime += dtMilliseconds;\n    } else {\n      this._stoppedTime = 0;\n    }\n  }\n\n  _shouldDecelerate(currentRoad: Road): boolean {\n    const predictedStopPosition = this._getPredictedStopPositionIfDecelerating();\n    if (\n      currentRoad.to === this._destination &&\n      currentRoad.length + ROAD_END_OVERSHOOT < predictedStopPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_DESTINATION;\n      return true;\n    }\n\n    const nextTravellerOnRoad = currentRoad.getTravellerAfterPosition(\n      this._positionOnCurrentRoad,\n    );\n\n    const safeStopAheadPosition =\n      predictedStopPosition + this.comfortableRadius;\n\n    if (\n      nextTravellerOnRoad &&\n      nextTravellerOnRoad.positionOnCurrentRoad < safeStopAheadPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n      this._stoppedFor.push(nextTravellerOnRoad);\n      return true;\n    }\n\n    if (currentRoad.to instanceof Intersection) {\n      const intersection = currentRoad.to;\n      const outgoingTraveller = intersection.getClosestOutgoingTraveller();\n      if (outgoingTraveller) {\n        const outgoingTravellerPosition =\n          currentRoad.length + outgoingTraveller.positionOnCurrentRoad;\n\n        if (outgoingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(outgoingTraveller);\n          return true;\n        }\n      }\n\n      const incomingTraveller = intersection.getClosestIncomingTraveller();\n      if (incomingTraveller && incomingTraveller !== this) {\n        const incomingTravellerPosition =\n          currentRoad.length - incomingTraveller.distanceToEndOfCurrentRoad;\n        if (incomingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(incomingTraveller);\n          return true;\n        }\n      }\n    }\n\n    if (this._shouldDecelerateForNearbyTravellers(currentRoad)) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_NEARBY;\n      return true;\n    }\n\n    // const currentPoint = this.position;\n    // const currentSafeCircle = new Circle(\n    //   currentPoint.x,\n    //   currentPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     currentSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    // const predictedStopPoint = this._getPredictedStopPointIfDecelerating(\n    //   currentRoad,\n    // );\n    // const predictedSafeCircle = new Circle(\n    //   predictedStopPoint.x,\n    //   predictedStopPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     predictedSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    return false;\n  }\n\n  _shouldDecelerateForNearbyTravellers(currentRoad: Road): boolean {\n    const travellerFinder = this.getScene().getSystem(TravellerFinder);\n    const stopArea = this.predictedStopArea;\n    const stopPoint = stopArea.center;\n    const nextStopPoint = this.potentialNextPredictedStopPoint;\n    const searchArea = stopArea.withRadius(NEARBY_RADIUS);\n    const nearbyTravellers = travellerFinder.findTravellersInCircle(searchArea);\n\n    for (const other of nearbyTravellers) {\n      // cannot crash into self\n      if (other === this) continue;\n\n      // if we both started breaking now, we would be a safe distance so we're fine\n      const otherStopArea = other.predictedStopArea;\n      const otherStopPoint = otherStopArea.center;\n      if (!stopArea.intersectsCircle(otherStopArea)) continue;\n\n      // currently we think other will stop at the center of otherStopArea.\n      // otherNextStopPoint is one pixel further forward based other's current\n      // heading\n      const otherNextStopPoint = other.potentialNextPredictedStopPoint;\n\n      // if we're moving away from each other, everything is fine:\n      const currentStopDistance = stopPoint.distanceTo(otherStopArea.center);\n      const nextStopDistance = nextStopPoint.distanceTo(otherNextStopPoint);\n      if (nextStopDistance > currentStopDistance) continue;\n\n      // who is moving in a direction that's headed more towards the other's\n      // stop position? if they're moving towards me but i'm moving more\n      // orthagonally relative to them, they should slow down\n      const approachAmount = stopPoint.distanceTo(otherNextStopPoint);\n      const otherApproachAmount = otherStopPoint.distanceTo(nextStopPoint);\n      if (approachAmount < otherApproachAmount) {\n        continue;\n      }\n\n      // so we know we're moving towards them faster than they're moving\n      // towards us, but how much? If it's barely any and we're not already too\n      // close to them, we could just keep going\n      if (\n        approachAmount - otherApproachAmount <\n        0.15\n        // approachAmount > this.safeRadius * 0.8\n      ) {\n        continue;\n      }\n\n      // if there's a clash... just randomly tie-break\n      if (approachAmount === otherApproachAmount) {\n        return Math.random() < 0.5;\n      }\n\n      // if we've been waiting around for fuckin ever just slam that fuckin\n      // pedal to the floor like ugh (in reality just nudge forward a little)\n      // (unless the other one is stopped to cus otherwise we'll just crash)\n      if (this._stoppedTime > PATIENCE && !other.isStopped) {\n        this._forceAcceleration();\n        return false;\n      }\n\n      // attempt to break deadlocks. i guess this is the equivalent of 'other'\n      // waving at the current traveller to continue\n      if (other.isStoppedFor(this)) continue;\n\n      this._stoppedFor.push(other);\n    }\n\n    if (this._stoppedFor.length) return true;\n\n    return false;\n  }\n\n  // _shouldDecelerateForTravellersInCircle(currentRoad: Road, circle: Circle) {\n  //   const travellerFinder = this.getScene().getSystem(TravellerFinder);\n  //   const overlappingTravellers = travellerFinder.findTravellersInCircle(\n  //     circle,\n  //   );\n\n  //   const currentPosition = this.position;\n  //   const nextPosition = this.predictedPositionInDirectionOfTravel;\n\n  //   const clashingTravellers = overlappingTravellers.filter(other => {\n  //     if (other === this) return false;\n  //     if (other.currentRoad === currentRoad) return false;\n\n  // const currentDistance = currentPosition.distanceTo(other.position);\n  // const nextDistance = nextPosition.distanceTo(other.position);\n\n  // const isGettingCloser = nextDistance < currentDistance;\n  // if (!isGettingCloser) return false;\n\n  // const otherNextPosition = other.predictedPositionInDirectionOfTravel;\n  // const otherNextDistance = currentPosition.distanceTo(otherNextPosition);\n  // const thisMoveDelta = nextDistance - currentDistance;\n  // const otherMoveDelta = otherNextDistance - currentDistance;\n  // if (thisMoveDelta < otherMoveDelta) return true;\n\n  // if (this.isStopped && !other.isStopped) return true;\n\n  // if (this.isStopped && other.isStopped) {\n  //   if (this.stoppedTime === other.stoppedTime && this.id < other.id)\n  //     return false;\n  //   if (this.stoppedTime < other.stoppedTime) return false;\n  // }\n\n  //     return true;\n  //   });\n\n  //   return clashingTravellers.length > 0;\n  // }\n\n  _forceAcceleration() {\n    this._forceAccelerateTimer = FORCE_ACCELERATE_DURATION;\n  }\n\n  _accelerate(acceleration: number, dtSeconds: number, currentRoad: Road) {\n    const lastSpeed = this._speed;\n    this._speed = constrain(\n      0,\n      MAX_SPEED,\n      this._speed + acceleration * dtSeconds,\n    );\n    const avgSpeed = (lastSpeed + this._speed) / 2;\n    this._positionOnCurrentRoad = constrain(\n      0,\n      currentRoad.length,\n      this._positionOnCurrentRoad + avgSpeed * dtSeconds,\n    );\n  }\n\n  _checkAtEndOfRoad(currentRoad: Road) {\n    if (this._positionOnCurrentRoad === currentRoad.length) {\n      if (this._isExiting) return;\n      this._onReachEndOfCurrentRoad(currentRoad);\n    }\n  }\n\n  _checkExit() {\n    if (this._isExiting) {\n      assert(this._exitStartedAt);\n      if (this._age >= this._exitStartedAt + EXIT_DURATION) {\n        this._onExit();\n      }\n    }\n  }\n\n  _onReachEndOfCurrentRoad(currentRoad: Road) {\n    const nextNode = currentRoad.to;\n    const destination = this._destination;\n    if (nextNode.canConsumeTraveller) {\n      nextNode.consumeTraveller(this);\n      if (nextNode === destination) {\n        this._onReachDestination();\n      }\n    }\n  }\n\n  _onReachDestination() {\n    this._exit();\n  }\n\n  _onExit() {\n    this.getScene().removeChild(this);\n  }\n\n  _exit() {\n    this._exitStartedAt = this._age;\n  }\n}\n","import Entity from '../lib/scene/Entity';\nimport { PalTargetController, PalAbsoluteController } from './PalController';\nimport Vector2 from '../lib/geom/Vector2';\nimport { generateRandomPalConfig } from './PalConfig';\nimport PalGeom from './PalGeom';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport PalRenderer from './PalRenderer';\n\nexport function makeTargetPal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalTargetController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n\nexport function makeAbsolutePal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalAbsoluteController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n","// @flow\nimport { assert } from '../assert';\nimport { constrain, compact } from '../utils';\nimport Circle from './Circle';\nimport Vector2 from './Vector2';\nimport StraightPathSegment from './StraightPathSegment';\nimport CirclePathSegment from './CirclePathSegment';\nimport Line2 from './Line2';\n\nexport interface PathSegment {\n  getStart(): Vector2;\n  getEnd(): Vector2;\n  getLength(): number;\n  getPointAtPosition(position: number): Vector2;\n  getAngleAtPosition(position: number): number;\n}\n\nexport default class Path implements PathSegment {\n  static straightThroughPoints(...points: ReadonlyArray<Vector2>): Path {\n    let [lastPoint, ...remainingPoints] = points;\n    const path = new Path();\n\n    for (const point of remainingPoints) {\n      path.addSegment(new StraightPathSegment(lastPoint, point));\n      lastPoint = point;\n    }\n\n    return path;\n  }\n\n  static segmentAcrossCircle(\n    containingCircle: Circle,\n    entryAngle: number,\n    exitAngle: number,\n  ): CirclePathSegment | StraightPathSegment {\n    entryAngle = entryAngle + Math.PI;\n    const entryPoint = containingCircle.pointOnCircumference(entryAngle);\n    const exitPoint = containingCircle.pointOnCircumference(exitAngle);\n\n    const entryLineNormal = new Line2(\n      containingCircle.center,\n      entryPoint,\n    ).perpendicularLineThroughPoint(entryPoint);\n    const exitLineNormal = new Line2(\n      containingCircle.center,\n      exitPoint,\n    ).perpendicularLineThroughPoint(exitPoint);\n\n    if (entryLineNormal.isParallelTo(exitLineNormal)) {\n      return new StraightPathSegment(entryPoint, exitPoint);\n    }\n\n    const roadCircleCenter = entryLineNormal.pointAtIntersectionWith(\n      exitLineNormal,\n    );\n    const roadCircleRadius = entryPoint.distanceTo(roadCircleCenter);\n\n    // containingCircle.center.debugDraw('lime');\n    // roadCircleCenter.debugDraw('blue');\n    // entryPoint.debugDraw('magenta');\n    // exitPoint.debugDraw('red');\n\n    return new CirclePathSegment(\n      roadCircleCenter,\n      roadCircleRadius,\n      entryPoint.sub(roadCircleCenter).angle,\n      exitPoint.sub(roadCircleCenter).angle,\n    );\n  }\n\n  segments: PathSegment[] = [];\n\n  constructor(...segments: PathSegment[]) {\n    this.addSegments(...segments);\n  }\n\n  getStart(): Vector2 {\n    return this.segments[0].getStart();\n  }\n\n  getEnd(): Vector2 {\n    return this.segments[this.segments.length - 1].getEnd();\n  }\n\n  getLength(): number {\n    return this.segments.reduce(\n      (length, segment) => length + segment.getLength(),\n      0,\n    );\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getPointAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  getAngleAtPosition(position: number): number {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getAngleAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  addSegment(segment: PathSegment): this {\n    const lastSegment = this.segments[this.segments.length - 1];\n    if (lastSegment) {\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        `segments must neatly join together - ${lastSegment\n          .getEnd()\n          .toString()} !== ${segment.getStart().toString()}`,\n      );\n    }\n    this.segments.push(segment);\n    return this;\n  }\n\n  addSegments(...segments: PathSegment[]): this {\n    segments.forEach(segment => this.addSegment(segment));\n    return this;\n  }\n\n  autoRound(radius: number): this {\n    const newSegments = this.segments.map((segment, i): PathSegment | null => {\n      const lastSegment = i === 0 ? null : this.segments[i - 1];\n      if (!lastSegment) {\n        if (segment instanceof StraightPathSegment) return null;\n        return segment;\n      }\n\n      if (!(segment instanceof StraightPathSegment)) return segment;\n      if (!(lastSegment instanceof StraightPathSegment)) return null;\n\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        'segments must join',\n      );\n\n      const entryAngle = lastSegment.angle;\n      const exitAngle = segment.angle;\n      const usableRadius = Math.min(\n        radius,\n        lastSegment.getLength() / 2,\n        segment.getLength() / 2,\n      );\n\n      const containingCircle = new Circle(\n        segment.getStart().x,\n        segment.getStart().y,\n        usableRadius,\n      );\n\n      return Path.segmentAcrossCircle(containingCircle, entryAngle, exitAngle);\n    });\n\n    const compacted = compact(newSegments);\n\n    const start = this.getStart();\n    const end = this.getEnd();\n    let lastPoint = start;\n    this.segments = [];\n\n    compacted.forEach(segment => {\n      if (segment.getStart().equals(lastPoint)) {\n        this.addSegment(segment);\n      } else {\n        this.addSegment(new StraightPathSegment(lastPoint, segment.getStart()));\n        this.addSegment(segment);\n      }\n\n      lastPoint = segment.getEnd();\n    });\n\n    if (!lastPoint.equals(end)) {\n      this.addSegment(new StraightPathSegment(lastPoint, end));\n    }\n\n    return this;\n  }\n}\n","// @flow\nimport { compact } from '../lib/utils';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Scene from '../lib/scene/Scene';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\nimport Path from '../lib/geom/Path';\nimport Road from './Road';\nimport Intersection from './networkNodes/Intersection';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class Junction extends SceneObject {\n  _circle: Circle;\n  _intersectionsByAngle: { [angleString: string]: Intersection } = {};\n  _incomingIntersections: Set<Intersection> = new Set();\n  _outgoingIntersections: Set<Intersection> = new Set();\n  _roads: Road[] = [];\n\n  constructor(x: number, y: number, radius: number) {\n    super();\n    this._circle = new Circle(x, y, radius);\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    this._roads.forEach(road => scene.addChild(road));\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._circle.pointOnCircumference(radians);\n  }\n\n  connectToRoadAtAngle(\n    road: Road,\n    angle: number,\n    direction: ConnectionDirection,\n  ): Intersection {\n    const intersection = this._intersectionAtAngle(angle);\n    intersection.connectTo(road, direction);\n\n    const isIncoming =\n      direction === ConnectionDirection.IN ||\n      this._incomingIntersections.has(intersection);\n\n    const isOutgoing =\n      direction === ConnectionDirection.OUT ||\n      this._outgoingIntersections.has(intersection);\n\n    if (isIncoming) this._incomingIntersections.add(intersection);\n    if (isOutgoing) this._outgoingIntersections.add(intersection);\n\n    this._intersections.forEach(other => {\n      if (other === intersection) return;\n\n      if (isIncoming && this._outgoingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(intersection.position).angle,\n            other.position.sub(this._circle.center).angle,\n          ),\n        );\n\n        this._addRoad(new Road(intersection, other, { path }));\n      }\n\n      if (isOutgoing && this._incomingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(other.position).angle,\n            intersection.position.sub(this._circle.center).angle,\n          ),\n        );\n        this._addRoad(new Road(other, intersection, { path }));\n      }\n    });\n\n    return intersection;\n  }\n\n  _intersectionAtAngle(angle: number): Intersection {\n    const angleStr = angle.toString();\n    if (this._intersectionsByAngle[angleStr]) {\n      return this._intersectionsByAngle[angleStr];\n    }\n\n    const intersection = this._createIntersectionAtAngle(angle);\n    this._intersectionsByAngle[angleStr] = intersection;\n    return intersection;\n  }\n\n  _createIntersectionAtAngle(angle: number): Intersection {\n    const position = this.getVisualConnectionPointAtAngle(angle);\n    return new Intersection(position.x, position.y);\n  }\n\n  get _intersections(): Intersection[] {\n    return compact(\n      Object.keys(this._intersectionsByAngle).map(\n        angle => this._intersectionsByAngle[angle],\n      ),\n    );\n  }\n\n  _addRoad(road: Road) {\n    this._roads.push(road);\n    if (this.hasScene()) {\n      this.getScene().addChild(road);\n    }\n  }\n}\n","// @flow\nimport SceneObject from '../lib/scene/SceneObject';\nimport Path from '../lib/geom/Path';\nimport StraightPathSegment from '../lib/geom/StraightPathSegment';\nimport Vector2 from '../lib/geom/Vector2';\nimport * as ShapeHelpers from '../lib/canvasShapeHelpers';\nimport { YELLOW } from './colors';\nimport ConnectionDirection from './ConnectionDirection';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Junction from './Junction';\nimport Traveller from './Traveller';\n\n// const ROAD_OUTER_COLOR = BLUE;\n// const ROAD_INNER_COLOR = LIGHT_BG;\nconst ROAD_DASH_COLOR = YELLOW.darken(0.2);\n// const ROAD_OUTER_WIDTH = 12;\n// const ROAD_INNER_WIDTH = 13;\nconst ROAD_DASH_WIDTH = 3;\nconst ROAD_IDEAL_DASH = [5, 10];\nconst ROAD_IDEAL_DASH_LENGTH = ROAD_IDEAL_DASH.reduce((a, b) => a + b, 0);\nconst ROAD_DASH_SPEED = 0.05;\n\nexport type RoadOptions = {\n  autoRound?: number;\n  points?: Array<Vector2>;\n  path?: Path;\n};\n\nexport default class Road extends SceneObject {\n  isNode = false;\n  from: NetworkNode;\n  to: NetworkNode;\n  _path: Path;\n  _currentTravellers: Traveller[] = [];\n\n  constructor(\n    from: NetworkNode | Junction,\n    to: NetworkNode | Junction,\n    { points, autoRound, path }: RoadOptions = {},\n  ) {\n    super();\n\n    const angleFrom = points\n      ? from.position.angleTo(points[0])\n      : from.position.angleTo(to.position);\n\n    const angleTo = points\n      ? to.position.angleTo(points[points.length - 1])\n      : to.position.angleTo(from.position);\n\n    if (path) {\n      this._path = path;\n    } else if (points) {\n      this._path = Path.straightThroughPoints(\n        from.getVisualConnectionPointAtAngle(angleFrom),\n        ...points,\n        to.getVisualConnectionPointAtAngle(angleTo),\n      );\n    } else {\n      this._path = new Path().addSegment(\n        new StraightPathSegment(\n          from.getVisualConnectionPointAtAngle(angleFrom),\n          to.getVisualConnectionPointAtAngle(angleTo),\n        ),\n      );\n    }\n\n    if (autoRound != null) {\n      this._path.autoRound(autoRound);\n    }\n\n    if (from instanceof Junction) {\n      this.from = from.connectToRoadAtAngle(\n        this,\n        angleFrom,\n        ConnectionDirection.OUT,\n      );\n    } else {\n      this.from = from;\n      from.connectTo(this, ConnectionDirection.OUT);\n    }\n\n    if (to instanceof Junction) {\n      this.to = to.connectToRoadAtAngle(this, angleTo, ConnectionDirection.IN);\n    } else {\n      this.to = to;\n      to.connectTo(this, ConnectionDirection.IN);\n    }\n  }\n\n  get length(): number {\n    return this._path.getLength();\n  }\n\n  get start(): Vector2 {\n    return this._path.getStart();\n  }\n\n  get end(): Vector2 {\n    return this._path.getEnd();\n  }\n\n  get expectedTimeFromStartToEnd(): number {\n    if (this._currentTravellers.length) {\n      const avgSpeed =\n        this._currentTravellers.reduce(\n          (sum, traveller) => sum + traveller.speed,\n          0,\n        ) / this._currentTravellers.length;\n      return this.length / avgSpeed;\n    }\n\n    return this.length / (Traveller.MAX_SPEED * 0.7);\n  }\n\n  canAddTravellerAtStart(): boolean {\n    const nextTraveller = this.getTravellerAfterPosition(0);\n    if (!nextTraveller) return true;\n    return (\n      nextTraveller.positionOnCurrentRoad > nextTraveller.comfortableRadius\n    );\n  }\n\n  addTravellerAtStart(traveller: Traveller) {\n    this._currentTravellers.push(traveller);\n    traveller.onAddedToRoad(this);\n  }\n\n  removeTraveller(traveller: Traveller): boolean {\n    const index = this._currentTravellers.indexOf(traveller);\n    if (index === -1) return false;\n    this.removeTravellerAtIndex(index);\n    return true;\n  }\n\n  removeTravellerAtIndex(index: number): Traveller {\n    const traveller = this._currentTravellers[index];\n    this._currentTravellers.splice(index, 1);\n    traveller.onRemovedFromRoad();\n    return traveller;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    const nodes = [] as Array<NetworkNode>;\n    if (visited.has(this.to)) return nodes;\n    return [...this.to.getAllReachableNodes(visited), this.to];\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    return this._path.getPointAtPosition(position);\n  }\n\n  getAngleAtPosition(position: number): number {\n    return this._path.getAngleAtPosition(position);\n  }\n\n  getTravellerAfterPosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = traveller.positionOnCurrentRoad - position;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getTravellerBeforePosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = position - traveller.positionOnCurrentRoad;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, time: number) {\n    ctx.beginPath();\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ShapeHelpers.path(ctx, this._path);\n\n    // ctx.strokeStyle = ROAD_OUTER_COLOR.toString();\n    // ctx.lineWidth = ROAD_OUTER_WIDTH;\n    // ctx.stroke();\n\n    // ctx.strokeStyle = ROAD_INNER_COLOR.toString();\n    // ctx.lineWidth = ROAD_INNER_WIDTH;\n    // ctx.stroke();\n\n    const dashScale = this._getLineDashScale();\n    const dashLength = ROAD_IDEAL_DASH_LENGTH * dashScale;\n    ctx.setLineDash(ROAD_IDEAL_DASH.map(length => length * dashScale));\n    ctx.strokeStyle = ROAD_DASH_COLOR.toString();\n    ctx.lineDashOffset = (-time * ROAD_DASH_SPEED * dashScale) % dashLength;\n    ctx.lineWidth = ROAD_DASH_WIDTH;\n    // ctx.strokeStyle = 'black';\n    // ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  _getLineDashScale(): number {\n    const wholeDashCount = Math.floor(this.length / ROAD_IDEAL_DASH_LENGTH);\n    const wholeDashLength = wholeDashCount * ROAD_IDEAL_DASH_LENGTH;\n\n    const roundDownLength = this.length - wholeDashLength;\n    const roundUpLength =\n      wholeDashLength + ROAD_IDEAL_DASH_LENGTH - this.length;\n\n    const dashScale =\n      roundDownLength < roundUpLength\n        ? this.length / wholeDashLength\n        : this.length / (wholeDashLength + ROAD_IDEAL_DASH_LENGTH);\n\n    return dashScale;\n  }\n}\n","// @flow\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { outSine } from '../../lib/easings';\nimport { mapRange, constrain, flatten, uniq } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { TEAL } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Traveller from '../Traveller';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 500;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst CLOCK_RADIUS = RADIUS * 0.7;\nconst PULSE_RADIUS = 35;\n\nconst PULSE_DURATION = 500;\nconst CLOCK_FADE_DURATION = 150;\n\nconst MAIN_COLOR = TEAL.lighten(0.1);\nconst CLOCK_COLOR = TEAL.darken(0.1);\nconst PULSE_COLOR = TEAL.lighten(0.2).fade(0.1);\n\nexport default class Producer extends SceneObject implements NetworkNode {\n  isDestination = false;\n  canConsumeTraveller = false;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = new Circle(x, y, RADIUS);\n    this._visualConnectionCircle = new Circle(x, y, VISUAL_CONNECTION_RADIUS);\n    this._cooldown = cooldown;\n    this._timer = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()) {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  consumeTraveller() {\n    throw new Error('producer cannot consume traveller');\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n    if (this._timer >= this._cooldown) {\n      this._onTimerEnd();\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ctx.arc(\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n      -Math.PI / 2,\n      progress * 2 * Math.PI - Math.PI / 2,\n      false,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = MAIN_COLOR.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      CLOCK_RADIUS,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _onTimerEnd() {\n    const didEmitTraveller = this._attemptEmitTraveller();\n    if (didEmitTraveller) {\n      this._pulse();\n      this._resetTimer();\n    }\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        startRadius: RADIUS,\n        endRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: outSine,\n        removeOnComplete: true,\n      }),\n    );\n  }\n\n  _attemptEmitTraveller(): boolean {\n    const road = this._connectionSet.sampleOutgoing();\n    if (!(road instanceof Road)) return false;\n\n    if (road.canAddTravellerAtStart()) {\n      const traveller = new Traveller();\n      road.addTravellerAtStart(traveller);\n      this.getScene().addChild(traveller);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Scene from '../lib/scene/Scene';\nimport Consumer from './networkNodes/Consumer';\nimport Producer from './networkNodes/Producer';\nimport Road from './Road';\nimport Junction from './Junction';\n// import DebugOverlay from \"./systems/DebugOverlay\";\nimport TravellerFinder from './TravellerFinder';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst ROUND = 50;\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nconst root = document.getElementById('root');\nassert(root, '#root must be present');\nscene.appendTo(root);\n\n// scene.addSystem(new DebugOverlay());\nscene.addSystem(new TravellerFinder());\n\nscenario3();\n\nscene.start();\n\nfunction scenario1() {\n  const producer1 = new Producer(100, 100, 500);\n  // const producer2 = new Consumer(100, 300, 2500);\n  const consumer1 = new Consumer(400, 200, 1500);\n  const consumer2 = new Consumer(250, 200, 1500);\n  scene.addChild(producer1);\n  // scene.addChild(producer2);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n\n  const junction1 = new Junction(250, 100, ROUND);\n  scene.addChild(junction1);\n  scene.addChild(new Road(producer1, junction1));\n  scene.addChild(\n    new Road(junction1, consumer1, {\n      points: [new Vector2(400, 100)],\n      autoRound: ROUND,\n    }),\n  );\n  scene.addChild(new Road(junction1, consumer2));\n\n  // const path2 = new Path();\n  // path2.addSegments(\n  //   new StraightPathSegment(new Vector2(130, 300), new Vector2(380, 300)),\n  //   new CirclePathSegment(new Vector2(380, 280), 20, Math.PI * 0.5, 0),\n  //   new StraightPathSegment(new Vector2(400, 280), new Vector2(400, 230)),\n  // );\n  // const road2 = new Road(producer2, consumer1, path2);\n  // scene.addChild(road2);\n}\n\nfunction scenario2() {\n  const producer = new Producer(100, 300, 500);\n  const junction = new Junction(300, 300, ROUND);\n  const consumer1 = new Consumer(300, 100, 5000);\n  const consumer2 = new Consumer(500, 300, 5000);\n  const consumer3 = new Consumer(300, 500, 5000);\n\n  scene.addChild(new Road(producer, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  scene.addChild(producer);\n  scene.addChild(junction);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n}\n\nfunction scenario3() {\n  const northConsumer = new Consumer(300, 550, 1500);\n  const middleConsumer = new Consumer(100, 450, 1500);\n  const southConsumer = new Consumer(100, 250, 1500);\n  const eastProducer = new Producer(600, 150, 500);\n  const westProducer = new Producer(100, 100, 500);\n  // const westProducer = new Producer(250, 250, 100);\n\n  scene.addChild(northConsumer);\n  scene.addChild(middleConsumer);\n  scene.addChild(southConsumer);\n  scene.addChild(eastProducer);\n  scene.addChild(westProducer);\n\n  const mainJunction = new Junction(300, 150, ROUND);\n  const eastProducerSplit = new Junction(500, 370, ROUND);\n  const southConsumerJoin = new Junction(330, 400, ROUND);\n  scene.addChild(mainJunction);\n  scene.addChild(eastProducerSplit);\n  scene.addChild(southConsumerJoin);\n  scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(eastProducer, eastProducerSplit));\n  scene.addChild(new Road(eastProducerSplit, southConsumerJoin));\n  // scene.addChild(\n  //   new Road(eastProducerSplit, mainJunction, {\n  //     points: [[600, 280], [700, 50], [450, 180], [450, 100], [300, 20]],\n  //     // points: [[400, 100]],\n  //     autoRound: 50,\n  //   }),\n  // );\n  scene.addChild(\n    new Road(eastProducerSplit, mainJunction, {\n      points: [new Vector2(400, 300), new Vector2(500, 50)],\n      autoRound: ROUND,\n    }),\n  );\n\n  // scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(mainJunction, southConsumerJoin));\n  scene.addChild(new Road(southConsumerJoin, northConsumer));\n  scene.addChild(new Road(mainJunction, middleConsumer));\n  scene.addChild(new Road(mainJunction, southConsumer));\n}\n\nfunction scenario4() {\n  const producer1 = new Producer(100, 100, 1000);\n  const producer2 = new Producer(300, 200, 1000);\n  const producer3 = new Producer(100, 300, 1000);\n  // const producer4 = new Producer(400, 100, 1000);\n  const consumer1 = new Consumer(300, 100, 1000);\n  const consumer2 = new Consumer(100, 200, 1000);\n  const consumer3 = new Consumer(300, 300, 1000);\n  // const consumer4 = new Consumer(430, 300, 1000);\n  scene.addChild(producer1);\n  scene.addChild(producer2);\n  scene.addChild(producer3);\n  // scene.addChild(producer4);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n  // scene.addChild(consumer4);\n\n  const junction = new Junction(200, 200, 30);\n  scene.addChild(junction);\n\n  scene.addChild(new Road(producer1, junction));\n  scene.addChild(new Road(producer2, junction));\n  scene.addChild(new Road(producer3, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  // scene.addChild(\n  //   new Road(producer4, consumer4, {\n  //     points: [[400, 250], [415, 250], [415, 150], [430, 150]],\n  //     autoRound: 30,\n  //   }),\n  // );\n}\n\nfunction scenario6() {\n  const producer = new Producer(300, 50, 1500).addTo(scene);\n  const consumer = new Consumer(500, 50, 100).addTo(scene);\n  new Road(producer, consumer, {\n    points: [\n      new Vector2(350, 150),\n      new Vector2(150, 350),\n      new Vector2(400, 500),\n      new Vector2(650, 350),\n      new Vector2(450, 150),\n    ],\n    autoRound: 400,\n  }).addTo(scene);\n}\n","import { assert } from '../assert';\nimport SceneObject from './SceneObject';\nimport SceneSystem from './SceneSystem';\n\nconst speed = 1;\nconst scale = 1;\nconst repeatUpdate = 1;\n\ntype SystemClass<T extends SceneSystem = SceneSystem> = {\n  systemName: string;\n  new (): T;\n};\n\nexport default class Scene {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  private _scaleFactor: number;\n  private _children: SceneObject[] = [];\n  private _isPlaying: boolean = false;\n  private frameHandle: number | null = null;\n  private lastElapsedTime: number | null = null;\n  private systemsByClass = new Map<SystemClass<SceneSystem>, SceneSystem>();\n\n  constructor(width: number, height: number, scaleFactor: number = 1) {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = width * scaleFactor;\n    this.canvas.height = height * scaleFactor;\n    this.canvas.style.width = `${width}px`;\n    this.canvas.style.height = `${height}px`;\n    const ctx = this.canvas.getContext('2d');\n    assert(ctx, 'ctx');\n    this.ctx = ctx;\n    this._scaleFactor = scaleFactor * scale;\n\n    this._setupVisiblityChange();\n  }\n\n  get width(): number {\n    return this.canvas.width / this._scaleFactor;\n  }\n\n  get height(): number {\n    return this.canvas.height / this._scaleFactor;\n  }\n\n  get scaleFactor(): number {\n    return this._scaleFactor;\n  }\n\n  get isPlaying(): boolean {\n    return this.frameHandle !== null && this._isPlaying;\n  }\n\n  set isPlaying(newValue: boolean) {\n    assert(\n      this.frameHandle !== null,\n      'cannot set isPlaying without calling start',\n    );\n    this._isPlaying = newValue;\n  }\n\n  get children(): SceneObject[] {\n    return this._children;\n  }\n\n  appendTo(element: HTMLElement) {\n    element.appendChild(this.canvas);\n  }\n\n  hasSystem(systemType: SystemClass): boolean {\n    return this.systemsByClass.has(systemType);\n  }\n\n  getSystem<T extends SceneSystem>(systemType: SystemClass<T>): T {\n    const system = this.systemsByClass.get(systemType);\n    assert(system, `system, ${systemType.systemName} not found`);\n    assert(system instanceof systemType, 'system is wrong instance type');\n    return system;\n  }\n\n  addSystem(system: SceneSystem) {\n    assert(\n      !this.hasSystem(system.constructor as any),\n      'only one system of each type allowed',\n    );\n    this.systemsByClass.set(system.constructor as any, system);\n    system.afterAddToScene(this);\n  }\n\n  removeSystem(systemType: SystemClass) {\n    const system = this.getSystem(systemType);\n    system.beforeRemoveFromScene(this);\n    this.systemsByClass.delete(systemType);\n  }\n\n  addChild(child: SceneObject) {\n    this._children.push(child);\n    child.onAddedToScene(this);\n  }\n\n  addChildBefore(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index, newChild);\n  }\n\n  addChildAfter(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index + 1, newChild);\n  }\n\n  addChildAtIndex(index: number, child: SceneObject) {\n    this._children.splice(index, 0, child);\n    child.onAddedToScene(this);\n  }\n\n  removeChild(child: SceneObject): boolean {\n    const index = this._children.indexOf(child);\n    if (index === -1) return false;\n\n    this.removeChildAtIndex(index);\n    return true;\n  }\n\n  removeChildAtIndex(index: number): SceneObject {\n    const child = this._children[index];\n    this._children.splice(index, 1);\n    child.onRemovedFromScene();\n    return child;\n  }\n\n  update(delta: number) {\n    for (let i = 0; i < repeatUpdate; i++) {\n      for (const system of this.systemsByClass.values()) {\n        system.beforeUpdate(delta);\n      }\n      this._children.forEach((child) => child.update(delta));\n      for (const system of this.systemsByClass.values()) {\n        system.afterUpdate(delta);\n      }\n    }\n  }\n\n  draw(elapsedTime: number) {\n    this.ctx.save();\n    this.ctx.scale(this._scaleFactor, this._scaleFactor);\n    this.ctx.clearRect(0, 0, this.width, this.height);\n\n    for (const system of this.systemsByClass.values()) {\n      system.beforeDraw(this.ctx, elapsedTime);\n    }\n    this._children\n      .sort((a, b) => a.getSortOrder() - b.getSortOrder())\n      .forEach((child) => child.draw(this.ctx, elapsedTime));\n    for (const system of this.systemsByClass.values()) {\n      system.afterDraw(this.ctx, elapsedTime);\n    }\n\n    this.ctx.restore();\n  }\n\n  start() {\n    this._isPlaying = true;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  }\n\n  stop() {\n    if (this.frameHandle !== null) {\n      window.cancelAnimationFrame(this.frameHandle);\n      this.frameHandle = null;\n    }\n    this._isPlaying = false;\n    this.lastElapsedTime = null;\n  }\n\n  _tick = (elapsedTime: number) => {\n    elapsedTime = elapsedTime * speed;\n    const lastElapsedTime = this.lastElapsedTime;\n    if (lastElapsedTime !== null) {\n      const deltaTime = elapsedTime - lastElapsedTime;\n      if (this.isPlaying) {\n        this.update(deltaTime);\n        this.draw(elapsedTime);\n      }\n    }\n\n    this.lastElapsedTime = elapsedTime;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  };\n\n  _setupVisiblityChange() {\n    let playOnVisible = false;\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.isPlaying) {\n        playOnVisible = true;\n        this.stop();\n      }\n      if (playOnVisible && !document.hidden) {\n        playOnVisible = false;\n        this.start();\n      }\n    });\n  }\n}\n"],"names":["$0590d9fc1b9817be$var$constructorIdCounts","$0590d9fc1b9817be$export$2e2bcd8739ae039","hasScene","this","scene","getScene","$87DYR","assert","draw","ctx","elapsedTime","update","delta","addTo","addChild","onAddedToScene","scene1","onRemovedFromScene","getSortOrder","name","id","constructor","$b2475cb40559fc2b$var$UnitBezier","sampleCurveX","t3","ax","bx","cx","sampleCurveY","t1","ay","by","cy","sampleCurveDerivativeX","t2","solveCurveX","x3","epsilon","t","i","NEWTON_METHOD_ITERATIONS","x2","$96RKe","approxEq","dx","lo","hi","solve","x1","epsilon1","DEFAULT_EPSILON","x11","y11","x21","y21","$b2475cb40559fc2b$export$45db2fc2f15997e7","n","$b2475cb40559fc2b$export$cef097a6f35c9b6a","Math","sin","PI","$b2475cb40559fc2b$export$e38aa6d936f277b2","s","$4a39eef099898156$export$2e2bcd8739ae039","deltaTime","deltaProgress","_duration","_progress","min","_circle","withRadius","lerp","_startRadius","_endRadius","_easeRadius","_removeOnComplete","removeChild","beginPath","opacity","_easeOpacity","fillStyle","_color","fade","toString","$yW6N3","circle","center","x","y","radius","fill","startRadius","endRadius","duration","color","easeRadius","easeOpacity","removeOnComplete","super","$4TER2","default","$parcel$interopDefault","$0FWmF","$c479791925765205$export$d0446fe88325854e","$c479791925765205$export$aa201224bb439d47","$c479791925765205$export$aab610c505c06a8f","ConnectionDirection","$e7b25626ebe2fa17$var$ConnectionDirection","$e7b25626ebe2fa17$export$2e2bcd8739ae039","$e36fcec16fe90272$export$2e2bcd8739ae039","add","target","direction","IN","addIncoming","OUT","addOutgoing","Error","target1","incoming","push","target2","outgoing","sampleIncoming","sample","sampleOutgoing","$f8fe5e061301c004$var$MAIN_COLOR","lighten","desaturate","$f8fe5e061301c004$var$CLOCK_COLOR","darken","$f8fe5e061301c004$var$PULSE_COLOR","$f8fe5e061301c004$export$2e2bcd8739ae039","position","canConsumeTraveller","_timer","_cooldown","incomingConnections","_connectionSet","outgoingConnections","getVisualConnectionPointAtAngle","radians","_visualConnectionCircle","pointOnCircumference","getAllReachableNodes","visited","Set","connectTo","node","consumeTraveller","_resetTimer","_pulse","constrain","progress","colorMixAmount","mapRange","bgColor","mix","moveTo","easing","addChildBefore","cooldown","isDestination","$da8e7203d6eea939$export$2e2bcd8739ae039","afterAddToScene","beforeRemoveFromScene","beforeUpdate","afterUpdate","delta1","beforeDraw","time","afterDraw","ctx1","time1","systemName","$20c335d199682e1f$export$2e2bcd8739ae039","insert","item2","point","_getPosition","boundary","contains","_nextItemIndex","NODE_CAPACITY","_items","subdivisions","_getSubdivisions","remove","item1","index","indexOf","splice","_subdivisions","clear","undefined","forEach","subdivision","findItemsInRect","rect","foundItems","intersects","item","findItemsInCircle","getBoundingBox","filter","containsPoint","getCenter","$9x7hn","fromLeftTopRightBottom","left","top","right","bottom","getPosition","$e48083a1610aebeb$export$2e2bcd8739ae039","removeTraveller","traveller1","_quadTree","width","height","traveller","children","child","$fc0940676888ae78$export$2e2bcd8739ae039","findTravellersInCircle","$4481f2d3a26f3bcf$var$PathFinder","getNextRoad","initialNode","destinationNode","remainingNodes","has","bestCosts","Map","prevRoads","set","size","cost","_nodeWithShortestDistance","delete","_nextRoadFromRoute","_updateNeighbours","nodes","costs","bestCost","Infinity","bestNode","get","road","nextNode","to","nextNodeCost","altNextNodeCost","expectedTimeFromStartToEnd","start","finish","from","$4481f2d3a26f3bcf$export$2e2bcd8739ae039","$e68ae2c24c7d7188$export$2e2bcd8739ae039","destination","nextRoad","includes","removeFromCurrentRoad","addTravellerAtStart","uniq","flatten","map","getClosestOutgoingTraveller","bestTraveller","shortestDistance","getTravellerAfterPosition","positionOnCurrentRoad","getClosestIncomingTraveller","getTravellerBeforePosition","length","distanceToEndOfCurrentRoad","$6i1fg","$28c70117a47ab52b$export$2e2bcd8739ae039","$7ic2V","getSortOrderFn","entity","$400ab8c2e6376767$export$2e2bcd8739ae039","addComponent","component","args","componentInstances","instance","hasComponent","component1","getComponent","component2","removeComponent","component3","onRemove","values","component4","component5","component6","component7","$fc0940676888ae78$var$enterEase","$b2475cb40559fc2b$export$bcede31c95c9ee9","$fc0940676888ae78$var$exitEase","StopReason","$fc0940676888ae78$var$StopReason","currentRoad","_currentRoad","getPointAtPosition","_positionOnCurrentRoad","predictedStopPoint","stopPosition","_getPredictedStopPositionIfDecelerating","_getPredictedPointForPosition","predictedStopArea","safeRadius","potentialNextPredictedStopPoint","_destination","speed","_speed","isStopped","stoppedTime","_stoppedTime","stopReason","_stopReason","isStoppedFor","other","_stoppedFor","onAddedToRoad","_pickDestination","onRemovedFromRoad","getSystem","dtMilliseconds","_age","_move","pal","_getPal","$19ECN","PalAbsoluteController","setPosition","getAngleAtPosition","_getEnterTransitionScale","_checkAtEndOfRoad","_checkExit","_isExiting","_exitStartedAt","_pal","config","$h8N2y","generateRandomPalConfig","$2dNNZ","setAnimationController","$k9rmw","$exw1r","$e9b3d2f51f5f1fed$export$b7cfb0b946e2f4d5","_getExitTransitionScale","timeToStop","overshoot","overshootAngle","fromPolar","end","potentialDestinations","dtMilliseconds1","currentRoad1","dtSeconds","_forceAccelerateTimer","_shouldDecelerate","_accelerate","currentRoad2","predictedStopPosition","STOPPED_FOR_DESTINATION","nextTravellerOnRoad","safeStopAheadPosition","comfortableRadius","STOPPED_FOR_TRAFFIC_IN_FRONT","intersection","outgoingTraveller","incomingTraveller","_shouldDecelerateForNearbyTravellers","STOPPED_FOR_TRAFFIC_NEARBY","currentRoad3","travellerFinder","stopArea","stopPoint","nextStopPoint","searchArea","nearbyTravellers","otherStopArea","otherStopPoint","intersectsCircle","otherNextStopPoint","currentStopDistance","distanceTo","approachAmount","otherApproachAmount","random","_forceAcceleration","acceleration","currentRoad4","lastSpeed","avgSpeed","currentRoad5","_onReachEndOfCurrentRoad","_onExit","currentRoad6","_onReachDestination","_exit","MAX_SPEED","$bf57ed7391903046$export$2e2bcd8739ae039","points","lastPoint","remainingPoints","path","addSegment","$b2Aev","containingCircle1","entryAngle1","exitAngle1","entryPoint","exitPoint","entryLineNormal","$6Cnop","perpendicularLineThroughPoint","exitLineNormal","isParallelTo","roadCircleCenter","pointAtIntersectionWith","roadCircleRadius","$hKbPz","sub","angle","getStart","segments","getEnd","getLength","reduce","segment","constrained","soFar","position1","segment1","lastSegment","equals","addSegments","autoRound","newSegments","entryAngle","exitAngle","usableRadius","containingCircle","segmentAcrossCircle","compacted","compact","segments1","$044aa2905e2633d4$export$2e2bcd8739ae039","_roads","connectToRoadAtAngle","_intersectionAtAngle","isIncoming","_incomingIntersections","isOutgoing","_outgoingIntersections","_intersections","_addRoad","$555e57406fd3b1be$export$2e2bcd8739ae039","angle1","angleStr","_intersectionsByAngle","_createIntersectionAtAngle","angle2","Object","keys","road1","$555e57406fd3b1be$var$ROAD_DASH_COLOR","$555e57406fd3b1be$var$ROAD_IDEAL_DASH","$555e57406fd3b1be$var$ROAD_IDEAL_DASH_LENGTH","a","b","_path","_currentTravellers","sum","canAddTravellerAtStart","nextTraveller","traveller2","removeTravellerAtIndex","position2","bestDistance","distance","position3","lineCap","lineJoin","dashScale","_getLineDashScale","dashLength","setLineDash","strokeStyle","lineDashOffset","lineWidth","stroke","wholeDashLength","floor","isNode","angleFrom","angleTo","straightThroughPoints","$095811fd17bac22d$var$MAIN_COLOR","$095811fd17bac22d$var$CLOCK_COLOR","$095811fd17bac22d$var$PULSE_COLOR","$095811fd17bac22d$export$2e2bcd8739ae039","_onTimerEnd","arc","$095811fd17bac22d$var$RADIUS","_attemptEmitTraveller","$c92f324627ca05f7$var$scene","canvas","_scaleFactor","scaleFactor","isPlaying","frameHandle","_isPlaying","newValue","_children","appendTo","element","appendChild","hasSystem","systemType","systemsByClass","systemType1","system","addSystem","removeSystem","systemType2","child3","targetChild","newChild","addChildAtIndex","addChildAfter","targetChild1","newChild1","child1","child2","removeChildAtIndex","index1","system1","elapsedTime1","save","scale","clearRect","sort","system2","restore","window","requestAnimationFrame","_tick","stop","cancelAnimationFrame","lastElapsedTime","_setupVisiblityChange","playOnVisible","document","addEventListener","hidden","createElement","style","getContext","devicePixelRatio","$c92f324627ca05f7$var$root","getElementById","northConsumer","middleConsumer","southConsumer","eastProducer","westProducer","mainJunction","eastProducerSplit","southConsumerJoin","$c92f324627ca05f7$var$scenario3"],"version":3,"file":"index.c9978ea6.js.map"}