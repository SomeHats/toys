{"mappings":"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","sources":["src/lib/fakeConsole.ts","src/blob-tree/traceBlobTree.tsx","src/lib/DebugDraw.ts","src/blob-tree/canvas.ts","src/blob-tree/BlobTree.tsx","src/lib/IdGenerator.tsx","src/blob-tree/blob-tree-main.tsx","src/blob-tree/BlobTreeEditor.tsx"],"sourcesContent":["import { profile } from 'console';\nimport { NoToneMapping } from 'three';\nimport { noop } from './utils';\n\nexport const fakeConsole: Console = {\n  assert: noop,\n  clear: noop,\n  count: noop,\n  countReset: noop,\n  debug: noop,\n  dir: noop,\n  dirxml: noop,\n  error: noop,\n  group: noop,\n  groupCollapsed: noop,\n  groupEnd: noop,\n  info: noop,\n  log: noop,\n  table: noop,\n  time: noop,\n  timeEnd: noop,\n  timeLog: noop,\n  timeStamp: noop,\n  trace: noop,\n  warn: noop,\n  profile: noop,\n  profileEnd: noop,\n  Console: console.Console,\n};\n","import { assert } from '../lib/assert';\nimport { DebugDraw } from '../lib/DebugDraw';\nimport { fakeConsole } from '../lib/fakeConsole';\nimport Vector2 from '../lib/geom/Vector2';\nimport { constrainWrapped, indexed, sortBy } from '../lib/utils';\nimport { BlobTree, BlobTreeNode } from './BlobTree';\n\n// interface TracerInterface {\n//   moveTo(x: number, y: number);\n//   quadraticCurveTo(cpx: number, cpy: number, x: number, y: number);\n// }\n\nconst TENSION = 0.2;\n\nexport function traceBlobTree(\n  blobTree: BlobTree,\n  debugDraw: DebugDraw,\n  console = fakeConsole,\n) {\n  for (const rootNode of blobTree.iterateRootNodes()) {\n    traceBlobTreeRoot(blobTree, rootNode, debugDraw, console);\n  }\n}\n\nexport function traceBlobTreeRoot(\n  tree: BlobTree,\n  root: BlobTreeNode,\n  debugDraw: DebugDraw,\n  console = fakeConsole,\n) {\n  const prevNode = root;\n  const node: BlobTreeNode | undefined = Array.from(\n    tree.iterateChildNodes(root),\n  )[0];\n  const nextNode = node\n    ? Array.from(tree.iterateChildNodes(node))[0]\n    : undefined;\n\n  if (!prevNode || !node || !nextNode) {\n    return;\n  }\n\n  const prevCircle = prevNode.toCircle();\n  const circle = node.toCircle();\n  const nextCircle = nextNode.toCircle();\n\n  const prevTangents = prevCircle.outerTangentsWith(circle);\n  const nextTangents = circle.outerTangentsWith(nextCircle);\n\n  if (!prevTangents || !nextTangents) {\n    return;\n  }\n\n  const incomingTangentAtNode = prevTangents[0];\n  const outgoingTangentAtNode = nextTangents[0];\n  debugDraw.debugLine2(incomingTangentAtNode, { color: 'lime' });\n  debugDraw.debugLine2(outgoingTangentAtNode, { color: 'lime' });\n  const tangentIntersection = incomingTangentAtNode.pointAtIntersectionWith(\n    outgoingTangentAtNode,\n  );\n  const connectionNormal = circle.center.angleTo(tangentIntersection);\n  const connectionPoint =\n    incomingTangentAtNode.isPointWithinBounds(tangentIntersection) &&\n    outgoingTangentAtNode.isPointWithinBounds(tangentIntersection)\n      ? tangentIntersection\n      : circle.pointOnCircumference(connectionNormal);\n\n  debugDraw.debugPointX(connectionPoint);\n\n  const startPoint = incomingTangentAtNode.start;\n  const endPoint = connectionPoint;\n  const startDerivative = incomingTangentAtNode.start\n    .lerp(incomingTangentAtNode.end, TENSION)\n    .sub(startPoint);\n  const endDerivative = Vector2.fromPolar(\n    connectionNormal + Math.PI / 2,\n    incomingTangentAtNode.length * TENSION,\n  );\n  debugDraw.debugVectorAtPoint(startDerivative, startPoint);\n  debugDraw.debugVectorAtPoint(endDerivative, endPoint);\n\n  debugDraw.debugBezierCurve(\n    startPoint,\n    startPoint.add(startDerivative),\n    endPoint.sub(endDerivative),\n    endPoint,\n  );\n}\n\n// export function traceBlobTreeRoot(\n//   tree: BlobTree,\n//   root: BlobTreeNode,\n//   debugDraw: DebugDraw,\n//   console = fakeConsole,\n// ) {\n//   console.group('traceBlobTreeRoot');\n//   console.log({ tree, root });\n//   function traceNode(node: BlobTreeNode, prevTangent?: Vector2) {\n//     console.group('traceNode');\n//     console.log({ node });\n//     const nodeCircle = node.toCircle();\n\n//     const parentNode = tree.getNodeParentIfExists(node);\n//     const parentAngle = parentNode\n//       ? node.position.angleTo(parentNode.position)\n//       : 0;\n//     const children = sortBy(Array.from(tree.iterateChildNodes(node)), (child) =>\n//       constrainWrapped(\n//         0,\n//         Math.PI * 2,\n//         node.position.angleTo(child.position) - parentAngle,\n//       ),\n//     );\n\n//     let last = parentNode;\n//     let incomingTangent = prevTangent;\n//     for (const [index, child] of indexed(children)) {\n//       const childTangents = nodeCircle.outerTangentsWith(child.toCircle());\n//       if (!childTangents) continue;\n//       debugDraw.debugPolyLine([childTangents[0].start, childTangents[0].end], {\n//         color: 'lime',\n//         label: String(index),\n//       });\n\n//       const lastTangents = last?.toCircle().outerTangentsWith(nodeCircle);\n//       console.log(lastTangents);\n//       if (lastTangents) {\n//         const t1 = lastTangents[0];\n//         const t2 = childTangents[0];\n//         const angleToLineNormal = nodeCircle.center.angleTo(\n//           t1.pointAtIntersectionWith(t2),\n//         );\n//         const targetPoint = nodeCircle.pointOnCircumference(angleToLineNormal);\n//         debugDraw.debugPointX(targetPoint);\n//         const cp1 = targetPoint.add(\n//           Vector2.fromPolar(angleToLineNormal - Math.PI / 2, t1.length * 0.3),\n//         );\n//         debugDraw.debugPointX(cp1);\n//         if (prevTangent) {\n//           debugDraw.debugPointX(prevTangent, { color: 'cyan' });\n//         }\n//       }\n\n//       traceNode(child);\n//       last = child;\n//     }\n//     console.groupEnd();\n//   }\n\n//   traceNode(root);\n//   console.groupEnd();\n// }\n","import AABB from './geom/AABB';\nimport Line2 from './geom/Line2';\nimport Vector2 from './geom/Vector2';\n\nconst DEFAULT_DEBUG_COLOR = 'magenta';\nconst LABEL_OFFSET = new Vector2(5, 0);\nconst DEBUG_POINT_SIZE = 3;\nconst HAIRLINE = 0.5;\nconst DEBUG_ARROW_ANGLE = Math.PI * 0.75;\nconst DEBUG_ARROW_SIZE = 5;\n\nexport type StrokeOptions = {\n  strokeWidth?: number;\n  stroke?: string;\n  strokeCap?: 'butt' | 'round' | 'square';\n  strokeDash?: number[];\n  strokeDashOffset?: number;\n  strokeJoin?: 'bevel' | 'round' | 'miter';\n};\n\nexport type FillOptions = {\n  fill?: string;\n};\n\nexport type DebugOptions = {\n  color?: string;\n  label?: string;\n};\n\nexport type StrokeAndFillOptions = StrokeOptions & FillOptions;\n\nexport class DebugDraw {\n  constructor(public readonly ctx: CanvasRenderingContext2D) {}\n\n  public clear(fill?: string) {\n    if (!fill) {\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      return;\n    }\n\n    this.applyFillOptions({ fill });\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n\n  public beginPath() {\n    this.ctx.beginPath();\n  }\n\n  public moveTo({ x, y }: Vector2) {\n    this.ctx.moveTo(x, y);\n  }\n\n  public lineTo({ x, y }: Vector2) {\n    this.ctx.lineTo(x, y);\n  }\n\n  public arc(\n    { x, y }: Vector2,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean,\n  ) {\n    this.ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  public arcTo(p1: Vector2, p2: Vector2, radius: number) {\n    this.ctx.arcTo(p1.x, p1.y, p2.x, p2.y, radius);\n  }\n\n  public quadraticCurveTo(control: Vector2, target: Vector2) {\n    this.ctx.quadraticCurveTo(control.x, control.y, target.x, target.y);\n  }\n  public bezierCurveTo(control1: Vector2, control2: Vector2, target: Vector2) {\n    this.ctx.bezierCurveTo(\n      control1.x,\n      control1.y,\n      control2.x,\n      control2.y,\n      target.x,\n      target.y,\n    );\n  }\n\n  public applyStrokeOptions({\n    strokeWidth = 1,\n    stroke = undefined,\n    strokeCap = 'butt',\n    strokeDash = [],\n    strokeDashOffset = 0,\n    strokeJoin = 'round',\n  }: StrokeOptions) {\n    if (stroke) {\n      this.ctx.lineWidth = strokeWidth;\n      this.ctx.strokeStyle = stroke;\n      this.ctx.lineCap = strokeCap;\n      this.ctx.setLineDash(strokeDash);\n      this.ctx.lineDashOffset = strokeDashOffset;\n      this.ctx.lineJoin = strokeJoin;\n    }\n  }\n\n  public stroke(options: StrokeOptions) {\n    if (options.stroke) {\n      this.applyStrokeOptions(options);\n      this.ctx.stroke();\n    }\n  }\n\n  public applyFillOptions({ fill = undefined }: FillOptions) {\n    if (fill) {\n      this.ctx.fillStyle = fill;\n    }\n  }\n\n  public fill(options: FillOptions) {\n    if (options.fill) {\n      this.applyFillOptions(options);\n      this.ctx.fill();\n    }\n  }\n\n  public applyStrokeAndFillOptions(options: StrokeAndFillOptions) {\n    this.applyFillOptions(options);\n    this.applyStrokeOptions(options);\n  }\n\n  public strokeAndFill(options: StrokeAndFillOptions) {\n    this.fill(options);\n    this.stroke(options);\n  }\n\n  public getDebugStrokeOptions(\n    color: string = DEFAULT_DEBUG_COLOR,\n  ): StrokeOptions {\n    return { stroke: color, strokeWidth: HAIRLINE };\n  }\n\n  public debugStroke(color: string = DEFAULT_DEBUG_COLOR) {\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n\n  public fillText(text: string, position: Vector2, options: FillOptions = {}) {\n    this.applyFillOptions(options);\n    this.ctx.fillText(text, position.x, position.y);\n  }\n\n  public circle(\n    center: Vector2,\n    radius: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.arc(center, radius, 0, 2 * Math.PI);\n    this.strokeAndFill(options);\n  }\n\n  public ellipse(\n    center: Vector2,\n    radiusX: number,\n    radiusY: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.ctx.ellipse(center.x, center.y, radiusX, radiusY, 0, 0, Math.PI * 2);\n    this.strokeAndFill(options);\n  }\n\n  public debugLabel(\n    label: string | undefined,\n    position: Vector2,\n    color: string,\n  ) {\n    if (label) {\n      this.applyFillOptions({ fill: color });\n      this.fillText(label, position.add(LABEL_OFFSET));\n    }\n  }\n\n  public debugPointX(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.beginPath();\n    this.ctx.moveTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.ctx.moveTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugPointO(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.circle(position, DEBUG_POINT_SIZE, {\n      strokeWidth: HAIRLINE,\n      stroke: color,\n    });\n  }\n\n  public debugArrow(\n    start: Vector2,\n    end: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, Vector2.average([start, end]), color);\n\n    this.ctx.beginPath();\n    this.moveTo(start);\n    this.lineTo(end);\n\n    const vector = end.sub(start);\n    const arrowLeftPoint = vector\n      .rotate(-DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n    const arrowRightPoint = vector\n      .rotate(+DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n\n    this.moveTo(arrowLeftPoint);\n    this.lineTo(end);\n    this.lineTo(arrowRightPoint);\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugVectorAtPoint(\n    vector: Vector2,\n    base: Vector2,\n    options?: DebugOptions,\n  ) {\n    this.debugArrow(base, base.add(vector), options);\n  }\n\n  public polygon(\n    polygon: ReadonlyArray<Vector2>,\n    options: StrokeAndFillOptions = {},\n  ) {\n    this.beginPath();\n    this.moveTo(polygon[polygon.length - 1]);\n    for (const point of polygon) {\n      this.lineTo(point);\n    }\n    this.strokeAndFill(options);\n  }\n\n  public polyLine(points: ReadonlyArray<Vector2>, options: StrokeOptions = {}) {\n    this.beginPath();\n    this.moveTo(points[0]);\n    for (let i = 1; i < points.length; i++) {\n      this.lineTo(points[i]);\n    }\n    this.stroke(options);\n  }\n\n  public debugPolygon(\n    polygon: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polygon[0], color);\n    this.polygon(polygon, this.getDebugStrokeOptions(color));\n  }\n\n  public debugPolyLine(\n    polyLine: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polyLine[0], color);\n    this.polyLine(polyLine, this.getDebugStrokeOptions(color));\n  }\n  public debugQuadraticCurve(\n    from: Vector2,\n    control: Vector2,\n    to: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, from, color);\n    this.beginPath();\n    this.moveTo(from);\n    this.quadraticCurveTo(control, to);\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n  public debugBezierCurve(\n    from: Vector2,\n    control1: Vector2,\n    control2: Vector2,\n    to: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, from, color);\n    this.beginPath();\n    this.moveTo(from);\n    this.bezierCurveTo(control1, control2, to);\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n  public debugLine2(\n    line: Line2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, line.start, color);\n    this.debugArrow(line.start, line.end, { color, label });\n  }\n\n  public aabb(\n    aabb: AABB,\n    opts: StrokeAndFillOptions & { debug?: DebugOptions },\n  ) {\n    if (opts.debug) {\n      this.debugLabel(\n        opts.debug.label,\n        aabb.origin,\n        opts.debug.color || DEFAULT_DEBUG_COLOR,\n      );\n    }\n    this.ctx.beginPath();\n    this.ctx.rect(aabb.left, aabb.top, aabb.width, aabb.height);\n    this.strokeAndFill(opts);\n  }\n}\n","import { DebugDraw } from '../lib/DebugDraw';\n\nexport const canvasEl = document.createElement('canvas');\nexport const ctx = canvasEl.getContext('2d')!;\nexport const width = document.body.clientWidth;\nexport const height = document.body.clientHeight;\nexport const scale = window.devicePixelRatio;\n\ncanvasEl.width = width * scale;\ncanvasEl.height = height * scale;\ncanvasEl.style.width = `${width}px`;\ncanvasEl.style.height = `${height}px`;\nctx.scale(scale, scale);\nexport const canvas = new DebugDraw(ctx);\ndocument.body.appendChild(canvasEl);\n","import { assert } from '../lib/assert';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { IdGenerator } from '../lib/IdGenerator';\n\nexport class BlobTreeNode {\n  private static readonly ids = new IdGenerator('BlobTreeNode');\n\n  static create(position: Vector2, radius: number): BlobTreeNode {\n    return new BlobTreeNode(BlobTreeNode.ids.next(), position, radius);\n  }\n\n  constructor(\n    readonly id: string,\n    public position: Vector2,\n    public radius: number,\n  ) {}\n\n  toCircle(): Circle {\n    return new Circle(this.position, this.radius);\n  }\n}\n\nexport class BlobTree {\n  private nodesById = new Map<string, BlobTreeNode>();\n  private childrenById = new Map<string, Array<string>>();\n  private parentById = new Map<string, string>();\n\n  constructor() {}\n\n  getNodeByIdIfExists(id: string): BlobTreeNode | undefined {\n    return this.nodesById.get(id);\n  }\n  getNodeById(id: string): BlobTreeNode {\n    const node = this.getNodeByIdIfExists(id);\n    assert(node);\n    return node;\n  }\n\n  getNodeParentIfExists(node: BlobTreeNode): BlobTreeNode | undefined {\n    const parentId = this.parentById.get(node.id);\n    if (!parentId) {\n      return undefined;\n    }\n    return this.getNodeById(parentId);\n  }\n\n  private getMutableChildIds(node: BlobTreeNode) {\n    let childIds = this.childrenById.get(node.id);\n    if (!childIds) {\n      childIds = [];\n      this.childrenById.set(node.id, childIds);\n    }\n    return childIds;\n  }\n\n  createNewRoot(position: Vector2, radius: number): BlobTreeNode {\n    const node = BlobTreeNode.create(position, radius);\n    this.nodesById.set(node.id, node);\n    return node;\n  }\n  createNewChild(\n    parent: BlobTreeNode,\n    position: Vector2,\n    radius: number,\n  ): BlobTreeNode {\n    const node = BlobTreeNode.create(position, radius);\n    this.nodesById.set(node.id, node);\n    this.parentById.set(node.id, parent.id);\n    this.getMutableChildIds(parent).push(node.id);\n    return node;\n  }\n\n  *iterateNodes() {\n    for (const node of this.nodesById.values()) {\n      yield node;\n    }\n  }\n  *iterateChildNodes(parent: BlobTreeNode) {\n    for (const childId of this.childrenById.get(parent.id) ?? []) {\n      yield this.getNodeById(childId);\n    }\n  }\n  *iterateRootNodes() {\n    for (const node of this.nodesById.values()) {\n      if (!this.getNodeParentIfExists(node)) {\n        yield node;\n      }\n    }\n  }\n}\n","export class IdGenerator {\n  private number = 0;\n  constructor(private readonly prefix: string) {}\n\n  next() {\n    return `${this.prefix}${this.number++}`;\n  }\n}\n","import { BlobTreeEditor } from './BlobTreeEditor';\nimport { frameLoop } from '../lib/utils';\nimport { canvas } from './canvas';\nimport { BlobTree } from './BlobTree';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst editor = new BlobTreeEditor(canvas, new BlobTree());\n\ndocument.addEventListener('mousemove', (event) => {\n  editor.onMouseMove(new Vector2(event.clientX, event.clientY));\n});\ndocument.addEventListener('mousedown', (event) => {\n  editor.onMouseDown(new Vector2(event.clientX, event.clientY));\n});\ndocument.addEventListener('mouseup', (event) => {\n  editor.onMouseUp(new Vector2(event.clientX, event.clientY));\n});\ndocument.addEventListener('keydown', (event) => {\n  editor.onKeyDown(event.key);\n});\n\nframeLoop(() => {\n  editor.tick();\n  editor.draw();\n});\n\nif ((module as any).hot) {\n  (module as any).hot.dispose(() => window.location.reload());\n}\n","import { fail } from '../lib/assert';\nimport { DebugDraw } from '../lib/DebugDraw';\nimport Vector2 from '../lib/geom/Vector2';\nimport { exhaustiveSwitchError } from '../lib/utils';\nimport { BlobTree, BlobTreeNode } from './BlobTree';\nimport { traceBlobTree } from './traceBlobTree';\n\ntype EditorState =\n  | {\n      type: 'idle';\n    }\n  | {\n      type: 'createNode';\n      node: BlobTreeNode;\n    }\n  | {\n      type: 'selectedIdle';\n      node: BlobTreeNode;\n    }\n  | {\n      type: 'moveNode';\n      node: BlobTreeNode;\n      offset: Vector2;\n    }\n  | {\n      type: 'resizeNode';\n      node: BlobTreeNode;\n      offset: number;\n    };\n\ntype HoverMode = 'center' | 'edge';\nconst HOVER_EDGE_SIZE = 6;\n\nexport class BlobTreeEditor {\n  private mousePosition = Vector2.ZERO;\n  private state: EditorState = { type: 'idle' };\n\n  constructor(\n    private readonly canvas: DebugDraw,\n    public readonly blobTree: BlobTree,\n  ) {}\n\n  private getSelectedNode() {\n    switch (this.state.type) {\n      case 'idle':\n        return null;\n      case 'createNode':\n      case 'selectedIdle':\n      case 'moveNode':\n      case 'resizeNode':\n        return this.state.node;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n  private getHover(): null | { node: BlobTreeNode; mode: HoverMode } {\n    let nearestNode = null;\n    let nearestDistance = Infinity;\n    for (const node of this.blobTree.iterateNodes()) {\n      const distance = node.position.distanceTo(this.mousePosition);\n      if (distance > node.radius + HOVER_EDGE_SIZE) {\n        continue;\n      }\n      if (distance < nearestDistance) {\n        nearestDistance = distance;\n        nearestNode = node;\n      }\n    }\n\n    if (!nearestNode) {\n      return null;\n    }\n\n    const hoverEdgeSize = Math.min(nearestNode.radius * 0.1, HOVER_EDGE_SIZE);\n    return {\n      node: nearestNode,\n      mode:\n        nearestDistance < nearestNode.radius - hoverEdgeSize\n          ? 'center'\n          : 'edge',\n    };\n  }\n\n  onMouseMove(position: Vector2) {\n    this.mousePosition = position;\n  }\n\n  onMouseDown(position: Vector2) {\n    switch (this.state.type) {\n      case 'idle':\n      case 'selectedIdle': {\n        const hover = this.getHover();\n        if (hover) {\n          switch (hover.mode) {\n            case 'center':\n              this.state = {\n                type: 'moveNode',\n                node: hover.node,\n                offset: hover.node.position.sub(this.mousePosition),\n              };\n              return;\n            case 'edge':\n              this.state = {\n                type: 'resizeNode',\n                node: hover.node,\n                offset:\n                  hover.node.radius -\n                  hover.node.position.distanceTo(this.mousePosition),\n              };\n              return;\n            default:\n              exhaustiveSwitchError(hover.mode);\n          }\n        }\n        this.state = {\n          type: 'createNode',\n          node:\n            this.state.type === 'idle'\n              ? this.blobTree.createNewRoot(position, 1)\n              : this.blobTree.createNewChild(this.state.node, position, 1),\n        };\n        return;\n      }\n      case 'selectedIdle':\n        this.state = {\n          type: 'createNode',\n          node: this.blobTree.createNewChild(this.state.node, position, 1),\n        };\n        return;\n      case 'createNode':\n      case 'moveNode':\n      case 'resizeNode':\n        return;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n\n  onMouseUp(position: Vector2) {\n    switch (this.state.type) {\n      case 'idle':\n      case 'selectedIdle':\n        return;\n      case 'createNode':\n      case 'moveNode':\n      case 'resizeNode':\n        this.state = { type: 'selectedIdle', node: this.state.node };\n        return;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n\n  onKeyDown(key: string) {\n    console.log(key);\n    if (key === ' ') {\n      traceBlobTree(this.blobTree, this.canvas, console);\n    }\n  }\n\n  tick() {\n    switch (this.state.type) {\n      case 'idle':\n        return;\n      case 'createNode':\n        this.state.node.radius = this.state.node.position.distanceTo(\n          this.mousePosition,\n        );\n        return;\n      case 'moveNode':\n        this.state.node.position = this.mousePosition.add(this.state.offset);\n        return;\n      case 'resizeNode':\n        this.state.node.radius =\n          this.mousePosition.distanceTo(this.state.node.position) +\n          this.state.offset;\n      case 'selectedIdle':\n        return;\n      default:\n        exhaustiveSwitchError(this.state);\n    }\n  }\n\n  draw() {\n    this.canvas.clear();\n\n    const selectedNode = this.getSelectedNode();\n    const hover = this.getHover();\n\n    this.canvas.beginPath();\n    traceBlobTree(this.blobTree, this.canvas);\n    // this.canvas.stroke({\n    //   stroke: 'rgba(255, 255, 255, 0.6)',\n    //   strokeWidth: 10,\n    // });\n\n    for (const node of this.blobTree.iterateNodes()) {\n      const style =\n        node === this.getSelectedNode()\n          ? { stroke: 'lime', strokeWidth: 2 }\n          : node === hover?.node\n          ? { stroke: 'lime', strokeWidth: 1 }\n          : { stroke: 'magenta', strokeWidth: 1 };\n      this.canvas.circle(node.position, node.radius, style);\n\n      for (const child of this.blobTree.iterateChildNodes(node)) {\n        this.canvas.polyLine([node.position, child.position], {\n          stroke: 'cyan',\n          strokeWidth: 1,\n        });\n      }\n    }\n  }\n}\n"],"names":["$19c750b3a3a2c527$export$fd2b1208638d84fa","assert","noop","clear","$96RKe","count","countReset","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","table","time","timeEnd","timeLog","timeStamp","trace","warn","profile","profileEnd","Console","console","$4c730d95b878e481$export$64151648616ed69e","blobTree","debugDraw","rootNode","iterateRootNodes","$4c730d95b878e481$export$b3a9c7999facdccc","tree","root","prevNode","node","Array","from","iterateChildNodes","nextNode","undefined","prevCircle","toCircle","circle","nextCircle","prevTangents","outerTangentsWith","nextTangents","incomingTangentAtNode","outgoingTangentAtNode","debugLine2","color","tangentIntersection","pointAtIntersectionWith","connectionNormal","center","angleTo","connectionPoint","isPointWithinBounds","pointOnCircumference","debugPointX","startPoint","start","endPoint","startDerivative","lerp","end","sub","endDerivative","$6i1fg","default","fromPolar","Math","PI","length","debugVectorAtPoint","debugBezierCurve","add","$870293e39def1396$var$LABEL_OFFSET","$870293e39def1396$var$DEBUG_ARROW_ANGLE","$573f83c0e9ec0945$export$38c8a1558598a89e","document","createElement","$573f83c0e9ec0945$export$39f92e86d1722f3a","getContext","$573f83c0e9ec0945$export$7e3df82ee760448c","body","clientWidth","$573f83c0e9ec0945$export$ac607276a8fe9f0a","clientHeight","$573f83c0e9ec0945$export$dcdf75081b88279d","window","devicePixelRatio","width","height","style","scale","$573f83c0e9ec0945$export$67ea982130081db","fill","this","applyFillOptions","ctx","fillRect","canvas","clearRect","beginPath","moveTo","x","y","lineTo","x1","y1","arc","x2","y2","radius","startAngle","endAngle","anticlockwise","arcTo","p1","p2","radius1","quadraticCurveTo","control","target","bezierCurveTo","control1","control2","target1","applyStrokeOptions","strokeWidth","stroke","strokeCap","strokeDash","strokeDashOffset","strokeJoin","lineWidth","strokeStyle","lineCap","setLineDash","lineDashOffset","lineJoin","options","fill1","fillStyle","options1","applyStrokeAndFillOptions","options2","strokeAndFill","options3","getDebugStrokeOptions","debugStroke","color1","fillText","text","position","options4","radius2","options5","ellipse","center1","radiusX","radiusY","options6","debugLabel","label","position1","color2","position2","color3","label1","debugPointO","position3","color4","label2","debugArrow","color5","label3","average","vector","arrowLeftPoint","rotate","withMagnitude","arrowRightPoint","base","options7","polygon","options8","point","polyLine","points","options9","i","debugPolygon","polygon1","color6","label4","debugPolyLine","color7","label5","debugQuadraticCurve","control3","to","color8","label6","from1","control11","control21","to1","color9","label7","line","color10","label8","aabb","opts","origin","rect","left","top","appendChild","$b63d5bc40b8ca2cc$export$b9cbe4a3eefb3140","ids","next","$4TER2","id","prefix","number","$b3dfe10f51298bb8$var$editor","getSelectedNode","state","type","exhaustiveSwitchError","getHover","nearestNode","nearestDistance","Infinity","iterateNodes","distance","distanceTo","mousePosition","hoverEdgeSize","min","mode","onMouseMove","onMouseDown","hover","offset","createNewRoot","createNewChild","onMouseUp","onKeyDown","key","tick","draw","child","ZERO","getNodeByIdIfExists","id1","nodesById","get","getNodeById","id2","$87DYR","getNodeParentIfExists","parentId","parentById","getMutableChildIds","node1","childIds","childrenById","set","create","parent","radius3","push","values","parent1","ref","childId","Map","addEventListener","event","clientX","clientY","frameLoop"],"version":3,"file":"index.5ed438b6.js.map"}