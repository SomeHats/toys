var Fe=Object.defineProperty;var Le=(n,e,t)=>e in n?Fe(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var l=(n,e,t)=>Le(n,typeof e!="symbol"?e+"":e,t);import{x as Ge,a as B,d as _,U as w,b as N,s as R,c as A,i as L,R as G,w as z,k as De,e as Ze,y as Ye,o as D,g as Qe,h as Xe}from"./chunk_index.7f6X1YHT.js";function Bt(n,e){const t=[];e:for(const s of n){for(const r of t)if(e?e(s,r):s===r)continue e;t.push(s)}return t}function Kt(n){return n.filter(e=>e!=null)}function Ut(n){return n[n.length-1]}function Ft(n,e){let t,s=1/0;for(const r of n){const i=e(r);i<s&&(t=r,s=i)}return t}function Lt(n,e){let t,s=-1/0;for(const r of n){const i=e(r);i>s&&(t=r,s=i)}return t}function Je(n,e){if(n===e)return!0;if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(!Object.is(n[t],e[t]))return!1;return!0}function Gt(n,e,t){const s=new Set(e.map(i=>i[n])),r=[];for(const i of t)s.has(i[n])||r.push(i);for(const i of e)r.push(i);return r}class xe{constructor(){l(this,"items",new WeakMap)}get(e,t){return this.items.has(e)||this.items.set(e,t(e)),this.items.get(e)}}/*!
 * MIT License: https://github.com/ai/nanoid/blob/main/LICENSE
 * Modified code originally from <https://github.com/ai/nanoid>
 * Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>
 *
 * `nanoid` is currently only distributed as an ES module. Some tools (jest, playwright) don't
 * properly support ESM-only code yet, and tldraw itself is distributed as both an ES module and a
 * CommonJS module. By including nanoid here, we can make sure it works well in every environment
 * where tldraw is used. We can also remove some unused features like custom alphabets.
 */const me=globalThis.crypto,et="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict",tt=128;let M,q;function st(n){!M||M.length<n?(M=new Uint8Array(n*tt),me.getRandomValues(M),q=0):q+n>M.length&&(me.getRandomValues(M),q=0),q+=n}function rt(n=21){st(n-=0);let e="";for(let t=q-n;t<q;t++)e+=et[M[t]&63];return e}let nt=rt;function ke(n){return nt(n)}function it(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function ne(n,e){if(it(n,e))return n[e]}function ot(n){return Object.keys(n)}function y(n){return Object.values(n)}function S(n){return Object.entries(n)}function Zt(n){return Object.fromEntries(n)}function Z(n,e){const t={};let s=!1;for(const[r,i]of S(n))e(r,i)?t[r]=i:s=!0;return s?t:n}function Yt(n,e){const t={};for(const[s,r]of S(n)){const i=e(s,r);t[s]=i}return t}function Qt(n,e){if(n===e)return!0;const t=new Set(Object.keys(n)),s=new Set(Object.keys(e));if(t.size!==s.size)return!1;for(const r of t)if(!s.has(r)||!Object.is(n[r],e[r]))return!1;return!0}function Xt(n,e){const t=[];for(const s in n)Object.is(n[s],e[s])||t.push(s);return t}function Jt(n,e,t=1e-6){return Ge(n,e,(s,r)=>{if(typeof s=="number"&&typeof r=="number")return Math.abs(s-r)<t})}const at=()=>typeof process<"u"&&!1,T=[],ct=60,je=Math.floor(1e3/ct)*.9;let Y,W,Q=-je;const _e=()=>{const n=T.splice(0,T.length);for(const e of n)e()};function Ve(n=!1){if(Y)return;const e=Date.now();if(e-Q<je){Y=requestAnimationFrame(()=>{Y=void 0,Ve(!0)});return}if(n){if(W)return;Q=e,_e()}else{if(W)return;W=requestAnimationFrame(()=>{W=void 0,Q=e,_e()})}}function dt(n){return at()?(n(),()=>{}):(T.includes(n)||(T.push(n),Ve()),()=>{const e=T.indexOf(n);e>-1&&T.splice(e,1)})}/*!
 * This file was lovingly and delicately extracted from Immutable.js
 * MIT License: https://github.com/immutable-js/immutable-js/blob/main/LICENSE
 * Copyright (c) 2014-present, Lee Byron and other contributors.
 */function oe(n){return n>>>1&1073741824|n&3221225471}const ut=Object.prototype.valueOf;function O(n){if(n==null)return ye(n);if(typeof n.hashCode=="function")return oe(n.hashCode(n));const e=gt(n);if(e==null)return ye(e);switch(typeof e){case"boolean":return e?1108378657:1108378656;case"number":return ft(e);case"string":return e.length>mt?ht(e):ie(e);case"object":case"function":return pt(e);case"symbol":return lt(e);default:if(typeof e.toString=="function")return ie(e.toString());throw new Error("Value type "+typeof e+" cannot be hashed.")}}function ye(n){return n===null?1108378658:1108378659}function ft(n){if(n!==n||n===1/0)return 0;let e=n|0;for(e!==n&&(e^=n*4294967295);n>4294967295;)n/=4294967295,e^=n;return oe(e)}function ht(n){let e=ee[n];return e===void 0&&(e=ie(n),J===_t&&(J=0,ee={}),J++,ee[n]=e),e}function ie(n){let e=0;for(let t=0;t<n.length;t++)e=31*e+n.charCodeAt(t)|0;return oe(e)}function lt(n){let e=we[n];return e!==void 0||(e=$e(),we[n]=e),e}function pt(n){let e=ve.get(n);return e!==void 0||(e=$e(),ve.set(n,e)),e}function gt(n){return n.valueOf!==ut&&typeof n.valueOf=="function"?n.valueOf(n):n}function $e(){const n=++X;return X&1073741824&&(X=0),n}const ve=new WeakMap,we=Object.create(null);let X=0;const mt=16,_t=255;let J=0,ee={};const k=5,P=1<<k,j=P-1,E={};function be(){return{value:!1}}function b(n){n&&(n.value=!0)}function ae(n,e){e=e||0;const t=Math.max(0,n.length-e),s=new Array(t);for(let r=0;r<t;r++)s[r]=n[r+e];return s}const V=Object.is;class Ne{}class ce{constructor(e){l(this,"_root");l(this,"size");l(this,"__ownerID");l(this,"__hash");l(this,"__altered");return e==null?x():e instanceof ce?e:x().withMutations(t=>{for(const[s,r]of e)t.set(s,r)})}get(e,t){return this._root?this._root.get(0,void 0,e,t):t}set(e,t){return Ae(this,e,t)}delete(e){return Ae(this,e,E)}deleteAll(e){return this.withMutations(t=>{for(const s of e)t.delete(s)})}__ensureOwner(e){return e===this.__ownerID?this:e?fe(this.size,this._root,e,this.__hash):this.size===0?x():(this.__ownerID=e,this.__altered=!1,this)}withMutations(e){const t=this.asMutable();return e(t),t.wasAltered()?t.__ensureOwner(this.__ownerID):this}wasAltered(){return this.__altered}asMutable(){return this.__ownerID?this:this.__ensureOwner(new Ne)}[Symbol.iterator](){return this.entries()[Symbol.iterator]()}entries(){return new te(this,yt,!1)}keys(){return new te(this,Pe,!1)}values(){return new te(this,ze,!1)}}class de{constructor(e,t){this.ownerID=e,this.entries=t}get(e,t,s,r){const i=this.entries;for(let o=0,a=i.length;o<a;o++)if(V(s,i[o][0]))return i[o][1];return r}update(e,t,s,r,i,o,a){const c=i===E,u=this.entries;let d=0;const f=u.length;for(;d<f&&!V(r,u[d][0]);d++);const h=d<f;if(h?u[d][1]===i:c)return this;if(b(a),(c||!h)&&b(o),c&&u.length===1)return;if(!h&&!c&&u.length>=It)return bt(e,u,r,i);const g=e&&e===this.ownerID,m=g?u:ae(u);return h?c?d===f-1?m.pop():m[d]=m.pop():m[d]=[r,i]:m.push([r,i]),g?(this.entries=m,this):new de(e,m)}}class U{constructor(e,t,s){this.ownerID=e,this.bitmap=t,this.nodes=s}get(e,t,s,r){t===void 0&&(t=O(s));const i=1<<((e===0?t:t>>>e)&j),o=this.bitmap;return o&i?this.nodes[Ie(o&i-1)].get(e+k,t,s,r):r}update(e,t,s,r,i,o,a){s===void 0&&(s=O(r));const c=(t===0?s:s>>>t)&j,u=1<<c,d=this.bitmap,f=(d&u)!==0;if(!f&&i===E)return this;const h=Ie(d&u-1),g=this.nodes,m=f?g[h]:void 0,p=he(m,e,t+k,s,r,i,o,a);if(p===m)return this;if(!f&&p&&g.length>=Mt)return Ct(e,g,d,c,p);if(f&&!p&&g.length===2&&Se(g[h^1]))return g[h^1];if(f&&p&&g.length===1&&Se(p))return p;const v=e&&e===this.ownerID,$=f?p?d:d^u:d|u,ge=f?p?We(g,h,p,v):St(g,h,v):At(g,h,p,v);return v?(this.bitmap=$,this.nodes=ge,this):new U(e,$,ge)}}class ue{constructor(e,t,s){this.ownerID=e,this.count=t,this.nodes=s}get(e,t,s,r){t===void 0&&(t=O(s));const i=(e===0?t:t>>>e)&j,o=this.nodes[i];return o?o.get(e+k,t,s,r):r}update(e,t,s,r,i,o,a){s===void 0&&(s=O(r));const c=(t===0?s:s>>>t)&j,u=i===E,d=this.nodes,f=d[c];if(u&&!f)return this;const h=he(f,e,t+k,s,r,i,o,a);if(h===f)return this;let g=this.count;if(!f)g++;else if(!h&&(g--,g<Ot))return Et(e,d,g,c);const m=e&&e===this.ownerID,p=We(d,c,h,m);return m?(this.count=g,this.nodes=p,this):new ue(e,g,p)}}class F{constructor(e,t,s){this.ownerID=e,this.keyHash=t,this.entries=s}get(e,t,s,r){const i=this.entries;for(let o=0,a=i.length;o<a;o++)if(V(s,i[o][0]))return i[o][1];return r}update(e,t,s,r,i,o,a){s===void 0&&(s=O(r));const c=i===E;if(s!==this.keyHash)return c?this:(b(a),b(o),le(this,e,t,s,[r,i]));const u=this.entries;let d=0;const f=u.length;for(;d<f&&!V(r,u[d][0]);d++);const h=d<f;if(h?u[d][1]===i:c)return this;if(b(a),(c||!h)&&b(o),c&&f===2)return new H(e,this.keyHash,u[d^1]);const g=e&&e===this.ownerID,m=g?u:ae(u);return h?c?d===f-1?m.pop():m[d]=m.pop():m[d]=[r,i]:m.push([r,i]),g?(this.entries=m,this):new F(e,this.keyHash,m)}}class H{constructor(e,t,s){this.ownerID=e,this.keyHash=t,this.entry=s}get(e,t,s,r){return V(s,this.entry[0])?this.entry[1]:r}update(e,t,s,r,i,o,a){const c=i===E,u=V(r,this.entry[0]);if(u?i===this.entry[1]:c)return this;if(b(a),c){b(o);return}return u?e&&e===this.ownerID?(this.entry[1]=i,this):new H(e,this.keyHash,[r,i]):(b(o),le(this,e,t,O(r),[r,i]))}}class te{constructor(e,t,s){l(this,"_stack");this._type=t,this._reverse=s,this._stack=e._root&&Ee(e._root)}[Symbol.iterator](){return this}next(){const e=this._type;let t=this._stack;for(;t;){const s=t.node,r=t.index++;let i;if(s.entry){if(r===0)return se(e,s.entry)}else if("entries"in s&&s.entries){if(i=s.entries.length-1,r<=i)return se(e,s.entries[this._reverse?i-r:r])}else if(i=s.nodes.length-1,r<=i){const o=s.nodes[this._reverse?i-r:r];if(o){if(o.entry)return se(e,o.entry);t=this._stack=Ee(o,t)}continue}t=this._stack=this._stack.__prev}return wt()}}function se(n,e){return vt(n,e[0],e[1])}function Ee(n,e){return{node:n,index:0,__prev:e}}const Pe=0,ze=1,yt=2;function vt(n,e,t,s){const r=n===Pe?e:n===ze?t:[e,t];return s?s.value=r:s={value:r,done:!1},s}function wt(){return{value:void 0,done:!0}}function fe(n,e,t,s){const r=Object.create(ce.prototype);return r.size=n,r._root=e,r.__ownerID=t,r.__hash=s,r.__altered=!1,r}let Ce;function x(){return Ce||(Ce=fe(0))}function Ae(n,e,t){let s,r;if(n._root){const i=be(),o=be();if(s=he(n._root,n.__ownerID,0,void 0,e,t,i,o),!o.value)return n;r=n.size+(i.value?t===E?-1:1:0)}else{if(t===E)return n;r=1,s=new de(n.__ownerID,[[e,t]])}return n.__ownerID?(n.size=r,n._root=s,n.__hash=void 0,n.__altered=!0,n):s?fe(r,s):x()}function he(n,e,t,s,r,i,o,a){return n?n.update(e,t,s,r,i,o,a):i===E?n:(b(a),b(o),new H(e,s,[r,i]))}function Se(n){return n.constructor===H||n.constructor===F}function le(n,e,t,s,r){if(n.keyHash===s)return new F(e,s,[n.entry,r]);const i=(t===0?n.keyHash:n.keyHash>>>t)&j,o=(t===0?s:s>>>t)&j;let a;const c=i===o?[le(n,e,t+k,s,r)]:(a=new H(e,s,r),i<o?[n,a]:[a,n]);return new U(e,1<<i|1<<o,c)}function bt(n,e,t,s){n||(n=new Ne);let r=new H(n,O(t),[t,s]);for(let i=0;i<e.length;i++){const o=e[i];r=r.update(n,0,void 0,o[0],o[1])}return r}function Et(n,e,t,s){let r=0,i=0;const o=new Array(t);for(let a=0,c=1,u=e.length;a<u;a++,c<<=1){const d=e[a];d!==void 0&&a!==s&&(r|=c,o[i++]=d)}return new U(n,r,o)}function Ct(n,e,t,s,r){let i=0;const o=new Array(P);for(let a=0;t!==0;a++,t>>>=1)o[a]=t&1?e[i++]:void 0;return o[s]=r,new ue(n,i+1,o)}function Ie(n){return n-=n>>1&1431655765,n=(n&858993459)+(n>>2&858993459),n=n+(n>>4)&252645135,n+=n>>8,n+=n>>16,n&127}function We(n,e,t,s){const r=s?n:ae(n);return r[e]=t,r}function At(n,e,t,s){const r=n.length+1;if(s&&e+1===r)return n[e]=t,n;const i=new Array(r);let o=0;for(let a=0;a<r;a++)a===e?(i[a]=t,o=-1):i[a]=n[a+o];return i}function St(n,e,t){const s=n.length-1;if(t&&e===s)return n.pop(),n;const r=new Array(s);let i=0;for(let o=0;o<s;o++)o===e&&(i=1),r[o]=n[o+i];return r}const It=P/4,Mt=P/2,Ot=P/4;var qe,Te;class Me{constructor(e,t){l(this,"atoms");l(this,qe,"AtomMap");this.name=e;let s=x();t&&(s=s.withMutations(r=>{for(const[i,o]of t)r.set(i,B(`${e}:${String(i)}`,o))})),this.atoms=B(`${e}:atoms`,s)}getAtom(e){const t=this.atoms.__unsafe__getWithoutCapture().get(e);if(!t){this.atoms.get();return}return t}get(e){var s;const t=(s=this.getAtom(e))==null?void 0:s.get();return _(t!==w),t}__unsafe__getWithoutCapture(e){const t=this.atoms.__unsafe__getWithoutCapture().get(e);if(!t)return;const s=t.__unsafe__getWithoutCapture();return _(s!==w),s}has(e){const t=this.getAtom(e);return t?t.get()!==w:!1}__unsafe__hasWithoutCapture(e){const t=this.atoms.__unsafe__getWithoutCapture().get(e);return t?(_(t.__unsafe__getWithoutCapture()!==w),!0):!1}set(e,t){const s=this.atoms.__unsafe__getWithoutCapture().get(e);return s?s.set(t):this.atoms.update(r=>r.set(e,B(`${this.name}:${String(e)}`,t))),this}update(e,t){const s=this.atoms.__unsafe__getWithoutCapture().get(e);if(!s)throw new Error(`AtomMap: key ${e} not found`);const r=s.__unsafe__getWithoutCapture();_(r!==w),s.set(t(r))}delete(e){const t=this.atoms.__unsafe__getWithoutCapture().get(e);return t?(N(()=>{t.set(w),this.atoms.update(s=>s.delete(e))}),!0):!1}deleteMany(e){return N(()=>{const t=[],s=this.atoms.get().withMutations(r=>{for(const i of e){const o=r.get(i);if(!o)continue;const a=o.get();_(a!==w),t.push([i,a]),r.delete(i),o.set(w)}});return t.length&&this.atoms.set(s),t})}clear(){return N(()=>{for(const e of this.atoms.__unsafe__getWithoutCapture().values())e.set(w);this.atoms.set(x())})}*entries(){for(const[e,t]of this.atoms.get()){const s=t.get();_(s!==w),yield[e,s]}}*keys(){for(const e of this.atoms.get().keys())yield e}*values(){for(const e of this.atoms.get().values()){const t=e.get();_(t!==w),yield t}}get size(){return this.atoms.get().size}forEach(e,t){for(const[s,r]of this.entries())e.call(t,r,s,this)}[(Te=Symbol.iterator,qe=Symbol.toStringTag,Te)](){return this.entries()}}class re{constructor(e){l(this,"nextValue");l(this,"diff");this.previousValue=e}get(){var s,r,i,o;const e=((r=(s=this.diff)==null?void 0:s.removed)==null?void 0:r.size)??0,t=((o=(i=this.diff)==null?void 0:i.added)==null?void 0:o.size)??0;if(!(e===0&&t===0))return{value:this.nextValue,diff:this.diff}}_add(e,t){var s,r;this.nextValue??(this.nextValue=new Set(this.previousValue)),this.nextValue.add(e),this.diff??(this.diff={}),t?(s=this.diff.removed)==null||s.delete(e):((r=this.diff).added??(r.added=new Set),this.diff.added.add(e))}add(e){var r,i,o;const t=this.previousValue.has(e);if(t)return((i=(r=this.diff)==null?void 0:r.removed)==null?void 0:i.has(e))?this._add(e,t):void 0;(o=this.nextValue)!=null&&o.has(e)||this._add(e,t)}_remove(e,t){var s,r;this.nextValue??(this.nextValue=new Set(this.previousValue)),this.nextValue.delete(e),this.diff??(this.diff={}),t?((s=this.diff).removed??(s.removed=new Set),this.diff.removed.add(e)):(r=this.diff.added)==null||r.delete(e)}remove(e){var r,i,o,a;const t=this.previousValue.has(e);if(!t)return((i=(r=this.diff)==null?void 0:r.added)==null?void 0:i.has(e))?this._remove(e,t):void 0;(a=(o=this.diff)==null?void 0:o.removed)!=null&&a.has(e)||this._remove(e,t)}}function Ht(n){const e=[];for(let t=n.length-1;t>=0;t--){const s=n[t];if("id"in s)e.unshift(s);else{const r=s.dependsOn,i=e[0];i&&(e[0]={...i,dependsOn:r.concat(i.dependsOn??[])})}}return e}function Rt({sequence:n,sequenceId:e,retroactive:t=!0}){const s={sequenceId:e,retroactive:t,sequence:Ht(n)};return Be(s),s}function es(n,e){return Object.fromEntries(S(e).map(([t,s])=>[t,`${n}/${s}`]))}function ts(n){const e=n.sequenceId;return Rt({sequenceId:e,retroactive:n.retroactive??!0,sequence:n.sequence.map(t=>"id"in t?{...t,scope:"record",filter:s=>{var r,i;return s.typeName===n.recordType&&(((r=t.filter)==null?void 0:r.call(t,s))??!0)&&(((i=n.filter)==null?void 0:i.call(n,s))??!0)}}:t)})}function qt(n){const e=new Map(n.map(i=>[i.id,i])),t=new Set,s=[];function r(i){_(!t.has(i.id),`Circular dependency in migrations: ${i.id}`),t.add(i.id);const{version:o,sequenceId:a}=K(i.id),c=e.get(`${a}/${o-1}`);if(c&&r(c),i.dependsOn)for(const u of i.dependsOn){const d=e.get(u);d&&r(d)}e.delete(i.id),s.push(i)}for(const i of e.values())r(i);return s}function K(n){const[e,t]=n.split("/");return{sequenceId:e,version:parseInt(t)}}function Oe(n,e){e&&_(n.startsWith(e+"/"),`Every migration in sequence '${e}' must have an id starting with '${e}/'. Got invalid id: '${n}'`),_(n.match(/^(.*?)\/(0|[1-9]\d*)$/),`Invalid migration id: '${n}'`)}function Be(n){if(_(!n.sequenceId.includes("/"),`sequenceId cannot contain a '/', got ${n.sequenceId}`),_(n.sequenceId.length,"sequenceId must be a non-empty string"),n.sequence.length===0)return;Oe(n.sequence[0].id,n.sequenceId);let e=K(n.sequence[0].id).version;_(e===1,`Expected the first migrationId to be '${n.sequenceId}/1' but got '${n.sequence[0].id}'`);for(let t=1;t<n.sequence.length;t++){const s=n.sequence[t].id;Oe(s,n.sequenceId);const r=K(s).version;_(r===e+1,`Migration id numbers must increase in increments of 1, expected ${n.sequenceId}/${e+1} but got '${n.sequence[t].id}'`),e=r}}var C=(n=>(n.IncompatibleSubtype="incompatible-subtype",n.UnknownType="unknown-type",n.TargetVersionTooNew="target-version-too-new",n.TargetVersionTooOld="target-version-too-old",n.MigrationError="migration-error",n.UnrecognizedSubtype="unrecognized-subtype",n))(C||{});function ss(){return{added:{},updated:{},removed:{}}}function rs(n){const e={added:n.removed,removed:n.added,updated:{}};for(const[t,s]of Object.values(n.updated))e.updated[t.id]=[s,t];return e}function ns(n){return Object.keys(n.added).length===0&&Object.keys(n.updated).length===0&&Object.keys(n.removed).length===0}function Ke(n){const e={added:{},removed:{},updated:{}};return Tt(e,n),e}function Tt(n,e){for(const t of e){for(const[s,r]of S(t.added))if(n.removed[s]){const i=n.removed[s];delete n.removed[s],i!==r&&(n.updated[s]=[i,r])}else n.added[s]=r;for(const[s,[r,i]]of S(t.updated)){if(n.added[s]){n.added[s]=i,delete n.updated[s],delete n.removed[s];continue}if(n.updated[s]){n.updated[s]=[n.updated[s][0],i],delete n.removed[s];continue}n.updated[s]=t.updated[s],delete n.removed[s]}for(const[s,r]of S(t.removed))n.added[s]?delete n.added[s]:n.updated[s]?(n.removed[s]=n.updated[s][0],delete n.updated[s]):n.removed[s]=r}}class pe{constructor(e,t){l(this,"createDefaultProperties");l(this,"validator");l(this,"ephemeralKeys");l(this,"ephemeralKeySet");l(this,"scope");this.typeName=e,this.createDefaultProperties=t.createDefaultProperties,this.validator=t.validator??{validate:r=>r},this.scope=t.scope??"document",this.ephemeralKeys=t.ephemeralKeys;const s=new Set;if(t.ephemeralKeys)for(const[r,i]of S(t.ephemeralKeys))i&&s.add(r);this.ephemeralKeySet=s}create(e){const t={...this.createDefaultProperties(),id:"id"in e?e.id:this.createId()};for(const[s,r]of Object.entries(e))r!==void 0&&(t[s]=r);return t.typeName=this.typeName,t}clone(e){return{...R(e),id:this.createId()}}createId(e){return this.typeName+":"+(e??ke())}createCustomId(e){return this.typeName+":"+e}parseId(e){if(!this.isId(e))throw new Error(`ID "${e}" is not a valid ID for type "${this.typeName}"`);return e.slice(this.typeName.length+1)}isInstance(e){return(e==null?void 0:e.typeName)===this.typeName}isId(e){if(!e)return!1;for(let t=0;t<this.typeName.length;t++)if(e[t]!==this.typeName[t])return!1;return e[this.typeName.length]===":"}withDefaultProperties(e){return new pe(this.typeName,{createDefaultProperties:e,validator:this.validator,scope:this.scope,ephemeralKeys:this.ephemeralKeys})}validate(e,t){return t&&this.validator.validateUsingKnownGoodVersion?this.validator.validateUsingKnownGoodVersion(t,e):this.validator.validate(e)}}function is(n,e){return new pe(n,{createDefaultProperties:()=>({}),validator:e.validator,scope:e.scope,ephemeralKeys:e.ephemeralKeys})}function Dt(n){if(n.length===0)return new Set;const e=n[0],t=n.slice(1),s=new Set;for(const r of e)t.every(i=>i.has(r))&&s.add(r);return s}function xt(n,e){const t={};for(const s of e)n.has(s)||(t.added??(t.added=new Set),t.added.add(s));for(const s of n)e.has(s)||(t.removed??(t.removed=new Set),t.removed.add(s));return t.added||t.removed?t:void 0}function He(n,e){for(const[t,s]of Object.entries(n)){const r=s,i=e[t];if("eq"in r&&i!==r.eq||"neq"in r&&i===r.neq||"gt"in r&&(typeof i!="number"||i<=r.gt))return!1}return!0}function Re(n,e,t){const s=Object.fromEntries(Object.keys(t).map(r=>[r,new Set]));for(const[r,i]of Object.entries(t))if("eq"in i){const a=n.index(e,r).get().get(i.eq);if(a)for(const c of a)s[r].add(c)}else if("neq"in i){const o=n.index(e,r);for(const[a,c]of o.get())if(a!==i.neq)for(const u of c)s[r].add(u)}else if("gt"in i){const o=n.index(e,r);for(const[a,c]of o.get())if(a>i.gt)for(const u of c)s[r].add(u)}return Dt(Object.values(s))}class kt{constructor(e,t){l(this,"indexCache",new Map);l(this,"historyCache",new Map);this.recordMap=e,this.history=t}filterHistory(e){if(this.historyCache.has(e))return this.historyCache.get(e);const t=A("filterHistory:"+e,(s,r)=>{if(L(s))return this.history.get();const i=this.history.getDiffSince(r);if(i===G)return this.history.get();const o={added:{},removed:{},updated:{}};let a=0,c=0,u=0;for(const d of i){for(const f of y(d.added))if(f.typeName===e)if(o.removed[f.id]){const h=o.removed[f.id];delete o.removed[f.id],c--,h!==f&&(o.updated[f.id]=[h,f],u++)}else o.added[f.id]=f,a++;for(const[f,h]of y(d.updated))h.typeName===e&&(o.added[h.id]?o.added[h.id]=h:o.updated[h.id]?o.updated[h.id]=[o.updated[h.id][0],h]:(o.updated[h.id]=[f,h],u++));for(const f of y(d.removed))f.typeName===e&&(o.added[f.id]?(delete o.added[f.id],a--):o.updated[f.id]?(o.removed[f.id]=o.updated[f.id][0],delete o.updated[f.id],u--,c++):(o.removed[f.id]=f,c++))}return a||c||u?z(this.history.get(),o):s},{historyLength:100});return this.historyCache.set(e,t),t}index(e,t){const s=e+":"+t;if(this.indexCache.has(s))return this.indexCache.get(s);const r=this.__uncached_createIndex(e,t);return this.indexCache.set(s,r),r}__uncached_createIndex(e,t){const s=this.filterHistory(e),r=()=>{s.get();const i=new Map;for(const o of this.recordMap.values())if(o.typeName===e){const a=o[t];i.has(a)||i.set(a,new Set),i.get(a).add(o.id)}return i};return A("index:"+e+":"+t,(i,o)=>{if(L(i))return r();const a=s.getDiffSince(o);if(a===G)return r();const c=new Map,u=(g,m)=>{let p=c.get(g);p||(p=new re(i.get(g)??new Set)),p.add(m),c.set(g,p)},d=(g,m)=>{let p=c.get(g);p||(p=new re(i.get(g)??new Set)),p.remove(m),c.set(g,p)};for(const g of a){for(const m of y(g.added))if(m.typeName===e){const p=m[t];u(p,m.id)}for(const[m,p]of y(g.updated))if(p.typeName===e){const v=m[t],$=p[t];v!==$&&(d(v,p.id),u($,p.id))}for(const m of y(g.removed))if(m.typeName===e){const p=m[t];d(p,m.id)}}let f,h;for(const[g,m]of c){const p=m.get();p&&(f||(f=new Map(i)),h||(h=new Map),p.value.size===0?f.delete(g):f.set(g,p.value),h.set(g,p.diff))}return f&&h?z(f,h):i},{historyLength:100})}record(e,t=()=>({}),s="record:"+e+(t?":"+t.toString():"")){const r=this.ids(e,t,s);return A(s,()=>{for(const i of r.get())return this.recordMap.get(i)})}records(e,t=()=>({}),s="records:"+e+(t?":"+t.toString():"")){const r=this.ids(e,t,"ids:"+s);return A(s,()=>Array.from(r.get(),i=>this.recordMap.get(i)),{isEqual:Je})}ids(e,t=()=>({}),s="ids:"+e+(t?":"+t.toString():"")){const r=this.filterHistory(e),i=()=>{r.get();const c=t();if(Object.keys(c).length===0){const u=new Set;for(const d of this.recordMap.values())d.typeName===e&&u.add(d.id);return u}return Re(this,e,c)},o=c=>{const u=i(),d=xt(c,u);return d?z(u,d):c},a=A("ids_query:"+s,t,{isEqual:De});return A("query:"+s,(c,u)=>{const d=a.get();if(L(c))return i();if(u<a.lastChangedEpoch)return o(c);const f=r.getDiffSince(u);if(f===G)return o(c);const h=new re(c);for(const m of f){for(const p of y(m.added))p.typeName===e&&He(d,p)&&h.add(p.id);for(const[p,v]of y(m.updated))v.typeName===e&&(He(d,v)?h.add(v.id):h.remove(v.id));for(const p of y(m.removed))p.typeName===e&&h.remove(p.id)}const g=h.get();return g?z(g.value,g.diff):c},{historyLength:50})}exec(e,t){const s=Re(this,e,t);return s.size===0?Ze:Array.from(s,r=>this.recordMap.get(r))}}class jt{constructor(e){l(this,"_beforeCreateHandlers",{});l(this,"_afterCreateHandlers",{});l(this,"_beforeChangeHandlers",{});l(this,"_afterChangeHandlers",{});l(this,"_beforeDeleteHandlers",{});l(this,"_afterDeleteHandlers",{});l(this,"_operationCompleteHandlers",[]);l(this,"_isEnabled",!0);this.store=e}isEnabled(){return this._isEnabled}setIsEnabled(e){this._isEnabled=e}handleBeforeCreate(e,t){if(!this._isEnabled)return e;const s=this._beforeCreateHandlers[e.typeName];if(s){let r=e;for(const i of s)r=i(r,t);return r}return e}handleAfterCreate(e,t){if(!this._isEnabled)return;const s=this._afterCreateHandlers[e.typeName];if(s)for(const r of s)r(e,t)}handleBeforeChange(e,t,s){if(!this._isEnabled)return t;const r=this._beforeChangeHandlers[t.typeName];if(r){let i=t;for(const o of r)i=o(e,i,s);return i}return t}handleAfterChange(e,t,s){if(!this._isEnabled)return;const r=this._afterChangeHandlers[t.typeName];if(r)for(const i of r)i(e,t,s)}handleBeforeDelete(e,t){if(!this._isEnabled)return!0;const s=this._beforeDeleteHandlers[e.typeName];if(s){for(const r of s)if(r(e,t)===!1)return!1}return!0}handleAfterDelete(e,t){if(!this._isEnabled)return;const s=this._afterDeleteHandlers[e.typeName];if(s)for(const r of s)r(e,t)}handleOperationComplete(e){if(this._isEnabled)for(const t of this._operationCompleteHandlers)t(e)}register(e){const t=[];for(const[s,r]of Object.entries(e))r!=null&&r.beforeCreate&&t.push(this.registerBeforeCreateHandler(s,r.beforeCreate)),r!=null&&r.afterCreate&&t.push(this.registerAfterCreateHandler(s,r.afterCreate)),r!=null&&r.beforeChange&&t.push(this.registerBeforeChangeHandler(s,r.beforeChange)),r!=null&&r.afterChange&&t.push(this.registerAfterChangeHandler(s,r.afterChange)),r!=null&&r.beforeDelete&&t.push(this.registerBeforeDeleteHandler(s,r.beforeDelete)),r!=null&&r.afterDelete&&t.push(this.registerAfterDeleteHandler(s,r.afterDelete));return()=>{for(const s of t)s()}}registerBeforeCreateHandler(e,t){return this._beforeCreateHandlers[e]||(this._beforeCreateHandlers[e]=[]),this._beforeCreateHandlers[e].push(t),()=>I(this._beforeCreateHandlers[e],t)}registerAfterCreateHandler(e,t){return this._afterCreateHandlers[e]||(this._afterCreateHandlers[e]=[]),this._afterCreateHandlers[e].push(t),()=>I(this._afterCreateHandlers[e],t)}registerBeforeChangeHandler(e,t){return this._beforeChangeHandlers[e]||(this._beforeChangeHandlers[e]=[]),this._beforeChangeHandlers[e].push(t),()=>I(this._beforeChangeHandlers[e],t)}registerAfterChangeHandler(e,t){return this._afterChangeHandlers[e]||(this._afterChangeHandlers[e]=[]),this._afterChangeHandlers[e].push(t),()=>I(this._afterChangeHandlers[e],t)}registerBeforeDeleteHandler(e,t){return this._beforeDeleteHandlers[e]||(this._beforeDeleteHandlers[e]=[]),this._beforeDeleteHandlers[e].push(t),()=>I(this._beforeDeleteHandlers[e],t)}registerAfterDeleteHandler(e,t){return this._afterDeleteHandlers[e]||(this._afterDeleteHandlers[e]=[]),this._afterDeleteHandlers[e].push(t),()=>I(this._afterDeleteHandlers[e],t)}registerOperationCompleteHandler(e){return this._operationCompleteHandlers.push(e),()=>I(this._operationCompleteHandlers,e)}}function I(n,e){const t=n.indexOf(e);t>=0&&n.splice(t,1)}let Vt=class{constructor(e){l(this,"id");l(this,"records");l(this,"history",B("history",0,{historyLength:1e3}));l(this,"query");l(this,"listeners",new Set);l(this,"historyAccumulator",new Nt);l(this,"historyReactor");l(this,"schema");l(this,"props");l(this,"scopedTypes");l(this,"sideEffects",new jt(this));l(this,"isMergingRemoteChanges",!1);l(this,"_integrityChecker");l(this,"_isPossiblyCorrupted",!1);l(this,"pendingAfterEvents",null);l(this,"_isInAtomicOp",!1);const{initialData:t,schema:s,id:r}=e;this.id=r??ke(),this.schema=s,this.props=e.props,t?this.records=new Me("store",S(t).map(([i,o])=>[i,this.schema.validateRecord(this,o,"initialize",null)])):this.records=new Me("store"),this.query=new kt(this.records,this.history),this.historyReactor=Ye("Store.historyReactor",()=>{this.history.get(),this._flushHistory()},{scheduleEffect:i=>this.cancelHistoryReactor=dt(i)}),this.scopedTypes={document:new Set(y(this.schema.types).filter(i=>i.scope==="document").map(i=>i.typeName)),session:new Set(y(this.schema.types).filter(i=>i.scope==="session").map(i=>i.typeName)),presence:new Set(y(this.schema.types).filter(i=>i.scope==="presence").map(i=>i.typeName))}}cancelHistoryReactor(){}_flushHistory(){if(this.historyAccumulator.hasChanges()){const e=this.historyAccumulator.flush();for(const{changes:t,source:s}of e){let r=null,i=null,o=null;for(const{onHistory:a,filters:c}of this.listeners)if(!(c.source!=="all"&&c.source!==s))if(c.scope!=="all")if(c.scope==="document"){if(i??(i=this.filterChangesByScope(t,"document")),!i)continue;a({changes:i,source:s})}else if(c.scope==="session"){if(r??(r=this.filterChangesByScope(t,"session")),!r)continue;a({changes:r,source:s})}else{if(o??(o=this.filterChangesByScope(t,"presence")),!o)continue;a({changes:o,source:s})}else a({changes:t,source:s})}}}dispose(){this.cancelHistoryReactor()}filterChangesByScope(e,t){const s={added:Z(e.added,(r,i)=>this.scopedTypes[t].has(i.typeName)),updated:Z(e.updated,(r,i)=>this.scopedTypes[t].has(i[1].typeName)),removed:Z(e.removed,(r,i)=>this.scopedTypes[t].has(i.typeName))};return Object.keys(s.added).length===0&&Object.keys(s.updated).length===0&&Object.keys(s.removed).length===0?null:s}updateHistory(e){this.historyAccumulator.add({changes:e,source:this.isMergingRemoteChanges?"remote":"user"}),this.listeners.size===0&&this.historyAccumulator.clear(),this.history.set(this.history.get()+1,e)}validate(e){this.allRecords().forEach(t=>this.schema.validateRecord(this,t,e,null))}put(e,t){this.atomic(()=>{const s={},r={};let i,o=!1;const a=this.isMergingRemoteChanges?"remote":"user";for(let c=0,u=e.length;c<u;c++){i=e[c];const d=this.records.__unsafe__getWithoutCapture(i.id);if(d){if(i=this.sideEffects.handleBeforeChange(d,i,a),this.schema.validateRecord(this,i,t??"updateRecord",d)===d)continue;i=i,this.records.set(i.id,i),o=!0,s[i.id]=[d,i],this.addDiffForAfterEvent(d,i)}else i=this.sideEffects.handleBeforeCreate(i,a),o=!0,i=this.schema.validateRecord(this,i,t??"createRecord",null),i=i,r[i.id]=i,this.addDiffForAfterEvent(null,i),this.records.set(i.id,i)}o&&this.updateHistory({added:r,updated:s,removed:{}})})}remove(e){this.atomic(()=>{const t=new Set(e),s=this.isMergingRemoteChanges?"remote":"user";if(this.sideEffects.isEnabled())for(const o of e){const a=this.records.__unsafe__getWithoutCapture(o);a&&this.sideEffects.handleBeforeDelete(a,s)===!1&&t.delete(o)}const r=this.records.deleteMany(t);if(r.length===0)return;const i={};for(const[o,a]of r)i[o]=a,this.addDiffForAfterEvent(a,null);this.updateHistory({added:{},updated:{},removed:i})})}get(e){return this.records.get(e)}unsafeGetWithoutCapture(e){return this.records.__unsafe__getWithoutCapture(e)}serialize(e="document"){const t={};for(const[s,r]of this.records)(e==="all"||this.scopedTypes[e].has(r.typeName))&&(t[s]=r);return t}getStoreSnapshot(e="document"){return{store:this.serialize(e),schema:this.schema.serialize()}}getSnapshot(e="document"){return console.warn("[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead."),this.getStoreSnapshot(e)}migrateSnapshot(e){const t=this.schema.migrateStoreSnapshot(e);if(t.type==="error")throw new Error(`Failed to migrate snapshot: ${t.reason}`);return{store:t.value,schema:this.schema.serialize()}}loadStoreSnapshot(e){const t=this.schema.migrateStoreSnapshot(e);if(t.type==="error")throw new Error(`Failed to migrate snapshot: ${t.reason}`);const s=this.sideEffects.isEnabled();try{this.sideEffects.setIsEnabled(!1),this.atomic(()=>{this.clear(),this.put(Object.values(t.value)),this.ensureStoreIsUsable()})}finally{this.sideEffects.setIsEnabled(s)}}loadSnapshot(e){console.warn("[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead."),this.loadStoreSnapshot(e)}allRecords(){return Array.from(this.records.values())}clear(){this.remove(Array.from(this.records.keys()))}update(e,t){const s=this.unsafeGetWithoutCapture(e);if(!s){console.error(`Record ${e} not found. This is probably an error`);return}this.put([t(s)])}has(e){return this.records.has(e)}listen(e,t){this._flushHistory();const s={onHistory:e,filters:{source:(t==null?void 0:t.source)??"all",scope:(t==null?void 0:t.scope)??"all"}};return this.historyReactor.scheduler.isActivelyListening||(this.historyReactor.start(),this.historyReactor.scheduler.execute()),this.listeners.add(s),()=>{this.listeners.delete(s),this.listeners.size===0&&this.historyReactor.stop()}}mergeRemoteChanges(e){if(this.isMergingRemoteChanges)return e();if(this._isInAtomicOp)throw new Error("Cannot merge remote changes while in atomic operation");try{this.atomic(e,!0,!0)}finally{this.ensureStoreIsUsable()}}extractingChanges(e){const t=[],s=this.historyAccumulator.addInterceptor(r=>t.push(r.changes));try{return N(e),Ke(t)}finally{s()}}applyDiff(e,{runCallbacks:t=!0,ignoreEphemeralKeys:s=!1}={}){this.atomic(()=>{const r=y(e.added);for(const[o,a]of y(e.updated)){const c=this.schema.getType(a.typeName);if(s&&c.ephemeralKeySet.size){const u=this.get(a.id);if(!u){r.push(a);continue}let d=null;for(const[f,h]of Object.entries(a))c.ephemeralKeySet.has(f)||Object.is(h,ne(u,f))||(d||(d={...u}),d[f]=h);d&&r.push(d)}else r.push(a)}const i=ot(e.removed);r.length&&this.put(r),i.length&&this.remove(i)},t)}createCache(e){const t=new xe;return{get:s=>{const r=this.records.getAtom(s);if(r)return t.get(r,()=>e(s,r)).get()}}}createComputedCache(e,t,s){return this.createCache((r,i)=>{const o=s!=null&&s.areRecordsEqual?A(`${e}:${r}:isEqual`,()=>i.get(),{isEqual:s.areRecordsEqual}):i;return A(e+":"+r,()=>t(o.get()),{isEqual:s==null?void 0:s.areResultsEqual})})}ensureStoreIsUsable(){this.atomic(()=>{var e;this._integrityChecker??(this._integrityChecker=this.schema.createIntegrityChecker(this)),(e=this._integrityChecker)==null||e.call(this)})}markAsPossiblyCorrupted(){this._isPossiblyCorrupted=!0}isPossiblyCorrupted(){return this._isPossiblyCorrupted}addDiffForAfterEvent(e,t){if(_(this.pendingAfterEvents,"must be in event operation"),e===t||(e&&t&&_(e.id===t.id),!e&&!t))return;const s=(e||t).id,r=this.pendingAfterEvents.get(s);r?r.after=t:this.pendingAfterEvents.set(s,{before:e,after:t})}flushAtomicCallbacks(e){let t=0,s=e?"remote":"user";for(;this.pendingAfterEvents;){const r=this.pendingAfterEvents;if(this.pendingAfterEvents=null,!!this.sideEffects.isEnabled()){if(t++,t>100)throw new Error("Maximum store update depth exceeded, bailing out");for(const{before:i,after:o}of r.values())i&&o&&i!==o&&!De(i,o)?this.sideEffects.handleAfterChange(i,o,s):i&&!o?this.sideEffects.handleAfterDelete(i,s):!i&&o&&this.sideEffects.handleAfterCreate(o,s);this.pendingAfterEvents?s="user":this.sideEffects.handleOperationComplete(s)}}}atomic(e,t=!0,s=!1){return N(()=>{if(this._isInAtomicOp){this.pendingAfterEvents||(this.pendingAfterEvents=new Map);const i=this.sideEffects.isEnabled();_(!s,"cannot call mergeRemoteChanges while in atomic operation");try{return i&&!t&&this.sideEffects.setIsEnabled(!1),e()}finally{this.sideEffects.setIsEnabled(i)}}this.pendingAfterEvents=new Map;const r=this.sideEffects.isEnabled();this.sideEffects.setIsEnabled(t??r),this._isInAtomicOp=!0,s&&(this.isMergingRemoteChanges=!0);try{const i=e();return this.isMergingRemoteChanges=!1,this.flushAtomicCallbacks(s),i}finally{this.pendingAfterEvents=null,this.sideEffects.setIsEnabled(r),this._isInAtomicOp=!1,this.isMergingRemoteChanges=!1}})}addHistoryInterceptor(e){return this.historyAccumulator.addInterceptor(t=>e(t,this.isMergingRemoteChanges?"remote":"user"))}};function $t(n){if(n.length===0)return[];const e=[];let t=[n[0]],s;for(let r=1,i=n.length;r<i;r++)s=n[r],t[0].source!==s.source&&(e.push(t),t=[]),t.push(s);return e.push(t),e.map(r=>({source:r[0].source,changes:Ke(r.map(i=>i.changes))}))}class Nt{constructor(){l(this,"_history",[]);l(this,"_interceptors",new Set)}addInterceptor(e){return this._interceptors.add(e),()=>{this._interceptors.delete(e)}}add(e){this._history.push(e);for(const t of this._interceptors)t(e)}flush(){const e=$t(this._history);return this._history=[],e}clear(){this._history=[]}hasChanges(){return this._history.length>0}}function as(n,e,t){const s=new xe;return{get(r,i){return s.get(r,()=>(r instanceof Vt?r:r.store).createComputedCache(n,c=>e(r,c),t)).get(i)}}}function Pt(n){if(n.schemaVersion>2||n.schemaVersion<1)return D.err("Bad schema version");if(n.schemaVersion===2)return D.ok(n);const e={schemaVersion:2,sequences:{"com.tldraw.store":n.storeVersion}};for(const[t,s]of Object.entries(n.recordVersions))if(e.sequences[`com.tldraw.${t}`]=s.version,"subTypeKey"in s)for(const[r,i]of Object.entries(s.subTypeVersions))e.sequences[`com.tldraw.${t}.${r}`]=i;return D.ok(e)}class Ue{constructor(e,t){l(this,"migrations",{});l(this,"sortedMigrations");var r;this.types=e,this.options=t;for(const i of t.migrations??[])_(!this.migrations[i.sequenceId],`Duplicate migration sequenceId ${i.sequenceId}`),Be(i),this.migrations[i.sequenceId]=i;const s=Object.values(this.migrations).flatMap(i=>i.sequence);this.sortedMigrations=qt(s);for(const i of this.sortedMigrations)if((r=i.dependsOn)!=null&&r.length)for(const o of i.dependsOn){const a=s.find(c=>c.id===o);_(a,`Migration '${i.id}' depends on missing migration '${o}'`)}}static create(e,t){return new Ue(e,t??{})}validateRecord(e,t,s,r){try{const i=ne(this.types,t.typeName);if(!i)throw new Error(`Missing definition for record type ${t.typeName}`);return i.validate(t,r??void 0)}catch(i){if(this.options.onValidationFailure)return this.options.onValidationFailure({store:e,record:t,phase:s,recordBefore:r,error:i});throw i}}getMigrationsSince(e){const t=Pt(e);if(!t.ok)return t;const s=t.value,r=new Set(Object.keys(s.sequences).filter(o=>this.migrations[o]));for(const o in this.migrations)s.sequences[o]===void 0&&this.migrations[o].retroactive&&r.add(o);if(r.size===0)return D.ok([]);const i=new Set;for(const o of r){const a=s.sequences[o];if(typeof a!="number"&&this.migrations[o].retroactive||a===0){for(const d of this.migrations[o].sequence)i.add(d.id);continue}const c=`${o}/${a}`,u=this.migrations[o].sequence.findIndex(d=>d.id===c);if(u===-1)return D.err("Incompatible schema?");for(const d of this.migrations[o].sequence.slice(u+1))i.add(d.id)}return D.ok(this.sortedMigrations.filter(({id:o})=>i.has(o)))}migratePersistedRecord(e,t,s="up"){const r=this.getMigrationsSince(t);if(!r.ok)return console.error("Error migrating record",r.error),{type:"error",reason:C.MigrationError};let i=r.value;if(i.length===0)return{type:"success",value:e};if(i.some(o=>o.scope==="store"))return{type:"error",reason:s==="down"?C.TargetVersionTooOld:C.TargetVersionTooNew};if(s==="down"){if(!i.every(o=>o.down))return{type:"error",reason:C.TargetVersionTooOld};i=i.slice().reverse()}e=R(e);try{for(const o of i){if(o.scope==="store")throw new Error;if(!(o.filter?o.filter(e):!0))continue;const c=o[s](e);c&&(e=R(c))}}catch(o){return console.error("Error migrating record",o),{type:"error",reason:C.MigrationError}}return{type:"success",value:e}}migrateStoreSnapshot(e){let{store:t}=e;const s=this.getMigrationsSince(e.schema);if(!s.ok)return console.error("Error migrating store",s.error),{type:"error",reason:C.MigrationError};const r=s.value;if(r.length===0)return{type:"success",value:t};t=R(t);try{for(const i of r)if(i.scope==="record")for(const[o,a]of Object.entries(t)){if(!(i.filter?i.filter(a):!0))continue;const u=i.up(a);u&&(t[o]=R(u))}else if(i.scope==="store"){const o=i.up(t);o&&(t=R(o))}else Qe(i)}catch(i){return console.error("Error migrating store",i),{type:"error",reason:C.MigrationError}}return{type:"success",value:t}}createIntegrityChecker(e){var t,s;return((s=(t=this.options).createIntegrityChecker)==null?void 0:s.call(t,e))??void 0}serialize(){return{schemaVersion:2,sequences:Object.fromEntries(Object.values(this.migrations).map(({sequenceId:e,sequence:t})=>[e,t.length?K(t.at(-1).id).version:0]))}}serializeEarliestVersion(){return{schemaVersion:2,sequences:Object.fromEntries(Object.values(this.migrations).map(({sequenceId:e})=>[e,0]))}}getType(e){const t=ne(this.types,e);return _(t,"record type does not exists"),t}}Xe("@tldraw/store","3.15.0","esm");export{Me as A,Ke as B,as as C,Jt as D,Xt as E,Gt as F,re as I,pe as R,Ue as S,xe as W,Vt as a,es as b,is as c,ts as d,Rt as e,Z as f,ne as g,it as h,S as i,y as j,Je as k,Qt as l,Yt as m,Kt as n,Zt as o,ns as p,ss as q,rs as r,Tt as s,dt as t,ke as u,Bt as v,ot as w,Ft as x,Ut as y,Lt as z};
