{"mappings":"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","sources":["src/lib/assert.ts","src/lib/utils.ts","src/lib/geom/Vector2.ts","src/lib/geom/AABB.ts","src/webgl/webgl-main.ts","src/webgl/test.vert","src/webgl/test.frag"],"sourcesContent":["export function fail(message: string): never {\n  throw new Error(message);\n}\n\nexport function assert(value: unknown, message?: string): asserts value {\n  if (!value) {\n    fail(message || 'Assertion Error');\n  }\n}\n","export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n","import { normalizeAngle, lerp } from '../utils';\n\nexport default class Vector2 {\n  static readonly ZERO = new Vector2(0, 0);\n\n  static fromPolar(angle: number, radius: number) {\n    return new Vector2(radius * Math.cos(angle), radius * Math.sin(angle));\n  }\n\n  static average(points: ReadonlyArray<Vector2>): Vector2 {\n    const sum = points.reduce((memo, p) => memo.add(p), Vector2.ZERO);\n    return sum.div(points.length);\n  }\n\n  static fromVectorLike({ x, y }: { x: number; y: number }): Vector2 {\n    return new Vector2(x, y);\n  }\n\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  toString(): string {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n\n  get magnitudeSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  get magnitude(): number {\n    return Math.sqrt(this.magnitudeSquared);\n  }\n\n  get angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  isInPolygon(polygon: ReadonlyArray<Vector2>): boolean {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const { x, y } = this;\n\n    let isInside = false;\n    for (\n      let currentIdx = 0, previousIdx = polygon.length - 1;\n      currentIdx < polygon.length;\n      previousIdx = currentIdx++\n    ) {\n      const { x: currentX, y: currentY } = polygon[currentIdx];\n      const { x: previousX, y: previousY } = polygon[previousIdx];\n      const doesIntersect =\n        currentY > y != previousY > y &&\n        x <\n          ((previousX - currentX) * (y - currentY)) / (previousY - currentY) +\n            currentX;\n\n      if (doesIntersect) {\n        isInside = !isInside;\n      }\n    }\n\n    return isInside;\n  }\n\n  equals(other: Vector2) {\n    return this === other || (this.x === other.x && this.y === other.y);\n  }\n\n  distanceTo({ x, y }: Vector2): number {\n    const dx = x - this.x;\n    const dy = y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angleTo(other: Vector2): number {\n    return other.sub(this).angle;\n  }\n\n  angleBetween(other: Vector2): number {\n    return normalizeAngle(\n      Math.atan2(other.y, other.x) - Math.atan2(this.y, this.x),\n    );\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  div(scale: number): Vector2 {\n    return new Vector2(this.x / scale, this.y / scale);\n  }\n\n  scale(scale: number): Vector2 {\n    return new Vector2(this.x * scale, this.y * scale);\n  }\n\n  negate(): Vector2 {\n    return this.scale(-1);\n  }\n\n  add({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x + x, this.y + y);\n  }\n\n  sub({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x - x, this.y - y);\n  }\n\n  floor(): Vector2 {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  ceil(): Vector2 {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n\n  round(): Vector2 {\n    return new Vector2(Math.round(this.x), Math.round(this.y));\n  }\n\n  withMagnitude(newMagnitude: number): Vector2 {\n    return Vector2.fromPolar(this.angle, newMagnitude);\n  }\n\n  normalize(): Vector2 {\n    return this.withMagnitude(1);\n  }\n\n  withAngle(newAngle: number): Vector2 {\n    return Vector2.fromPolar(newAngle, this.magnitude);\n  }\n\n  rotate(byAngle: number): Vector2 {\n    return this.withAngle(this.angle + byAngle);\n  }\n\n  lerp(other: Vector2, n: number): Vector2 {\n    return new Vector2(lerp(this.x, other.x, n), lerp(this.y, other.y, n));\n  }\n}\n","import Vector2 from './Vector2';\n\nexport default class AABB {\n  static fromLeftTopRightBottom(\n    left: number,\n    top: number,\n    right: number,\n    bottom: number,\n  ): AABB {\n    return new AABB(\n      new Vector2(left, top),\n      new Vector2(right - left, bottom - top),\n    );\n  }\n\n  constructor(public readonly origin: Vector2, public readonly size: Vector2) {\n    Object.freeze(this);\n  }\n\n  contains({ x, y }: Vector2): boolean {\n    return (\n      this.left <= x && x <= this.right && this.top <= y && y <= this.bottom\n    );\n  }\n\n  intersects(other: AABB): boolean {\n    return !(\n      this.right < other.left ||\n      this.left > other.right ||\n      this.bottom < other.top ||\n      this.top > other.bottom\n    );\n  }\n\n  getCenter(): Vector2 {\n    return this.origin.add(this.size.scale(0.5));\n  }\n\n  get left(): number {\n    return this.origin.x;\n  }\n\n  get right(): number {\n    return this.origin.x + this.size.x;\n  }\n\n  get top(): number {\n    return this.origin.y;\n  }\n\n  get bottom(): number {\n    return this.origin.y + this.size.y;\n  }\n\n  get width(): number {\n    return this.size.x;\n  }\n\n  get height(): number {\n    return this.size.y;\n  }\n}\n","import { assert } from '../lib/assert';\nimport testVert from './test.vert';\nimport testFrag from './test.frag';\nimport AABB from '../lib/geom/AABB';\nimport { times, random } from '../lib/utils';\nimport Vector2 from '../lib/geom/Vector2';\nimport { Triangle } from 'three';\n\nconst canvas = document.createElement('canvas');\ncanvas.width = document.body.clientWidth * window.devicePixelRatio;\ncanvas.height = document.body.clientHeight * window.devicePixelRatio;\ncanvas.style.width = `${document.body.clientWidth}px`;\ncanvas.style.height = `${document.body.clientHeight}px`;\ndocument.body.appendChild(canvas);\n\nconst gl = canvas.getContext('webgl');\nassert(gl);\n\nenum ShaderType {\n  Fragment = WebGLRenderingContext.FRAGMENT_SHADER,\n  Vertex = WebGLRenderingContext.VERTEX_SHADER,\n}\n\nfunction createShader(\n  gl: WebGLRenderingContext,\n  type: ShaderType,\n  source: string,\n): WebGLShader {\n  const shader = gl.createShader(type);\n  assert(shader);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success: boolean = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!success) {\n    console.log(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    throw new Error('compile error');\n  }\n  return shader;\n}\n\nfunction createProgram(\n  gl: WebGLRenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram {\n  const program = gl.createProgram();\n  assert(program);\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  const success: boolean = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!success) {\n    console.log(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    throw 'link error';\n  }\n  return program;\n}\n\nconst vertexShader = createShader(gl, ShaderType.Vertex, testVert);\nconst fragmentShader = createShader(gl, ShaderType.Fragment, testFrag);\nconst program = createProgram(gl, vertexShader, fragmentShader);\n\nconst positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\nconst colorAttributeLocation = gl.getAttribLocation(program, 'a_color');\nconst resolutionUniformLocation = gl.getUniformLocation(\n  program,\n  'u_resolution',\n);\n\nconst positionBuffer = gl.createBuffer();\nassert(positionBuffer);\n\n// 2d points\nconst positions = [10, 20, 80, 20, 10, 30, 10, 30, 80, 20, 80, 30];\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\ngl.viewport(0, 0, canvas.width, canvas.height);\n\n// Clear the canvas\ngl.clearColor(0, 0, 0, 0);\ngl.clear(gl.COLOR_BUFFER_BIT);\n\n// Tell it to use our program (pair of shaders)\ngl.useProgram(program);\n\n// set the resolution\ngl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n\ngl.enableVertexAttribArray(positionAttributeLocation);\n\n// Bind the position buffer.\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n// Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\ngl.vertexAttribPointer(\n  positionAttributeLocation,\n  2, // size = 2 components per iteration\n  gl.FLOAT, // type = the data is 32bit floats\n  false, // normalize = dont normalize the data\n  0, // stride = 0 = move forward size * sizeof(type) each iteration to get the next position\n  0, // offset = start at the beginning of the buffer\n);\n\nconst rectCount = 100;\nconst vertexBuffer = new Float32Array(rectCount * 12);\n\nfunction setRectangle(gl: WebGLRenderingContext, idx: number, rect: AABB) {\n  vertexBuffer.set(\n    [\n      rect.left,\n      rect.top,\n      rect.right,\n      rect.top,\n      rect.left,\n      rect.bottom,\n      rect.left,\n      rect.bottom,\n      rect.right,\n      rect.top,\n      rect.right,\n      rect.bottom,\n    ],\n    idx * 12,\n  );\n}\n\ntimes(rectCount, (idx) => {\n  const rect = new AABB(\n    new Vector2(random(gl.canvas.width), random(gl.canvas.height)),\n    new Vector2(random(200), random(200)),\n  );\n\n  setRectangle(gl, idx, rect);\n});\n\ngl.bufferData(gl.ARRAY_BUFFER, vertexBuffer, gl.STATIC_DRAW);\n\n// Set a random color.\n// gl.uniform4f(\n//   colorUniformLocation,\n//   Math.random(),\n//   Math.random(),\n//   Math.random(),\n//   1,\n// );\n\n// Draw the rectangle.\ngl.drawArrays(gl.TRIANGLES, 0, rectCount * 6);\n\nexport {};\n","// an attribute will receive data from a buffer\nattribute vec2 a_position;\nattribute vec4 a_color;\n\nvarying vec4 v_color;\n\nuniform vec2 u_resolution;\n\n// all shaders have a main function\nvoid main() {\n  // convert the position from pixels to 0.0 to 1.0\n  vec2 zeroToOne = a_position / u_resolution;\n \n  // convert from 0->1 to 0->2\n  vec2 zeroToTwo = zeroToOne * 2.0;\n \n  // convert from 0->2 to -1->+1 (clip space)\n  vec2 clipSpace = zeroToTwo - 1.0;\n \n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n\n  // Convert from clip space to color space.\n  // Clip space goes -1.0 to +1.0\n  // Color space goes from 0.0 to 1.0\n  v_color = a_color;\n}","precision mediump float;\n \nuniform vec4 u_color;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = v_color;\n}"],"names":["$90518cd969dab22c$export$a7a9523472993e97","value","message","Error","$90518cd969dab22c$export$2b62a06a9fee979c","$15a201ffde8bbde4$export$3a89f8d6f6bf6c9f","a","b","n","$15a201ffde8bbde4$export$4385e60b38654f68","Math","random","$db8edb9c8035529a$export$2e2bcd8739ae039","angle","radius","cos","sin","points","reduce","memo","p","add","ZERO","div","length","x","y","toString","this","magnitudeSquared","magnitude","sqrt","atan2","isInPolygon","polygon","isInside","currentIdx","previousIdx","currentX","currentY","previousX","previousY","equals","other","distanceTo","x1","y1","dx","dy","angleTo","other1","sub","angleBetween","other2","min","max","size","$15a201ffde8bbde4$export$9013bf5175691fac","PI","dot","other3","scale","scale1","negate","x2","y2","x3","y3","floor","ceil","round","withMagnitude","newMagnitude","fromPolar","normalize","withAngle","newAngle","rotate","byAngle","lerp","other4","x4","y4","$615946a1704d0ee5$export$2e2bcd8739ae039","left","top","right","bottom","contains","intersects","getCenter","origin","width","height","Object","freeze","$b42638343a930603$var$canvas","document","createElement","body","clientWidth","window","devicePixelRatio","clientHeight","style","appendChild","$b42638343a930603$var$gl","getContext","ShaderType","$b42638343a930603$var$createShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","$b42638343a930603$var$ShaderType","WebGLRenderingContext","FRAGMENT_SHADER","VERTEX_SHADER","$b42638343a930603$var$vertexShader","Vertex","$parcel$interopDefault","$b42638343a930603$var$fragmentShader","Fragment","$b42638343a930603$var$program","vertexShader","fragmentShader","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","$b42638343a930603$var$createProgram","$b42638343a930603$var$positionAttributeLocation","getAttribLocation","$b42638343a930603$var$resolutionUniformLocation","getUniformLocation","$b42638343a930603$var$positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","viewport","clearColor","clear","COLOR_BUFFER_BIT","useProgram","uniform2f","canvas","enableVertexAttribArray","vertexAttribPointer","FLOAT","$b42638343a930603$var$vertexBuffer","$b42638343a930603$var$rectCount","fn","result","i","push","$15a201ffde8bbde4$export$b5bc26e198ce73d0","idx","rect","set","$b42638343a930603$var$setRectangle","drawArrays","TRIANGLES"],"version":3,"file":"index.bbe9b8b5.js.map"}