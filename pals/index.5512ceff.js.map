{"mappings":"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","sources":["src/lib/scene/SceneObject.ts","src/lib/scene/SortOrderProvider.ts","src/pals/pals-main.ts","src/lib/scene/Scene.ts","src/lib/scene/Entity.ts"],"sourcesContent":["import { assert } from '../assert';\nimport Scene from './Scene';\n\nconst constructorIdCounts = {} as Record<string, number>;\n\nconst getNextCount = (name: string): string => {\n  if (!constructorIdCounts[name]) constructorIdCounts[name] = 0;\n  return `${name}@${constructorIdCounts[name]++}`;\n};\n\nexport default abstract class SceneObject {\n  id: string = getNextCount(this.constructor.name);\n  private scene: Scene | null = null;\n\n  hasScene(): boolean {\n    return this.scene !== null;\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene must be present');\n    return this.scene;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {}\n  update(delta: number): void {}\n\n  addTo(scene: Scene): this {\n    scene.addChild(this);\n    return this;\n  }\n\n  onAddedToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  onRemovedFromScene() {\n    this.scene = null;\n  }\n\n  getSortOrder(): number {\n    return 0;\n  }\n}\n","import Component from './Component';\nimport Entity from './Entity';\n\nexport default class SortOrderProvider extends Component {\n  constructor(\n    entity: Entity,\n    private getSortOrderFn: (entity: Entity) => number,\n  ) {\n    super(entity);\n  }\n\n  getSortOrder(): number {\n    return this.getSortOrderFn(this.entity);\n  }\n}\n","import Scene from '../lib/scene/Scene';\nimport { assert } from '../lib/assert';\nimport Vector2 from '../lib/geom/Vector2';\nimport Entity from '../lib/scene/Entity';\nimport { PalTargetController } from './PalController';\nimport PalGeom from './PalGeom';\nimport PalRenderer from './PalRenderer';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport { generateRandomPalConfig } from './PalConfig';\n\nconst root = document.getElementById('root');\nassert(root);\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nscene.appendTo(root);\n\n// const pal = new Pal(100, 50);\nconst pal = new Entity();\npal.addComponent(PalTargetController, new Vector2(100, 50));\nconst config = generateRandomPalConfig();\nconst geom = pal.addComponent(PalGeom, config);\ngeom.setAnimationController(new PalWalkAnimationController(config));\npal.addComponent(PalRenderer, config);\nscene.addChild(pal);\n\nroot.addEventListener('mousemove', e => {\n  const x = e.clientX - scene.canvas.offsetLeft;\n  const y = e.clientY - scene.canvas.offsetTop;\n  pal.getComponent(PalTargetController).setTarget(new Vector2(x - 50, y));\n});\n\nscene.start();\n\n// const scenario5 = () => {\n//   const pal = new Pal(100, 50);\n//   scene.addChild(pal);\n\n//   const root = document.getElementById('root');\n//   invariant(root, '#root must be present');\n\n//   root.addEventListener('mousemove', e => {\n//     pal.setTarget(e.offsetX / scene.scaleFactor, e.offsetY / scene.scaleFactor);\n//   });\n// };\n\n// const go = () => {\n//   if (window.scene) return;\n//   scene = new Scene(800, 600, window.devicePixelRatio);\n//   window.scene = scene;\n//   const root = document.getElementById('root');\n//   invariant(root, '#root must be present');\n//   scene.appendTo(root);\n\n//   scene.addSystem(new DebugOverlay());\n//   scene.addSystem(new TravellerFinder());\n\n//   scenario3();\n\n//   scene.start();\n// };\n","import { assert } from '../assert';\nimport SceneObject from './SceneObject';\nimport SceneSystem from './SceneSystem';\n\nconst speed = 1;\nconst scale = 1;\nconst repeatUpdate = 1;\n\ntype SystemClass<T extends SceneSystem = SceneSystem> = {\n  systemName: string;\n  new (): T;\n};\n\nexport default class Scene {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  private _scaleFactor: number;\n  private _children: SceneObject[] = [];\n  private _isPlaying: boolean = false;\n  private frameHandle: number | null = null;\n  private lastElapsedTime: number | null = null;\n  private systemsByClass = new Map<SystemClass<SceneSystem>, SceneSystem>();\n\n  constructor(width: number, height: number, scaleFactor: number = 1) {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = width * scaleFactor;\n    this.canvas.height = height * scaleFactor;\n    this.canvas.style.width = `${width}px`;\n    this.canvas.style.height = `${height}px`;\n    const ctx = this.canvas.getContext('2d');\n    assert(ctx, 'ctx');\n    this.ctx = ctx;\n    this._scaleFactor = scaleFactor * scale;\n\n    this._setupVisiblityChange();\n  }\n\n  get width(): number {\n    return this.canvas.width / this._scaleFactor;\n  }\n\n  get height(): number {\n    return this.canvas.height / this._scaleFactor;\n  }\n\n  get scaleFactor(): number {\n    return this._scaleFactor;\n  }\n\n  get isPlaying(): boolean {\n    return this.frameHandle !== null && this._isPlaying;\n  }\n\n  set isPlaying(newValue: boolean) {\n    assert(\n      this.frameHandle !== null,\n      'cannot set isPlaying without calling start',\n    );\n    this._isPlaying = newValue;\n  }\n\n  get children(): SceneObject[] {\n    return this._children;\n  }\n\n  appendTo(element: HTMLElement) {\n    element.appendChild(this.canvas);\n  }\n\n  hasSystem(systemType: SystemClass): boolean {\n    return this.systemsByClass.has(systemType);\n  }\n\n  getSystem<T extends SceneSystem>(systemType: SystemClass<T>): T {\n    const system = this.systemsByClass.get(systemType);\n    assert(system, `system, ${systemType.systemName} not found`);\n    assert(system instanceof systemType, 'system is wrong instance type');\n    return system;\n  }\n\n  addSystem(system: SceneSystem) {\n    assert(\n      !this.hasSystem(system.constructor as any),\n      'only one system of each type allowed',\n    );\n    this.systemsByClass.set(system.constructor as any, system);\n    system.afterAddToScene(this);\n  }\n\n  removeSystem(systemType: SystemClass) {\n    const system = this.getSystem(systemType);\n    system.beforeRemoveFromScene(this);\n    this.systemsByClass.delete(systemType);\n  }\n\n  addChild(child: SceneObject) {\n    this._children.push(child);\n    child.onAddedToScene(this);\n  }\n\n  addChildBefore(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index, newChild);\n  }\n\n  addChildAfter(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index + 1, newChild);\n  }\n\n  addChildAtIndex(index: number, child: SceneObject) {\n    this._children.splice(index, 0, child);\n    child.onAddedToScene(this);\n  }\n\n  removeChild(child: SceneObject): boolean {\n    const index = this._children.indexOf(child);\n    if (index === -1) return false;\n\n    this.removeChildAtIndex(index);\n    return true;\n  }\n\n  removeChildAtIndex(index: number): SceneObject {\n    const child = this._children[index];\n    this._children.splice(index, 1);\n    child.onRemovedFromScene();\n    return child;\n  }\n\n  update(delta: number) {\n    for (let i = 0; i < repeatUpdate; i++) {\n      for (const system of this.systemsByClass.values()) {\n        system.beforeUpdate(delta);\n      }\n      this._children.forEach((child) => child.update(delta));\n      for (const system of this.systemsByClass.values()) {\n        system.afterUpdate(delta);\n      }\n    }\n  }\n\n  draw(elapsedTime: number) {\n    this.ctx.save();\n    this.ctx.scale(this._scaleFactor, this._scaleFactor);\n    this.ctx.clearRect(0, 0, this.width, this.height);\n\n    for (const system of this.systemsByClass.values()) {\n      system.beforeDraw(this.ctx, elapsedTime);\n    }\n    this._children\n      .sort((a, b) => a.getSortOrder() - b.getSortOrder())\n      .forEach((child) => child.draw(this.ctx, elapsedTime));\n    for (const system of this.systemsByClass.values()) {\n      system.afterDraw(this.ctx, elapsedTime);\n    }\n\n    this.ctx.restore();\n  }\n\n  start() {\n    this._isPlaying = true;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  }\n\n  stop() {\n    if (this.frameHandle !== null) {\n      window.cancelAnimationFrame(this.frameHandle);\n      this.frameHandle = null;\n    }\n    this._isPlaying = false;\n    this.lastElapsedTime = null;\n  }\n\n  _tick = (elapsedTime: number) => {\n    elapsedTime = elapsedTime * speed;\n    const lastElapsedTime = this.lastElapsedTime;\n    if (lastElapsedTime !== null) {\n      const deltaTime = elapsedTime - lastElapsedTime;\n      if (this.isPlaying) {\n        this.update(deltaTime);\n        this.draw(elapsedTime);\n      }\n    }\n\n    this.lastElapsedTime = elapsedTime;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  };\n\n  _setupVisiblityChange() {\n    let playOnVisible = false;\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.isPlaying) {\n        playOnVisible = true;\n        this.stop();\n      }\n      if (playOnVisible && !document.hidden) {\n        playOnVisible = false;\n        this.start();\n      }\n    });\n  }\n}\n","import SceneObject from './SceneObject';\nimport Component from './Component';\nimport { assert } from '../assert';\nimport SortOrderProvider from './SortOrderProvider';\nimport Scene from './Scene';\n\ntype ComponentClass<T extends Component, Args extends unknown[]> = {\n  name: string;\n  new (entity: Entity, ...args: Args): T;\n};\n\nexport default class Entity extends SceneObject {\n  private componentInstances = new Map<\n    ComponentClass<Component, any>,\n    Component\n  >();\n\n  addComponent<T extends Component, Args extends unknown[]>(\n    component: ComponentClass<T, Args>,\n    ...args: Args\n  ): T {\n    assert(\n      !this.componentInstances.has(component),\n      `component instance ${component.name} already exists`,\n    );\n    const instance = new component(this, ...args);\n    this.componentInstances.set(component, instance);\n    return instance;\n  }\n\n  hasComponent<T extends Component>(\n    component: ComponentClass<T, any[]>,\n  ): boolean {\n    return this.componentInstances.has(component);\n  }\n\n  getComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.componentInstances.get(component);\n    assert(instance, `no instance for ${component.name} exists`);\n    assert(instance instanceof component, 'wrong instance type');\n    return instance;\n  }\n\n  removeComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.getComponent(component);\n    this.componentInstances.delete(component);\n    instance.onRemove();\n    return instance;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeDraw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.draw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterDraw(ctx, elapsedTime);\n    }\n  }\n  update(delta: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeUpdate(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.update(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterUpdate(delta);\n    }\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    for (const component of this.componentInstances.values()) {\n      component.onAddedToScene(scene);\n    }\n  }\n\n  onRemovedFromScene() {\n    const scene = this.getScene();\n    super.onRemovedFromScene();\n    for (const component of this.componentInstances.values()) {\n      component.onRemovedFromScene(scene);\n    }\n  }\n\n  getSortOrder() {\n    if (this.hasComponent(SortOrderProvider)) {\n      return this.getComponent(SortOrderProvider).getSortOrder();\n    } else {\n      return super.getSortOrder();\n    }\n  }\n}\n"],"names":["$83bf66e14d730e78$var$constructorIdCounts","$3f847b092ae83168$export$9099ad97b570f7c","$5WDzG","default","getSortOrder","getSortOrderFn","this","entity","super","$80996def6050756d$var$root","document","getElementById","$aILhO","assert","$80996def6050756d$var$scene","width","canvas","_scaleFactor","height","scaleFactor","isPlaying","frameHandle","_isPlaying","newValue","children","_children","appendTo","element","appendChild","hasSystem","systemType","systemsByClass","has","getSystem","system","get","systemName","addSystem","constructor","set","afterAddToScene","removeSystem","beforeRemoveFromScene","delete","addChild","child","push","onAddedToScene","addChildBefore","targetChild","newChild","index","indexOf","addChildAtIndex","addChildAfter","splice","removeChild","removeChildAtIndex","onRemovedFromScene","update","delta","i","values","beforeUpdate","forEach","system1","afterUpdate","draw","elapsedTime","ctx","save","scale","clearRect","beforeDraw","sort","a","b","afterDraw","restore","start","window","requestAnimationFrame","_tick","stop","cancelAnimationFrame","lastElapsedTime","_setupVisiblityChange","playOnVisible","addEventListener","hidden","Map","deltaTime","createElement","style","getContext","devicePixelRatio","$80996def6050756d$var$pal","hasScene","scene","getScene","addTo","name","id","addComponent","component","args","componentInstances","instance","hasComponent","getComponent","removeComponent","onRemove","component1","component2","$hGok8","PalTargetController","$gcFVl","$80996def6050756d$var$config","$180ke","generateRandomPalConfig","$6QVeV","setAnimationController","$7n8qG","$181T4","e","x","clientX","offsetLeft","y","clientY","offsetTop","setTarget"],"version":3,"file":"index.5512ceff.js.map"}