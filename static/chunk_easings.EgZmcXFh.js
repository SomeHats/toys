import{Y as o}from"./chunk_utils.qw3xpJ_t.js";const h=class h{constructor(s,a,t,r){const i=3*s,c=3*(t-s)-i,u=3*a,n=3*(r-a)-u;this.ax=1-i-c,this.bx=c,this.cx=i,this.ay=1-u-n,this.by=n,this.cy=u}sampleCurveX(s){return((this.ax*s+this.bx)*s+this.cx)*s}sampleCurveY(s){return((this.ay*s+this.by)*s+this.cy)*s}sampleCurveDerivativeX(s){return(3*this.ax*s+2*this.bx)*s+this.cx}solveCurveX(s,a){let t=s;for(let c=0;c<h.NEWTON_METHOD_ITERATIONS;c++){const u=this.sampleCurveX(t);if(o(u,s,a))return t;const n=this.sampleCurveDerivativeX(t);if(o(n,0,1e-6))break;t-=(u-s)/n}let r=0,i=1;if(t=s,t<r)return r;if(t>i)return i;for(;r<i;){const c=this.sampleCurveX(t);if(o(c,s,a))return t;s>c?r=t:i=t,t=(i-r)/2+r}return t}solve(s,a=h.DEFAULT_EPSILON){return this.sampleCurveY(this.solveCurveX(s,a))}};h.NEWTON_METHOD_ITERATIONS=8,h.DEFAULT_EPSILON=1e-6;let b=h;const T=e=>s=>e(1-s),l=e=>e;l.cubicBezier="cubic-bezier(0.5, 0.5, 0.5, 0.5)";const v=e=>-1*Math.cos(e*Math.PI*.5)+1;v.cubicBezier="cubic-bezier(0.12, 0, 0.39, 0)";const E=e=>Math.sin(e*Math.PI*.5);E.cubicBezier="cubic-bezier(0.61, 1, 0.88, 1)";const p=e=>-1/2*(Math.cos(Math.PI*e)-1);p.cubicBezier="cubic-bezier(0.37, 0, 0.63, 1)";const m=(e=1.70158)=>s=>1*s*s*((e+1)*s-e),C=(e=1.70158)=>s=>(s=s-1,1*(s*s*((e+1)*s+e)+1));export{C as a,m as b,v as c,p as i,l,E as o,T as r};
