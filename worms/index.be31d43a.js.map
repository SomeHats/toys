{"mappings":"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","sources":["src/lib/utils.ts","src/lib/geom/Vector2.ts","src/lib/DebugDraw.ts","src/worms/canvas.ts","src/lib/assert.ts","src/worms/colors.ts","src/worms/worms-main.ts","src/lib/createTriangleGrid.ts"],"sourcesContent":["export type TimeoutId = ReturnType<typeof setTimeout>;\nexport type IntervalId = ReturnType<typeof setInterval>;\n\nexport type ReadonlyRecord<K extends keyof any, T> = {\n  readonly [P in K]: T;\n};\n\nexport function times<T>(n: number, fn: (idx: number) => T): Array<T> {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\nexport function lerp(a: number, b: number, n: number): number {\n  return (b - a) * n + a;\n}\n\nexport function invLerp(a: number, b: number, n: number): number {\n  return (n - a) / (b - a);\n}\n\nexport function constrain(min: number, max: number, n: number): number {\n  return Math.min(max, Math.max(min, n));\n}\n\nexport function constrainWrapped(min: number, max: number, n: number): number {\n  const size = max - min;\n  n = n - min;\n  while (n < 0) {\n    n += size;\n  }\n  n = n % size;\n  return min + n;\n}\n\nexport function mapRange(\n  a1: number,\n  b1: number,\n  a2: number,\n  b2: number,\n  n: number,\n): number {\n  return lerp(a2, b2, invLerp(a1, b1, n));\n}\n\nexport function random(a: number, b?: number) {\n  if (typeof b === 'number') {\n    return lerp(a, b, Math.random());\n  }\n  return lerp(0, a, Math.random());\n}\n\nexport function randomInt(a: number, b?: number) {\n  return Math.floor(random(a, b));\n}\n\nexport function varyAbsolute(base: number, amount: number): number {\n  return random(base - amount, base + amount);\n}\n\nexport function varyRelative(base: number, amount: number): number {\n  return varyAbsolute(base, base * amount);\n}\n\nexport function sample<T>(arr: ReadonlyArray<T>): T {\n  return arr[Math.floor(random(arr.length))];\n}\n\nexport function flatten<T>(arr: ReadonlyArray<ReadonlyArray<T>>): Array<T> {\n  return arr.reduce<Array<T>>((a, b) => a.concat(b), []);\n}\n\nexport function uniq<T>(arr: T[]): Array<T> {\n  return Array.from(new Set(arr));\n}\n\nexport function intersection<T>(a1: T[], a2: T[]): T[] {\n  const a1Items = new Set(a1);\n  const result = new Set<T>();\n  for (const item of a2) {\n    if (a1Items.has(item)) {\n      result.add(item);\n    }\n  }\n  return Array.from(result);\n}\n\nexport function groupBy<T, Key>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Map<Key, Array<T>> {\n  const groups = new Map<Key, T[]>();\n  for (const item of items) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexport function sortBy<T, Key extends number | string>(\n  items: ReadonlyArray<T>,\n  getKey: (item: T) => Key,\n): Array<T> {\n  return items.slice().sort((a, b) => (getKey(a) < getKey(b) ? -1 : 1));\n}\n\nexport function partition<T>(\n  items: ReadonlyArray<T>,\n  condition: (item: T) => boolean,\n): [T[], T[]] {\n  const pass = [];\n  const fail = [];\n  for (const item of items) {\n    if (condition(item)) {\n      pass.push(item);\n    } else {\n      fail.push(item);\n    }\n  }\n  return [pass, fail];\n}\n\nexport function randomColor(): string {\n  return `rgb(${Math.floor(random(256))},${Math.floor(\n    random(256),\n  )},${Math.floor(random(256))})`;\n}\n\nexport function removeFromArray<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function frame(): Promise<number> {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => resolve(time));\n  });\n}\n\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport async function frameLoop(\n  cb: (time: number, cancel: () => void) => void,\n) {\n  let shouldCancel = false;\n  const cancel = () => {\n    shouldCancel = true;\n  };\n  while (true) {\n    cb(await frame(), cancel);\n    if (shouldCancel) {\n      return;\n    }\n  }\n}\n\nexport function fromEntries<K extends PropertyKey, V>(\n  entries: ReadonlyArray<[K, V]>,\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}\n\nexport function keys<K extends string, V>(object: Record<K, V>): Array<K> {\n  return Object.keys(object) as K[];\n}\n\nexport function values<K extends string, V>(object: Record<K, V>): Array<V> {\n  return Object.values(object) as V[];\n}\n\nexport function entries<K extends string, V>(\n  object: Record<K, V>,\n): Array<[K, V]> {\n  return Object.entries(object) as [K, V][];\n}\n\nexport function compact<T>(arr: ReadonlyArray<T>): Array<NonNullable<T>> {\n  return arr.filter(\n    (item): item is NonNullable<T> => item !== null && item !== undefined,\n  );\n}\n\nexport function normalizeAngle(angle: number): number {\n  return constrainWrapped(-Math.PI, Math.PI, angle);\n}\n\nexport function clamp(a: number, b: number, n: number): number {\n  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), n));\n}\n\nexport function shuffle<T>(arr: ReadonlyArray<T>): Array<T> {\n  const newArr = arr.slice();\n  for (let i = newArr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];\n  }\n  return newArr;\n}\n\nexport function getId(prefix = ''): string {\n  return `${prefix}${Math.random().toString(36).slice(1)}`;\n}\n\nexport function getLocalStorageItem(\n  key: string,\n  fallback: unknown = null,\n): unknown {\n  try {\n    // Get from local storage by key\n    const item = window.localStorage.getItem(key);\n    // Parse stored json or if none return initialValue\n    return item ? JSON.parse(item) : fallback;\n  } catch (error) {\n    // If error also return initialValue\n    console.log(error);\n    return fallback;\n  }\n}\n\nexport function setLocalStorageItem(key: string, value: unknown) {\n  const stringified = JSON.stringify(value);\n  try {\n    window.localStorage.setItem(key, stringified);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport function debounce<Args extends Array<unknown>>(\n  ms: number,\n  fn: (...args: Args) => void,\n): (...args: Args) => void {\n  let timeoutHandle: TimeoutId | undefined;\n\n  return (...args: Args) => {\n    if (timeoutHandle !== undefined) {\n      clearTimeout(timeoutHandle);\n    }\n    timeoutHandle = setTimeout(() => fn(...args), ms);\n  };\n}\n\nexport function exhaustiveSwitchError(value: never): never {\n  throw new Error(`Unknown switch case ${value}`);\n}\n\nexport function has(obj: object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function get<K extends string, V>(\n  obj: Partial<Record<K, V>>,\n  key: K,\n): V | undefined;\nexport function get(obj: object, key: string): unknown;\nexport function get(obj: object, key: string): unknown {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n  return (obj as any)[key];\n}\n\nexport function approxEq(a: number, b: number, epsilon: number): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\nexport function queueMicrotask(callback: () => void): () => void {\n  let isCancelled = false;\n  Promise.resolve()\n    .then(() => {\n      if (isCancelled) {\n        return;\n      }\n      callback();\n    })\n    .catch((e) =>\n      setTimeout(() => {\n        throw e;\n      }),\n    );\n  return () => {\n    isCancelled = true;\n  };\n}\n\nexport function promiseFromEvents<T>(\n  setupResolve: (resolve: (value: T) => void) => void,\n  setupReject: (reject: (error: unknown) => void) => void,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    setupResolve(resolve);\n    setupReject(reject);\n  });\n}\n\nexport function mapObjectValues<K extends string, V, U>(\n  object: Record<K, V>,\n  fn: (value: V, key: K, obj: Record<K, V>) => U,\n): Record<K, U> {\n  const result = {} as Record<K, U>;\n  for (const [k, v] of entries(object)) {\n    result[k] = fn(v, k, object);\n  }\n  return result;\n}\n","import { normalizeAngle, lerp } from '../utils';\n\nexport default class Vector2 {\n  static readonly ZERO = new Vector2(0, 0);\n\n  static fromPolar(angle: number, radius: number) {\n    return new Vector2(radius * Math.cos(angle), radius * Math.sin(angle));\n  }\n\n  static average(points: ReadonlyArray<Vector2>): Vector2 {\n    const sum = points.reduce((memo, p) => memo.add(p), Vector2.ZERO);\n    return sum.div(points.length);\n  }\n\n  static fromVectorLike({ x, y }: { x: number; y: number }): Vector2 {\n    return new Vector2(x, y);\n  }\n\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  toString(): string {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n\n  get magnitudeSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  get magnitude(): number {\n    return Math.sqrt(this.magnitudeSquared);\n  }\n\n  get angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  isInPolygon(polygon: ReadonlyArray<Vector2>): boolean {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const { x, y } = this;\n\n    let isInside = false;\n    for (\n      let currentIdx = 0, previousIdx = polygon.length - 1;\n      currentIdx < polygon.length;\n      previousIdx = currentIdx++\n    ) {\n      const { x: currentX, y: currentY } = polygon[currentIdx];\n      const { x: previousX, y: previousY } = polygon[previousIdx];\n      const doesIntersect =\n        currentY > y != previousY > y &&\n        x <\n          ((previousX - currentX) * (y - currentY)) / (previousY - currentY) +\n            currentX;\n\n      if (doesIntersect) {\n        isInside = !isInside;\n      }\n    }\n\n    return isInside;\n  }\n\n  equals(other: Vector2) {\n    return this === other || (this.x === other.x && this.y === other.y);\n  }\n\n  distanceTo({ x, y }: Vector2): number {\n    const dx = x - this.x;\n    const dy = y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  angleTo(other: Vector2): number {\n    return other.sub(this).angle;\n  }\n\n  angleBetween(other: Vector2): number {\n    return normalizeAngle(\n      Math.atan2(other.y, other.x) - Math.atan2(this.y, this.x),\n    );\n  }\n\n  dot(other: Vector2): number {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  div(scale: number): Vector2 {\n    return new Vector2(this.x / scale, this.y / scale);\n  }\n\n  scale(scale: number): Vector2 {\n    return new Vector2(this.x * scale, this.y * scale);\n  }\n\n  negate(): Vector2 {\n    return this.scale(-1);\n  }\n\n  add({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x + x, this.y + y);\n  }\n\n  sub({ x, y }: Vector2): Vector2 {\n    return new Vector2(this.x - x, this.y - y);\n  }\n\n  floor(): Vector2 {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  ceil(): Vector2 {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n\n  round(): Vector2 {\n    return new Vector2(Math.round(this.x), Math.round(this.y));\n  }\n\n  withMagnitude(newMagnitude: number): Vector2 {\n    return Vector2.fromPolar(this.angle, newMagnitude);\n  }\n\n  normalize(): Vector2 {\n    return this.withMagnitude(1);\n  }\n\n  withAngle(newAngle: number): Vector2 {\n    return Vector2.fromPolar(newAngle, this.magnitude);\n  }\n\n  rotate(byAngle: number): Vector2 {\n    return this.withAngle(this.angle + byAngle);\n  }\n\n  lerp(other: Vector2, n: number): Vector2 {\n    return new Vector2(lerp(this.x, other.x, n), lerp(this.y, other.y, n));\n  }\n}\n","import AABB from './geom/AABB';\nimport Vector2 from './geom/Vector2';\n\nconst DEFAULT_DEBUG_COLOR = 'magenta';\nconst LABEL_OFFSET = new Vector2(5, 0);\nconst DEBUG_POINT_SIZE = 3;\nconst HAIRLINE = 0.5;\nconst DEBUG_ARROW_ANGLE = Math.PI * 0.75;\nconst DEBUG_ARROW_SIZE = 5;\n\nexport type StrokeOptions = {\n  strokeWidth?: number;\n  stroke?: string;\n  strokeCap?: 'butt' | 'round' | 'square';\n  strokeDash?: number[];\n  strokeDashOffset?: number;\n  strokeJoin?: 'bevel' | 'round' | 'miter';\n};\n\nexport type FillOptions = {\n  fill?: string;\n};\n\nexport type DebugOptions = {\n  color?: string;\n  label?: string;\n};\n\nexport type StrokeAndFillOptions = StrokeOptions & FillOptions;\n\nexport class DebugDraw {\n  constructor(private readonly ctx: CanvasRenderingContext2D) {}\n\n  public clear(fill?: string) {\n    if (!fill) {\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      return;\n    }\n\n    this.applyFillOptions({ fill });\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n\n  public beginPath() {\n    this.ctx.beginPath();\n  }\n\n  public moveTo({ x, y }: Vector2) {\n    this.ctx.moveTo(x, y);\n  }\n\n  public lineTo({ x, y }: Vector2) {\n    this.ctx.lineTo(x, y);\n  }\n\n  public arc(\n    { x, y }: Vector2,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean,\n  ) {\n    this.ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  public arcTo(p1: Vector2, p2: Vector2, radius: number) {\n    this.ctx.arcTo(p1.x, p1.y, p2.x, p2.y, radius);\n  }\n\n  public applyStrokeOptions({\n    strokeWidth = 1,\n    stroke = undefined,\n    strokeCap = 'butt',\n    strokeDash = [],\n    strokeDashOffset = 0,\n    strokeJoin = 'round',\n  }: StrokeOptions) {\n    if (stroke) {\n      this.ctx.lineWidth = strokeWidth;\n      this.ctx.strokeStyle = stroke;\n      this.ctx.lineCap = strokeCap;\n      this.ctx.setLineDash(strokeDash);\n      this.ctx.lineDashOffset = strokeDashOffset;\n      this.ctx.lineJoin = strokeJoin;\n    }\n  }\n\n  public stroke(options: StrokeOptions) {\n    if (options.stroke) {\n      this.applyStrokeOptions(options);\n      this.ctx.stroke();\n    }\n  }\n\n  public applyFillOptions({ fill = undefined }: FillOptions) {\n    if (fill) {\n      this.ctx.fillStyle = fill;\n    }\n  }\n\n  public fill(options: FillOptions) {\n    if (options.fill) {\n      this.applyFillOptions(options);\n      this.ctx.fill();\n    }\n  }\n\n  public applyStrokeAndFillOptions(options: StrokeAndFillOptions) {\n    this.applyFillOptions(options);\n    this.applyStrokeOptions(options);\n  }\n\n  public strokeAndFill(options: StrokeAndFillOptions) {\n    this.fill(options);\n    this.stroke(options);\n  }\n\n  public getDebugStrokeOptions(\n    color: string = DEFAULT_DEBUG_COLOR,\n  ): StrokeOptions {\n    return { stroke: color, strokeWidth: HAIRLINE };\n  }\n\n  public debugStroke(color: string = DEFAULT_DEBUG_COLOR) {\n    this.stroke(this.getDebugStrokeOptions(color));\n  }\n\n  public fillText(text: string, position: Vector2, options: FillOptions = {}) {\n    this.applyFillOptions(options);\n    this.ctx.fillText(text, position.x, position.y);\n  }\n\n  public circle(\n    center: Vector2,\n    radius: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.arc(center, radius, 0, 2 * Math.PI);\n    this.strokeAndFill(options);\n  }\n\n  public ellipse(\n    center: Vector2,\n    radiusX: number,\n    radiusY: number,\n    options: StrokeAndFillOptions,\n  ) {\n    this.beginPath();\n    this.ctx.ellipse(center.x, center.y, radiusX, radiusY, 0, 0, Math.PI * 2);\n    this.strokeAndFill(options);\n  }\n\n  public debugLabel(\n    label: string | undefined,\n    position: Vector2,\n    color: string,\n  ) {\n    if (label) {\n      this.applyFillOptions({ fill: color });\n      this.fillText(label, position.add(LABEL_OFFSET));\n    }\n  }\n\n  public debugPointX(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.beginPath();\n    this.ctx.moveTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.ctx.moveTo(\n      position.x + DEBUG_POINT_SIZE,\n      position.y - DEBUG_POINT_SIZE,\n    );\n    this.ctx.lineTo(\n      position.x - DEBUG_POINT_SIZE,\n      position.y + DEBUG_POINT_SIZE,\n    );\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugPointO(\n    position: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, position, color);\n\n    this.circle(position, DEBUG_POINT_SIZE, {\n      strokeWidth: HAIRLINE,\n      stroke: color,\n    });\n  }\n\n  public debugArrow(\n    start: Vector2,\n    end: Vector2,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, Vector2.average([start, end]), color);\n\n    this.ctx.beginPath();\n    this.moveTo(start);\n    this.lineTo(end);\n\n    const vector = end.sub(start);\n    const arrowLeftPoint = vector\n      .rotate(-DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n    const arrowRightPoint = vector\n      .rotate(+DEBUG_ARROW_ANGLE)\n      .withMagnitude(DEBUG_ARROW_SIZE)\n      .add(end);\n\n    this.moveTo(arrowLeftPoint);\n    this.lineTo(end);\n    this.lineTo(arrowRightPoint);\n    this.stroke({ strokeWidth: HAIRLINE, stroke: color });\n  }\n\n  public debugVectorAtPoint(\n    vector: Vector2,\n    base: Vector2,\n    options?: DebugOptions,\n  ) {\n    this.debugArrow(base, base.add(vector), options);\n  }\n\n  public polygon(\n    polygon: ReadonlyArray<Vector2>,\n    options: StrokeAndFillOptions = {},\n  ) {\n    this.beginPath();\n    this.moveTo(polygon[polygon.length - 1]);\n    for (const point of polygon) {\n      this.lineTo(point);\n    }\n    this.strokeAndFill(options);\n  }\n\n  public polyLine(points: ReadonlyArray<Vector2>, options: StrokeOptions = {}) {\n    this.beginPath();\n    this.moveTo(points[0]);\n    for (let i = 1; i < points.length; i++) {\n      this.lineTo(points[i]);\n    }\n    this.stroke(options);\n  }\n\n  public debugPolygon(\n    polygon: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polygon[0], color);\n    this.polygon(polygon, this.getDebugStrokeOptions(color));\n  }\n\n  public debugPolyLine(\n    polyLine: ReadonlyArray<Vector2>,\n    { color = DEFAULT_DEBUG_COLOR, label = undefined }: DebugOptions = {},\n  ) {\n    this.debugLabel(label, polyLine[0], color);\n    this.polyLine(polyLine, this.getDebugStrokeOptions(color));\n  }\n\n  public aabb(\n    aabb: AABB,\n    opts: StrokeAndFillOptions & { debug?: DebugOptions },\n  ) {\n    if (opts.debug) {\n      this.debugLabel(\n        opts.debug.label,\n        aabb.origin,\n        opts.debug.color || DEFAULT_DEBUG_COLOR,\n      );\n    }\n    this.ctx.beginPath();\n    this.ctx.rect(aabb.left, aabb.top, aabb.width, aabb.height);\n    this.strokeAndFill(opts);\n  }\n}\n","import { DebugDraw } from '../lib/DebugDraw';\n\nexport const canvasEl = document.createElement('canvas');\nexport const ctx = canvasEl.getContext('2d')!;\nexport const width = document.body.clientWidth;\nexport const height = document.body.clientHeight;\nexport const scale = window.devicePixelRatio;\n\ncanvasEl.width = width * scale;\ncanvasEl.height = height * scale;\ncanvasEl.style.width = `${width}px`;\ncanvasEl.style.height = `${height}px`;\nctx.scale(scale, scale);\nexport const canvas = new DebugDraw(ctx);\ndocument.body.appendChild(canvasEl);\n","export function fail(message: string): never {\n  throw new Error(message);\n}\n\nexport function assert(value: unknown, message?: string): asserts value {\n  if (!value) {\n    fail(message || 'Assertion Error');\n  }\n}\n","import Color from 'color';\n\n// // https://coolors.co/f2dc5d-f2a359-db9065-a4031f-240b36\n// export const BG = new Color('#240b36');\n// export const SNAKES = [\n//   new Color('#f2dc5d'),\n//   new Color('#f2a359'),\n//   new Color('#db9065'),\n//   new Color('#a4031f'),\n// ];\n\n// https://coolors.co/ba2d0b-d5f2e3-73ba9b-003e1f-01110a\n// export const BG = new Color('#01110a');\n\n// export const SNAKES = [\n//   new Color('#ba2d0b'),\n//   new Color('#d5f2e3'),\n//   new Color('#73ba9b'),\n//   new Color('#003e1f'),\n// ];\n\n// https://coolors.co/f4e04d-f2ed6f-cee397-8db1ab-587792\nexport const BG = new Color('#E2ECC9');\nexport const SNAKES = [\n  new Color('#C33C54'),\n  new Color('#bfb915'),\n  new Color('#96ba3b'),\n  new Color('#39847f'),\n  new Color('#12416b'),\n];\n","import { canvas, width, height } from './canvas';\nimport Vector2 from '../lib/geom/Vector2';\nimport {\n  compact,\n  getId,\n  sample,\n  shuffle,\n  times,\n  randomInt,\n  frameLoop,\n  uniq,\n  random,\n} from '../lib/utils';\nimport createTriangleGrid, { Triangle } from '../lib/createTriangleGrid';\nimport { assert } from '../lib/assert';\nimport { SNAKES, BG } from './colors';\nimport { schemePaired } from 'd3-scale-chromatic';\n\nconst TILE_SIZE = 50;\nconst ARC_LENGTH = (Math.PI * TILE_SIZE) / 6;\n\nconst trianglesById = createTriangleGrid(TILE_SIZE, width, height);\n\n// for (const triangle of trianglesById.values()) {\n//   canvas.debugPolygon(triangle.points, { color: 'lime' });\n// }\n\ntype Palatte = {\n  palette: Array<string>;\n  current(): string;\n  next(): string;\n  reset(idx?: number): void;\n};\nconst makeColorPalette = (): Palatte => {\n  const palette = times(randomInt(2, 6), () => sample(SNAKES).string());\n  if (uniq(palette).length === 1) return makeColorPalette();\n\n  let i = 0;\n  return {\n    palette,\n    current: () => {\n      return palette[i % palette.length];\n    },\n    next: () => {\n      i++;\n      return palette[i % palette.length];\n    },\n    reset: (idx = 0) => {\n      i = idx;\n    },\n  };\n};\n\nfunction getSharedPoints(a: Triangle, b: Triangle) {\n  const neighbour = a.neighbours.find(n => n.triangle === b);\n  assert(neighbour, 'must be a neighbour');\n  return neighbour.sharedPoints;\n}\n\nconst occupied = new Set<Triangle>();\ntype Snake = {\n  triangles: Array<Triangle>;\n  palette: ReturnType<typeof makeColorPalette>;\n  speed: number;\n  base: number;\n  offset: number;\n  length: number;\n  isDead: boolean;\n};\n\nconst makeSnake = () => {\n  const triangles: Array<Triangle> = [];\n  const palette = makeColorPalette();\n  let neighbours = [...trianglesById.values()];\n  for (let i = 0; i < 2; i++) {\n    const availableNeighbours = neighbours.filter(\n      neighbour => !occupied.has(neighbour),\n    );\n    if (!availableNeighbours.length) break;\n    const triangle = sample(availableNeighbours);\n    triangles.push(triangle);\n    occupied.add(triangle);\n    neighbours = triangle.neighbours.map(n => n.triangle);\n  }\n\n  // if (triangles.length < 2) continue;\n  return {\n    triangles,\n    palette,\n    speed: random(0.06, 0.12),\n    offset: 0,\n    base: 0,\n    length: triangles.length,\n    isDead: false,\n  };\n};\nconst snakes: Snake[] = [];\n\nfor (let si = 0; si < 10; si++) {\n  snakes.push(makeSnake());\n}\n\nframeLoop(() => {\n  canvas.clear(BG.string());\n\n  for (const snake of snakes) {\n    snake.offset += snake.speed;\n    if (snake.offset > 1) {\n      snake.offset--;\n      snake.base++;\n\n      if (!snake.isDead) {\n        const headTriangle = snake.triangles[0];\n        const availableNeighbours = headTriangle.neighbours.filter(\n          neighbour => !occupied.has(neighbour.triangle),\n        );\n        if (availableNeighbours.length) {\n          const triangle = sample(availableNeighbours).triangle;\n          occupied.add(triangle);\n          snake.triangles.unshift(triangle);\n          snake.base--;\n          snake.length++;\n        } else {\n          snake.isDead = true;\n          snakes.push(makeSnake());\n        }\n      }\n\n      const lastTriangle = snake.triangles[snake.triangles.length - snake.base];\n      if (lastTriangle) {\n        occupied.delete(lastTriangle);\n        snake.length--;\n      }\n    }\n\n    const { triangles, palette } = snake;\n    palette.reset(snake.base);\n    for (let i = 0; i < snake.length; i++) {\n      const triangle = triangles[i];\n      const last: Triangle | undefined = triangles[i - 1];\n      const next: Triangle | undefined = triangles[i + 1];\n      const currentColor = palette.current();\n      const nextColor = palette.next();\n\n      canvas.beginPath();\n      if (!last) {\n        continue;\n        // assert(next);\n        // const neck = Vector2.average(getSharedPoints(triangle, next));\n        // const head = triangle.center\n        //   .sub(neck)\n        //   .withMagnitude(ARC_LENGTH)\n        //   .add(neck);\n        // canvas.moveTo(head);\n        // canvas.lineTo(neck);\n      } else if (!next) {\n        assert(last);\n        canvas.moveTo(Vector2.average(getSharedPoints(triangle, last)));\n        canvas.lineTo(triangle.center);\n      } else {\n        canvas.moveTo(Vector2.average(getSharedPoints(triangle, last)));\n        canvas.arcTo(triangle.center, next.center, TILE_SIZE / 2 - 0.5);\n      }\n      if (!(i === 1 && !snake.isDead)) {\n        canvas.stroke({\n          strokeWidth: TILE_SIZE / 2,\n          stroke: currentColor,\n          strokeCap: 'round',\n          strokeDash: [ARC_LENGTH, ARC_LENGTH],\n          strokeDashOffset: snake.offset * ARC_LENGTH,\n        });\n      }\n      if (!(i === snake.length - 1 && snake.isDead)) {\n        canvas.stroke({\n          strokeWidth: TILE_SIZE / 2,\n          stroke: nextColor,\n          strokeCap: 'round',\n          strokeDash: [ARC_LENGTH, ARC_LENGTH],\n          strokeDashOffset: snake.offset * ARC_LENGTH - ARC_LENGTH,\n        });\n      }\n    }\n  }\n});\n","import Vector2 from '../lib/geom/Vector2';\nimport { getId, compact, intersection } from '../lib/utils';\nimport Intersection from '../network/networkNodes/Intersection';\n\ntype TriangleGeom = [Vector2, Vector2, Vector2];\ntype IntermediateTriangle = {\n  id: string;\n  points: TriangleGeom;\n};\n\nexport type TriangleNeighbour = {\n  triangle: Triangle;\n  sharedPoints: [Vector2, Vector2];\n};\nexport type Triangle = {\n  id: string;\n  center: Vector2;\n  points: TriangleGeom;\n  neighbours: TriangleNeighbour[];\n  ix: number;\n  iy: number;\n};\n\nexport default function createTriangleGrid(\n  tileSize: number,\n  width: number,\n  height: number,\n): Map<string, Triangle> {\n  const tileHeight = (tileSize * Math.sqrt(3)) / 2;\n  const points: Vector2[][] = [];\n  const trianglePoints: IntermediateTriangle[][] = [];\n  for (let iy = 0; iy * tileHeight < height + tileHeight; iy++) {\n    const pointRow: Vector2[] = [];\n    points.push(pointRow);\n    const triangleRow: IntermediateTriangle[] = [];\n    trianglePoints.push(triangleRow);\n    for (let ix = 0; ix * tileSize < width + tileSize; ix++) {\n      const xOffset = iy % 2 === 0 ? -tileSize / 2 : 0;\n      const point = new Vector2(ix * tileSize + xOffset, iy * tileHeight);\n      pointRow.push(point);\n\n      if (iy !== 0 && ix !== 0) {\n        if (iy % 2 === 0) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix - 1]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix - 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        } else if (points[iy - 1][ix + 1]) {\n          const triangle1: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy][ix - 1], points[iy - 1][ix]],\n          };\n          const triangle2: IntermediateTriangle = {\n            id: getId('triangle'),\n            points: [point, points[iy - 1][ix + 1], points[iy - 1][ix]],\n          };\n          triangleRow.push(triangle1, triangle2);\n        }\n      }\n    }\n  }\n\n  const trianglesById = new Map<string, Triangle>();\n  for (let iy = 0; iy < trianglePoints.length; iy++) {\n    for (let ix = 0; ix < trianglePoints[iy].length; ix++) {\n      const triangle = trianglePoints[iy][ix];\n      const center = Vector2.average(triangle.points);\n\n      const neighbours = compact(\n        ix % 2 === 0\n          ? iy % 2 === 0\n            ? [\n                // 2,2\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix - 1],\n              ]\n            : [\n                // 2,3\n                trianglePoints[iy]?.[ix - 1],\n                trianglePoints[iy]?.[ix + 1],\n                trianglePoints[iy + 1]?.[ix + 1],\n              ]\n          : iy % 2 === 0\n          ? [\n              // 3,2\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix - 1],\n            ]\n          : [\n              //3,3\n              trianglePoints[iy]?.[ix - 1],\n              trianglePoints[iy]?.[ix + 1],\n              trianglePoints[iy - 1]?.[ix + 1],\n            ],\n      );\n\n      const fullTriangle = triangle as Triangle;\n      fullTriangle.center = center;\n      fullTriangle.neighbours = neighbours.map(neighbourTriangle => ({\n        triangle: neighbourTriangle,\n        sharedPoints: intersection(triangle.points, neighbourTriangle.points),\n      })) as TriangleNeighbour[];\n      fullTriangle.ix = ix;\n      fullTriangle.iy = iy;\n\n      trianglesById.set(fullTriangle.id, fullTriangle);\n    }\n  }\n\n  return trianglesById;\n}\n"],"names":["$f2b3fa9969eed8fe$export$45ca8e7f50ccf2e0","a","b","n","$f2b3fa9969eed8fe$export$da08e9e4ef153133","Math","random","$f2b3fa9969eed8fe$export$77d84a253d94711e","arr","floor","length","$f2b3fa9969eed8fe$export$863a417fd46116e4","a1","a2","a1Items","Set","result","item","has","add","Array","from","$f2b3fa9969eed8fe$export$b52d3027a78bd277","prefix","toString","slice","$b33d7521dbc247e4$export$9099ad97b570f7c","angle","radius","cos","sin","points","reduce","memo","p","ZERO","div","x","y","this","magnitudeSquared","magnitude","sqrt","atan2","isInPolygon","polygon","isInside","currentIdx","previousIdx","currentX","currentY","previousX","previousY","equals","other","distanceTo","dx","dy","angleTo","sub","angleBetween","min","max","size","$f2b3fa9969eed8fe$export$412d6621f9b9540a","PI","dot","scale","negate","ceil","round","withMagnitude","newMagnitude","fromPolar","normalize","withAngle","newAngle","rotate","byAngle","lerp","$4e69c769edcf1c3b$var$LABEL_OFFSET","$4e69c769edcf1c3b$var$DEBUG_ARROW_ANGLE","$7786eff09e1e579b$export$4d41f66daf6338dc","document","createElement","$7786eff09e1e579b$export$a4ecf2d011151542","getContext","$7786eff09e1e579b$export$b7952bcb5d125510","body","clientWidth","$7786eff09e1e579b$export$5e9f82a2cb459528","clientHeight","$7786eff09e1e579b$export$8f869025bba9609b","window","devicePixelRatio","width","height","style","$7786eff09e1e579b$export$dd37cca076be4c97","clear","fill","applyFillOptions","ctx","fillRect","canvas","clearRect","beginPath","moveTo","lineTo","arc","startAngle","endAngle","anticlockwise","arcTo","p1","p2","applyStrokeOptions","strokeWidth","stroke","strokeCap","strokeDash","strokeDashOffset","strokeJoin","lineWidth","strokeStyle","lineCap","setLineDash","lineDashOffset","lineJoin","options","fillStyle","applyStrokeAndFillOptions","strokeAndFill","getDebugStrokeOptions","color","debugStroke","fillText","text","position","circle","center","ellipse","radiusX","radiusY","debugLabel","label","debugPointX","debugPointO","debugArrow","start","end","average","vector","arrowLeftPoint","arrowRightPoint","debugVectorAtPoint","base","point","polyLine","i","debugPolygon","debugPolyLine","aabb","opts","debug","origin","rect","left","top","$25418d05f9b26617$export$b8795f4f643ce74f","value","message","Error","$25418d05f9b26617$export$62d771998a1345d1","appendChild","$27635e3ca1163c19$export$be5a783879320ec3","$parcel$interopDefault","$11cc8","$27635e3ca1163c19$export$9de115b64c1e7807","$dd70de2e6870e1ce$var$ARC_LENGTH","$dd70de2e6870e1ce$var$trianglesById","tileSize","tileHeight","trianglePoints","iy","pointRow","push","triangleRow","ix","triangle1","id","triangle2","trianglesById","Map","iy1","ref","ref1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","ref10","ref11","triangle","neighbours","filter","fullTriangle","map","neighbourTriangle","sharedPoints","set","$d8388b0338e164d4$export$9099ad97b570f7c","$dd70de2e6870e1ce$var$makeColorPalette","palette","fn","$f2b3fa9969eed8fe$export$6d93b59e0635649d","string","current","next","reset","idx","$dd70de2e6870e1ce$var$getSharedPoints","neighbour","find","$dd70de2e6870e1ce$var$occupied","$dd70de2e6870e1ce$var$makeSnake","triangles","values","availableNeighbours","speed","offset","isDead","$dd70de2e6870e1ce$var$snakes","si","cb","shouldCancel","cancel","Promise","resolve","requestAnimationFrame","time","$f2b3fa9969eed8fe$export$a1aa52cbcd20b120","snake","unshift","lastTriangle","delete","last","currentColor","nextColor","$dd70de2e6870e1ce$var$TILE_SIZE"],"version":3,"file":"index.be31d43a.js.map"}