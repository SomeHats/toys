import{f as w,e as g,g as E,k as M,v as P,c as S,n as k,l as x}from"./chunk_assert.7befa3b2.js";const a={ok(r){return new j(r)},error(r){return new A(r)},collect(r){const t=[];for(const e of r)if(e.isOk())t.push(e.value);else return e;return a.ok(t)}};class ${constructor(){}}class j extends ${constructor(t){super(),this.value=t}isOk(){return!0}isError(){return!1}unwrap(){return this.value}unwrapError(t){w(`${t!=null?t:"expected error"}: ${String(this.value)}`)}map(t){return a.ok(t(this.value))}mapErr(t){return this}andThen(t){return t(this.value)}}class A extends ${constructor(t){super(),this.error=t}isOk(){return!1}isError(){return!0}unwrap(t){if(this.error instanceof Error)throw this.error;w(`${t!=null?t:"expected value"}: ${String(this.error)}`)}unwrapError(t){return this.error}map(t){return this}mapErr(t){return a.error(t(this.error))}andThen(t){return this}}class c{constructor(t,e=[]){this.message=t,this.path=e}formatPath(){if(!this.path.length)return null;let t="";for(const e of this.path)typeof e=="number"?t+=`[${e}]`:t+=`.${e}`;return t}toString(){const t=this.formatPath(),e=this.message.split(`
`).map((n,s)=>s===0?n:`  ${n}`).join(`
`);return t?`At ${t}: ${e}`:e}}function d(r){return t=>typeof t===r?a.ok(t):a.error(new c(`Expected ${r}, got ${typeof t}`,[]))}function p(r,t){return new c(r.message,[t,...r.path])}function f(r){if(r===null)return"null";if(Array.isArray(r))return"an array";const t=typeof r;switch(t){case"bigint":case"boolean":case"function":case"number":case"string":case"symbol":return`a ${t}`;case"object":return`an ${t}`;case"undefined":return"undefined";default:S(t)}}const q=d("string"),m=d("number"),N=d("boolean");function T(r){return r==null?a.ok(null):a.error(new c(`Expected null or undefined, got ${f(r)}`))}function X(r){return t=>Array.isArray(t)?a.collect(t.map((e,n)=>r(e).mapErr(s=>p(s,n)))):a.error(new c(`Expected Array, got ${f(t)}`,[]))}function O(r){return t=>typeof t!="object"||t===null?a.error(new c(`Expected object, got ${f(t)}`,[])):a.collect(g(r).map(([e,n])=>n(E(t,e)).map(s=>[e,s]).mapErr(s=>p(s,e)))).map(e=>Object.fromEntries(e))}function Y(r,t){return e=>typeof e!="object"||e===null?a.error(new c(`Expected object, got ${f(e)}`,[])):a.collect(M(e).map(n=>r(n).andThen(s=>t(E(e,s)).map(i=>[s,i])).mapErr(s=>p(s,n)))).map(n=>Object.fromEntries(n))}function B(r){const t=new Set(Array.isArray(r)?r:P(r));return e=>{if(t.has(e))return a.ok(e);{const n=typeof e=="string"?`"${e}"`:typeof e=="boolean"||typeof e=="number"?String(e):f(e),s=Array.from(t,i=>typeof i=="string"?`"${i}"`:`${i}`).join(" or ");return a.error(new c(`Expected ${s}, got ${n}`))}}}function v(r){const t=g(r);return e=>{const n=[];for(const[s,i]of t){const u=i(e);if(u.isOk())return u;n.push(`- ${s}: ${u.error.toString()}`)}return a.error(new c(`Expected one of the following to pass, but all errored:
${n.join(`
`)}`))}}function V(r,t){return e=>r(e).andThen(t)}function F(r){return v({value:r,null:T})}const R=O({x:m,y:m}),o=class{constructor(r,t){this.x=r,this.y=t}static fromPolar(r,t){return new o(t*Math.cos(r),t*Math.sin(r))}static average(r){return r.reduce((e,n)=>e.add(n),o.ZERO).div(r.length)}static fromVectorLike({x:r,y:t}){return new o(r,t)}static fromEvent({clientX:r,clientY:t}){return new o(r,t)}toString(r){return`Vector2(${r==null?this.x:this.x.toFixed(r)}, ${r==null?this.y:this.y.toFixed(r)})`}serialize(){return{x:this.x,y:this.y}}get magnitudeSquared(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.magnitudeSquared)}get angle(){return Math.atan2(this.y,this.x)}isInPolygon(r){const{x:t,y:e}=this;let n=!1;for(let s=0,i=r.length-1;s<r.length;i=s++){const{x:u,y:l}=r[s],{x:b,y}=r[i];l>e!=y>e&&t<(b-u)*(e-l)/(y-l)+u&&(n=!n)}return n}equals(r){return this===r||this.x===r.x&&this.y===r.y}distanceTo({x:r,y:t}){return Math.hypot(this.x-r,this.y-t)}distanceToSq({x:r,y:t}){const e=this.x-r,n=this.y-t;return e*e+n*n}angleTo(r){return r.sub(this).angle}angleBetween(r){return k(Math.atan2(r.y,r.x)-Math.atan2(this.y,this.x))}dot(r){return this.x*r.x+this.y*r.y}div(r){return new o(this.x/r,this.y/r)}scale(r){return new o(this.x*r,this.y*r)}negate(){return this.scale(-1)}add({x:r,y:t}){return new o(this.x+r,this.y+t)}sub({x:r,y:t}){return new o(this.x-r,this.y-t)}floor(){return new o(Math.floor(this.x),Math.floor(this.y))}ceil(){return new o(Math.ceil(this.x),Math.ceil(this.y))}round(){return new o(Math.round(this.x),Math.round(this.y))}withMagnitude(r){return o.fromPolar(this.angle,r)}normalize(){return this.withMagnitude(1)}withAngle(r){return o.fromPolar(r,this.magnitude)}rotate(r){return this.withAngle(this.angle+r)}rotateAround(r,t){const e=Math.sin(t),n=Math.cos(t),s=this.x-r.x,i=this.y-r.y,u=s*n-i*e,l=s*e+i*n;return new o(u+r.x,l+r.y)}lerp(r,t){return new o(x(this.x,r.x,t),x(this.y,r.y,t))}perpendicular(){return new o(this.y,-this.x)}project(r,t){return r.scale(t).add(this)}};let h=o;h.ZERO=new o(0,0);h.UNIT=new o(1,1);h.X=new o(1,0);h.Y=new o(0,1);h.deserialize=o.fromVectorLike;h.parse=V(R,r=>a.ok(o.deserialize(r)));export{c as P,a as R,h as V,X as a,V as b,O as c,q as d,F as e,Y as f,B as g,R as h,N as i,m as p};
