var j=Object.defineProperty;var H=(t,e,r)=>e in t?j(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var i=(t,e,r)=>(H(t,typeof e!="symbol"?e+"":e,r),r);import{R as m,r as _}from"./chunk_index.0b9c6f54.js";var R=8,T=class{constructor(){i(this,"arraySize",0);i(this,"array",Array(R));i(this,"set",null)}get isEmpty(){if(this.array)return this.arraySize===0;if(this.set)return this.set.size===0;throw new Error("no set or array")}add(t){if(this.array)return this.array.indexOf(t)!==-1?!1:this.arraySize<R?(this.array[this.arraySize]=t,this.arraySize++,!0):(this.set=new Set(this.array),this.array=null,this.set.add(t),!0);if(this.set)return this.set.has(t)?!1:(this.set.add(t),!0);throw new Error("no set or array")}remove(t){if(this.array){const e=this.array.indexOf(t);return e===-1?!1:(this.array[e]=void 0,this.arraySize--,e!==this.arraySize&&(this.array[e]=this.array[this.arraySize],this.array[this.arraySize]=void 0),!0)}if(this.set)return this.set.has(t)?(this.set.delete(t),!0):!1;throw new Error("no set or array")}visit(t){if(this.array){for(let e=0;e<this.arraySize;e++){const r=this.array[e];typeof r<"u"&&t(r)}return}if(this.set){this.set.forEach(t);return}throw new Error("no set or array")}};function D(t){return t&&typeof t=="object"&&"parents"in t}function B(t){for(let e=0,r=t.parents.length;e<r;e++)if(t.parents[e].__unsafe__getWithoutCapture(),t.parents[e].lastChangedEpoch!==t.parentEpochs[e])return!0;return!1}var E=(t,e)=>{if(t.children.remove(e)&&t.children.isEmpty&&D(t))for(let r=0,s=t.parents.length;r<s;r++)E(t.parents[r],t)},C=(t,e)=>{if(t.children.add(e)&&D(t))for(let r=0,s=t.parents.length;r<s;r++)C(t.parents[r],t)};function q(t,e){return t===e||Object.is(t,e)||!!(t&&e&&typeof t.equals=="function"&&t.equals(e))}var z=Object.freeze([]),A=Symbol.for("__signia__"),x=globalThis;x[A]?console.error('Multiple versions of signia detected. This will cause unexpected behavior. Please add "resolutions" (yarn/pnpm) or "overrides" (npm) in your package.json to ensure only one version of signia is loaded.'):x[A]=!0;var $=class{constructor(t,e){i(this,"offset",0);i(this,"numNewParents",0);i(this,"maybeRemoved");this.below=t,this.child=e}},a=null;function k(t){a=new $(a,t)}function O(){const t=a;if(a=t.below,t.numNewParents>0||t.offset!==t.child.parents.length){for(let r=t.offset;r<t.child.parents.length;r++){const s=t.child.parents[r];t.child.parents.indexOf(s)>=t.offset&&E(s,t.child)}if(t.child.parents.length=t.offset,t.child.parentEpochs.length=t.offset,a!=null&&a.maybeRemoved)for(let r=0;r<a.maybeRemoved.length;r++){const s=a.maybeRemoved[r];t.child.parents.indexOf(s)===-1&&E(s,t.child)}}}function w(t){if(a){const e=a.child.parents.indexOf(t);if(e<0&&(a.numNewParents++,a.child.isActivelyListening&&C(t,a.child)),e<0||e>=a.offset){if(e!==a.offset&&e>0){const r=a.child.parents[a.offset];a.maybeRemoved?a.maybeRemoved.indexOf(r)===-1&&a.maybeRemoved.push(r):a.maybeRemoved=[r]}a.child.parents[a.offset]=t,a.child.parentEpochs[a.offset]=t.lastChangedEpoch,a.offset++}}}var d=Symbol("RESET_VALUE"),V=class{constructor(t){i(this,"index",0);i(this,"buffer");this.capacity=t,this.buffer=new Array(t)}pushEntry(t,e,r){if(r!==void 0){if(r===d){this.clear();return}this.buffer[this.index]=[t,e,r],this.index=(this.index+1)%this.capacity}}clear(){this.index=0,this.buffer.fill(void 0)}getChangesSince(t){const{index:e,capacity:r,buffer:s}=this;for(let n=0;n<r;n++){const f=(e-1+r-n)%r,c=s[f];if(!c)return d;const[p,y]=c;if(n===0&&t>=y)return[];if(p<=t&&t<y){const v=n+1,l=new Array(v);for(let g=0;g<v;g++)l[g]=s[(f+g)%r][2];return l}}return d}},o=-1,h=o+1,b=!1;function U(){h++}var Y=class{constructor(t){i(this,"initialAtomValues",new Map);this.parent=t}get isRoot(){return this.parent===null}commit(){if(this.isRoot){const t=this.initialAtomValues;this.initialAtomValues=new Map,I(t.keys())}else this.initialAtomValues.forEach((t,e)=>{this.parent.initialAtomValues.has(e)||this.parent.initialAtomValues.set(e,t)})}abort(){h++,this.initialAtomValues.forEach((t,e)=>{var r;e.set(t),(r=e.historyBuffer)==null||r.clear()}),this.commit()}};function I(t){if(b)throw new Error("cannot change atoms during reaction cycle");try{b=!0;const e=new Set,r=s=>{s.lastTraversedEpoch!==h&&(s.lastTraversedEpoch=h,"maybeScheduleEffect"in s?e.add(s):s.children.visit(r))};for(const s of t)s.children.visit(r);for(const s of e)s.maybeScheduleEffect()}finally{b=!1}}function Z(t,e){u?u.initialAtomValues.has(t)||u.initialAtomValues.set(t,e):I([t])}var u=null;function F(t){const e=new Y(u);u=e;try{let r=!1;const s=t(()=>r=!0);return r?e.abort():e.commit(),s}catch(r){throw e.abort(),r}finally{u=u.parent}}function et(t){return u?t():F(t)}var G=class{constructor(t,e,r){i(this,"isEqual");i(this,"computeDiff");i(this,"lastChangedEpoch",h);i(this,"children",new T);i(this,"historyBuffer");this.name=t,this.current=e,this.isEqual=(r==null?void 0:r.isEqual)??null,r&&(r.historyLength&&(this.historyBuffer=new V(r.historyLength)),this.computeDiff=r.computeDiff)}__unsafe__getWithoutCapture(){return this.current}get value(){return w(this),this.current}set(t,e){var s,n;if(((s=this.isEqual)==null?void 0:s.call(this,this.current,t))??q(this.current,t))return this.current;U(),this.historyBuffer&&this.historyBuffer.pushEntry(this.lastChangedEpoch,h,e??((n=this.computeDiff)==null?void 0:n.call(this,this.current,t,this.lastChangedEpoch,h))??d),this.lastChangedEpoch=h;const r=this.current;return this.current=t,Z(this,r),t}update(t){return this.set(t(this.current))}getDiffSince(t){var e;return w(this),t>=this.lastChangedEpoch?z:((e=this.historyBuffer)==null?void 0:e.getChangesSince(t))??d}};function rt(t,e,r){return new G(t,e,r)}var N=Symbol("UNINITIALIZED"),st=t=>t===N,S=class{constructor(t,e){this.value=t,this.diff=e}};function it(t,e){return new S(t,e)}var M=class{constructor(t,e,r){i(this,"lastChangedEpoch",o);i(this,"lastTraversedEpoch",o);i(this,"lastCheckedEpoch",o);i(this,"parents",[]);i(this,"parentEpochs",[]);i(this,"children",new T);i(this,"historyBuffer");i(this,"state",N);i(this,"computeDiff");i(this,"isEqual");this.name=t,this.derive=e,r!=null&&r.historyLength&&(this.historyBuffer=new V(r.historyLength)),this.computeDiff=r==null?void 0:r.computeDiff,this.isEqual=(r==null?void 0:r.isEqual)??null}get isActivelyListening(){return!this.children.isEmpty}__unsafe__getWithoutCapture(){var e,r;const t=this.lastChangedEpoch===o;if(!t&&(this.lastCheckedEpoch===h||!B(this)))return this.lastCheckedEpoch=h,this.state;try{k(this);const s=this.derive(this.state,this.lastCheckedEpoch),n=s instanceof S?s.value:s;if(!(((e=this.isEqual)==null?void 0:e.call(this,n,this.state))??q(n,this.state))){if(this.historyBuffer&&!t){const f=s instanceof S?s.diff:void 0;this.historyBuffer.pushEntry(this.lastChangedEpoch,h,f??((r=this.computeDiff)==null?void 0:r.call(this,this.state,n,this.lastCheckedEpoch,h))??d)}this.lastChangedEpoch=h,this.state=n}return this.lastCheckedEpoch=h,this.state}finally{O()}}get value(){const t=this.__unsafe__getWithoutCapture();return w(this),t}getDiffSince(t){var e;return this.value,t>=this.lastChangedEpoch?z:((e=this.historyBuffer)==null?void 0:e.getChangesSince(t))??d}};function L(t={},e,r,s){const n=s.get,f=Symbol.for("__signia__computed__"+r);return s.get=function(){let c=this[f];return c||(c=new M(r,n.bind(this),t),Object.defineProperty(this,f,{enumerable:!1,configurable:!1,writable:!1,value:c})),c.value},s}function at(){if(arguments.length===1){const t=arguments[0];return(e,r,s)=>L(t,e,r,s)}else return typeof arguments[0]=="string"?new M(arguments[0],arguments[1],arguments[2]):L(void 0,arguments[0],arguments[1],arguments[2])}var W=class{constructor(t,e,r){i(this,"_isActivelyListening",!1);i(this,"lastTraversedEpoch",o);i(this,"lastReactedEpoch",o);i(this,"_scheduleCount",0);i(this,"parentEpochs",[]);i(this,"parents",[]);i(this,"_scheduleEffect");i(this,"maybeExecute",()=>{this._isActivelyListening&&this.execute()});this.name=t,this.runEffect=e,this._scheduleEffect=r==null?void 0:r.scheduleEffect}get isActivelyListening(){return this._isActivelyListening}get scheduleCount(){return this._scheduleCount}maybeScheduleEffect(){if(this._isActivelyListening&&this.lastReactedEpoch!==h){if(this.parents.length&&!B(this)){this.lastReactedEpoch=h;return}this.scheduleEffect()}}scheduleEffect(){this._scheduleCount++,this._scheduleEffect?this._scheduleEffect(this.maybeExecute):this.execute()}attach(){this._isActivelyListening=!0;for(let t=0,e=this.parents.length;t<e;t++)C(this.parents[t],this)}detach(){this._isActivelyListening=!1;for(let t=0,e=this.parents.length;t<e;t++)E(this.parents[t],this)}execute(){try{k(this);const t=this.runEffect(this.lastReactedEpoch);return this.lastReactedEpoch=h,t}finally{O()}}};function nt(t,e,r){const s=new W(t,e,r);return s.attach(),s.scheduleEffect(),()=>{s.detach()}}function K(t,e){const r=m.useRef(e);r.current=e;const[s,n,f]=m.useMemo(()=>{let c=null;const p=l=>(c=l,()=>{c=null}),y=new W(`useStateTracking(${t})`,()=>{var l;return(l=r.current)==null?void 0:l.call(r)},{scheduleEffect(){c==null||c()}});return[y,p,()=>y.scheduleCount]},[t]);return m.useSyncExternalStore(n,f,f),m.useEffect(()=>(s.attach(),s.maybeScheduleEffect(),()=>{s.detach()}),[s]),s.execute()}var P={apply(t,e,r){return K(t.displayName??t.name??"tracked(???)",()=>t.apply(e,r))}},J=Symbol.for("react.memo"),Q=Symbol.for("react.forward_ref");function ht(t){let e=null;const r=t.$$typeof;return r===J&&(t=t.type,e=t.compare),r===Q?_.memo(_.forwardRef(new Proxy(t.render,P))):_.memo(new Proxy(t,P),e)}export{d as R,rt as a,ht as b,at as c,st as i,nt as r,et as t,it as w};
