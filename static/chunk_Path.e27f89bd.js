import{z as u,a as l,C as P}from"./chunk_assert.6e3d4d7d.js";import{L as d,C as L}from"./chunk_Circle.c946af55.js";import{S as h,C as w}from"./chunk_CirclePathSegment.9a8e7a13.js";class c{constructor(...t){this.segments=[],this.addSegments(...t)}static straightThroughPoints(...t){let[e,...r]=t;const n=new c;for(const o of r)n.addSegment(new h(e,o)),e=o;return n}static segmentAcrossCircle(t,e,r){e=e+Math.PI;const n=t.pointOnCircumference(e),o=t.pointOnCircumference(r),i=new d(t.center,n).perpendicularLineThroughPoint(n),s=new d(t.center,o).perpendicularLineThroughPoint(o);if(i.isParallelTo(s))return new h(n,o);const a=i.pointAtIntersectionWith(s),g=n.distanceTo(a);return new w(a,g,n.sub(a).angle(),o.sub(a).angle())}getStart(){return this.segments[0].getStart()}getEnd(){return this.segments[this.segments.length-1].getEnd()}getLength(){return this.segments.reduce((t,e)=>t+e.getLength(),0)}getPointAtPosition(t){const e=u(0,this.getLength(),t);let r=0;for(const n of this.segments){if(e<=r+n.getLength())return n.getPointAtPosition(e-r);r+=n.getLength()}throw new Error("this is supposed to be unreachable oops")}getAngleAtPosition(t){const e=u(0,this.getLength(),t);let r=0;for(const n of this.segments){if(e<=r+n.getLength())return n.getAngleAtPosition(e-r);r+=n.getLength()}throw new Error("this is supposed to be unreachable oops")}addSegment(t){const e=this.segments[this.segments.length-1];return e&&l(e.getEnd().equals(t.getStart()),`segments must neatly join together - ${e.getEnd().toString()} !== ${t.getStart().toString()}`),this.segments.push(t),this}addSegments(...t){return t.forEach(e=>this.addSegment(e)),this}autoRound(t){const e=this.segments.map((s,a)=>{const g=a===0?null:this.segments[a-1];if(!g)return s instanceof h?null:s;if(!(s instanceof h))return s;if(!(g instanceof h))return null;l(g.getEnd().equals(s.getStart()),"segments must join");const m=g.angle(),S=s.angle(),f=Math.min(t,g.getLength()/2,s.getLength()/2),p=L.create(s.getStart().x,s.getStart().y,f);return c.segmentAcrossCircle(p,m,S)}),r=P(e),n=this.getStart(),o=this.getEnd();let i=n;return this.segments=[],r.forEach(s=>{s.getStart().equals(i)?this.addSegment(s):(this.addSegment(new h(i,s.getStart())),this.addSegment(s)),i=s.getEnd()}),i.equals(o)||this.addSegment(new h(i,o)),this}}export{c as P};
