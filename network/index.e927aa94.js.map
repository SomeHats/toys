{"mappings":"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","sources":["src/lib/scene/SceneObject.ts","src/lib/easings.ts","src/network/effects/Pulse.ts","src/network/colors.ts","src/network/ConnectionDirection.ts","src/network/ConnectionSet.ts","src/network/networkNodes/Consumer.ts","src/lib/scene/SceneSystem.ts","src/lib/QuadTree.ts","src/network/TravellerFinder.ts","src/network/PathFinder.ts","src/network/networkNodes/Intersection.ts","src/lib/scene/SortOrderProvider.ts","src/lib/scene/Entity.ts","src/network/Traveller.ts","src/pals/makePal.ts","src/lib/geom/Path.ts","src/network/Junction.ts","src/network/Road.ts","src/network/networkNodes/Producer.ts","src/network/network-main.ts","src/lib/scene/Scene.ts"],"sourcesContent":["import { assert } from '../assert';\nimport Scene from './Scene';\n\nconst constructorIdCounts = {} as Record<string, number>;\n\nconst getNextCount = (name: string): string => {\n  if (!constructorIdCounts[name]) constructorIdCounts[name] = 0;\n  return `${name}@${constructorIdCounts[name]++}`;\n};\n\nexport default abstract class SceneObject {\n  id: string = getNextCount(this.constructor.name);\n  private scene: Scene | null = null;\n\n  hasScene(): boolean {\n    return this.scene !== null;\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene must be present');\n    return this.scene;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {}\n  update(delta: number): void {}\n\n  addTo(scene: Scene): this {\n    scene.addChild(this);\n    return this;\n  }\n\n  onAddedToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  onRemovedFromScene() {\n    this.scene = null;\n  }\n\n  getSortOrder(): number {\n    return 0;\n  }\n}\n","import { approxEq } from './utils';\n\n/** n should be between 0 and 1 */\nexport type Easing = (n: number) => number;\n\n// based on https://github.com/servo/servo/blob/0d0cfd030347ab0711b3c0607a9ee07ffe7124cf/components/style/bezier.rs\nclass UnitBezier {\n  private static readonly NEWTON_METHOD_ITERATIONS = 8;\n  private static readonly DEFAULT_EPSILON = 1e-6;\n  private readonly ax: number;\n  private readonly bx: number;\n  private readonly cx: number;\n  private readonly ay: number;\n  private readonly by: number;\n  private readonly cy: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    const cx = 3 * x1;\n    const bx = 3 * (x2 - x1) - cx;\n\n    const cy = 3 * y1;\n    const by = 3 * (y2 - y1) - cy;\n\n    this.ax = 1.0 - cx - bx;\n    this.bx = bx;\n    this.cx = cx;\n    this.ay = 1.0 - cy - by;\n    this.by = by;\n    this.cy = cy;\n  }\n\n  private sampleCurveX(t: number): number {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }\n\n  private sampleCurveY(t: number): number {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }\n\n  private sampleCurveDerivativeX(t: number): number {\n    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n  }\n\n  private solveCurveX(x: number, epsilon: number): number {\n    // Fast path: Use Newton's method.\n    let t = x;\n    for (let i = 0; i < UnitBezier.NEWTON_METHOD_ITERATIONS; i++) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      let dx = this.sampleCurveDerivativeX(t);\n      if (approxEq(dx, 0.0, 1e-6)) {\n        break;\n      }\n      t -= (x2 - x) / dx;\n    }\n\n    // Slow path: Use bisection.\n    let lo = 0;\n    let hi = 1;\n    t = x;\n\n    if (t < lo) {\n      return lo;\n    }\n    if (t > hi) {\n      return hi;\n    }\n\n    while (lo < hi) {\n      let x2 = this.sampleCurveX(t);\n      if (approxEq(x2, x, epsilon)) {\n        return t;\n      }\n      if (x > x2) {\n        lo = t;\n      } else {\n        hi = t;\n      }\n      t = (hi - lo) / 2.0 + lo;\n    }\n\n    return t;\n  }\n\n  solve(x: number, epsilon: number = UnitBezier.DEFAULT_EPSILON): number {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n  }\n}\n\nexport const cubicBezier = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): Easing => {\n  const bezier = new UnitBezier(x1, y1, x2, y2);\n  return (x) => bezier.solve(x);\n};\n\n/**\n * P(t) = (1-t)^3*P0 + 3*t*(1-t)^2*P1 + 3*t^2*(1-t)*P2 + t^3*P3\n * x = 3*t*(1-t)^2*p1x + 3*t^2*(1-t)*p2x + t^3\n * y(t) = 3*t*(1-t)^2*p1y + 3*t^2*(1-t)*p2y + t^3\n *\n *\n * y = 3*u1*(1-x)^2*x + 3*u2*(1-x)*x^2 + x^3\n */\n\n// https://gist.github.com/rezoner/713615dabedb59a15470\n// http://gsgd.co.uk/sandbox/jquery/easing/\nexport const reverse =\n  (easing: (n: number) => number) =>\n  (n: number): number =>\n    easing(1 - n);\n\nexport const linear = (n: number): number => n;\n\nexport const inQuad = (t: number): number => t * t;\n\nexport const outQuad = (t: number): number => t * (2 - t);\n\nexport const inOutQuad = (t: number): number =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\nexport const inCubic = (t: number): number => t * t * t;\n\nexport const outCubic = (t: number): number => --t * t * t + 1;\n\nexport const inOutCubic = (t: number): number =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nexport const inQuart = (t: number): number => t * t * t * t;\n\nexport const outQuart = (t: number): number => 1 - --t * t * t * t;\n\nexport const inOutQuart = (t: number): number =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\nexport const inQuint = (t: number): number => t * t * t * t * t;\n\nexport const outQuint = (t: number): number => 1 + --t * t * t * t * t;\n\nexport const inOutQuint = (t: number): number =>\n  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nexport const inSine = (t: number): number =>\n  -1 * Math.cos((t / 1) * (Math.PI * 0.5)) + 1;\n\nexport const outSine = (t: number): number =>\n  Math.sin((t / 1) * (Math.PI * 0.5));\n\nexport const inOutSine = (t: number): number =>\n  (-1 / 2) * (Math.cos(Math.PI * t) - 1);\n\nexport const inExpo = (t: number): number =>\n  t == 0 ? 0 : Math.pow(2, 10 * (t - 1));\n\nexport const outExpo = (t: number): number =>\n  t == 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n\nexport const inOutExpo = (t: number): number => {\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if ((t /= 1 / 2) < 1) return (1 / 2) * Math.pow(2, 10 * (t - 1));\n  return (1 / 2) * (-Math.pow(2, -10 * --t) + 2);\n};\n\nexport const inCirc = (t: number): number => -1 * (Math.sqrt(1 - t * t) - 1);\n\nexport const outCirc = (t: number): number => Math.sqrt(1 - (t = t - 1) * t);\n\nexport const inOutCirc = (t: number): number => {\n  if ((t /= 1 / 2) < 1) return (-1 / 2) * (Math.sqrt(1 - t * t) - 1);\n  return (1 / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1);\n};\n\nexport const inElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return -(\n    a *\n    Math.pow(2, 10 * (t -= 1)) *\n    Math.sin(((t - s) * (2 * Math.PI)) / p)\n  );\n};\n\nexport const outElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if (t == 1) return 1;\n  if (!p) p = 0.3;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  return a * Math.pow(2, -10 * t) * Math.sin(((t - s) * (2 * Math.PI)) / p) + 1;\n};\n\nexport const inOutElastic = (t: number): number => {\n  let s = 1.70158;\n  let p = 0;\n  let a = 1;\n  if (t == 0) return 0;\n  if ((t /= 1 / 2) == 2) return 1;\n  if (!p) p = 0.3 * 1.5;\n  if (a < 1) {\n    a = 1;\n    s = p / 4;\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(1 / a);\n  }\n  if (t < 1)\n    return (\n      -0.5 *\n      (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p))\n    );\n  return (\n    a *\n      Math.pow(2, -10 * (t -= 1)) *\n      Math.sin(((t - s) * (2 * Math.PI)) / p) *\n      0.5 +\n    1\n  );\n};\n\nexport const inBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    return 1 * t * t * ((s + 1) * t - s);\n  };\n\nexport const outBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    t = t - 1;\n    return 1 * (t * t * ((s + 1) * t + s) + 1);\n  };\n\nexport const inOutBack =\n  (s: number = 1.70158) =>\n  (t: number): number => {\n    if ((t /= 1 / 2) < 1)\n      return (1 / 2) * (t * t * (((s *= 1.525) + 1) * t - s));\n    return (1 / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  };\n\nexport const inBounce = (t: number): number => {\n  return 1 - outBounce(1 - t);\n};\n\nexport const outBounce = (t: number): number => {\n  if ((t /= 1) < 1 / 2.75) {\n    return 7.5625 * t * t;\n  } else if (t < 2 / 2.75) {\n    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n  } else if (t < 2.5 / 2.75) {\n    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n  } else {\n    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n  }\n};\n\nexport const inOutBounce = (t: number): number => {\n  if (t < 1 / 2) return inBounce(t * 2) * 0.5;\n  return outBounce(t * 2 - 1) * 0.5 + 0.5;\n};\n","import Color from 'color';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport Circle from '../../lib/geom/Circle';\nimport { linear, Easing } from '../../lib/easings';\nimport { lerp } from '../../lib/utils';\n\ntype PulseOptions = {\n  x: number;\n  y: number;\n  startRadius: number;\n  endRadius: number;\n  duration: number;\n  color: Color;\n  easeRadius?: Easing;\n  easeOpacity?: Easing;\n  removeOnComplete?: boolean;\n};\n\nexport default class Pulse extends SceneObject {\n  _circle: Circle;\n  _startRadius: number;\n  _endRadius: number;\n  _duration: number;\n  _color: Color;\n  _progress: number;\n  _easeRadius: Easing;\n  _easeOpacity: Easing;\n  _removeOnComplete: boolean;\n\n  constructor({\n    x,\n    y,\n    startRadius,\n    endRadius,\n    duration,\n    color,\n    easeRadius = linear,\n    easeOpacity = linear,\n    removeOnComplete = false,\n  }: PulseOptions) {\n    super();\n    this._circle = Circle.create(x, y, startRadius);\n    this._startRadius = startRadius;\n    this._endRadius = endRadius;\n    this._duration = duration;\n    this._color = color;\n    this._progress = 0;\n    this._easeRadius = easeRadius;\n    this._easeOpacity = easeOpacity;\n    this._removeOnComplete = removeOnComplete;\n  }\n\n  update(deltaTime: number) {\n    const deltaProgress = deltaTime / this._duration;\n    this._progress = Math.min(1, this._progress + deltaProgress);\n    this._circle = this._circle.withRadius(\n      lerp(\n        this._startRadius,\n        this._endRadius,\n        this._easeRadius(this._progress),\n      ),\n    );\n\n    if (this._progress === 1 && this._removeOnComplete) {\n      this.getScene().removeChild(this);\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    const opacity = this._easeOpacity(this._progress);\n    ctx.fillStyle = this._color.fade(opacity).toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n  }\n}\n","import Color from 'color';\n\n// https://coolors.co/f8ffe5-06d6a0-1b9aaa-ef476f-ffc43d\nexport const LIGHT_BG = new Color('#F8FFE5');\nexport const TEAL = new Color('#06D6A0');\nexport const BLUE = new Color('#1B9AAA');\nexport const RED = new Color('#EF476F');\nexport const YELLOW = new Color('#FFC43D');\n","enum ConnectionDirection {\n  IN = 'in',\n  OUT = 'out',\n}\n\nexport default ConnectionDirection;\n","import { sample } from '../lib/utils';\nimport Road from './Road';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class ConnectionSet {\n  incoming: Road[] = [];\n  outgoing: Road[] = [];\n\n  add(target: Road, direction: ConnectionDirection) {\n    switch (direction) {\n      case ConnectionDirection.IN:\n        this.addIncoming(target);\n        break;\n      case ConnectionDirection.OUT:\n        this.addOutgoing(target);\n        break;\n      default:\n        throw new Error(`unknow connection direction ${direction}`);\n    }\n  }\n\n  addIncoming(target: Road) {\n    this.incoming.push(target);\n  }\n\n  addOutgoing(target: Road) {\n    this.outgoing.push(target);\n  }\n\n  sampleIncoming(): Road {\n    return sample(this.incoming);\n  }\n\n  sampleOutgoing(): Road {\n    return sample(this.outgoing);\n  }\n}\n","// @flow\nimport { assert } from '../../lib/assert';\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { inBack, reverse, linear } from '../../lib/easings';\nimport { constrain, mapRange } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { RED } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 1000;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst PULSE_RADIUS = 25;\n\nconst CLOCK_FADE_DURATION = 150;\nconst PULSE_DURATION = 500;\n\nconst MAIN_COLOR = RED.lighten(0.2).desaturate(0.5);\nconst CLOCK_COLOR = RED.darken(0.2);\nconst PULSE_COLOR = RED.lighten(0.2).fade(0.4);\n\nexport default class Consumer extends SceneObject implements NetworkNode {\n  isDestination = true;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number = 0;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = Circle.create(x, y, RADIUS);\n    this._visualConnectionCircle = Circle.create(\n      x,\n      y,\n      VISUAL_CONNECTION_RADIUS,\n    );\n    this._cooldown = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return this._timer >= this._cooldown;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return [this];\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  consumeTraveller() {\n    assert(this.canConsumeTraveller, 'must be ready to consumer traveller');\n    this._resetTimer();\n    this._pulse();\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius * progress,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        endRadius: RADIUS,\n        startRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: inBack(4),\n        easeOpacity: reverse(linear),\n        removeOnComplete: true,\n      }),\n    );\n  }\n}\n","// @flow\nimport { assert } from '../assert';\nimport Scene from './Scene';\n\nconst DEFAULT_NAME = '$$AbstractSceneSystem$$';\n\nexport default abstract class SceneSystem {\n  static systemName = DEFAULT_NAME;\n  private scene: Scene | null = null;\n\n  constructor() {\n    assert(\n      this.constructor !== SceneSystem,\n      'SceneSystem is an abstract class that must be extended',\n    );\n    assert(\n      (this.constructor as any).systemName !== DEFAULT_NAME,\n      'classes extending SceneSystem must override SceneSystem.systemName',\n    );\n  }\n\n  getScene(): Scene {\n    assert(this.scene, 'scene is required');\n    return this.scene;\n  }\n\n  afterAddToScene(scene: Scene) {\n    this.scene = scene;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeRemoveFromScene(scene: Scene) {\n    this.scene = null;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  beforeUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterUpdate(delta: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  beforeDraw(ctx: CanvasRenderingContext2D, time: number) {}\n\n  // eslint-disable-next-line no-unused-vars\n  afterDraw(ctx: CanvasRenderingContext2D, time: number) {}\n}\n","import AABB from './geom/AABB';\nimport Circle from './geom/Circle';\nimport Vector2 from './geom/Vector2';\n\ntype Subdivisions<T> = [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>];\n\nexport default class QuadTree<T> {\n  static NODE_CAPACITY = 4;\n\n  boundary: AABB;\n  _items: (T | void)[] = [];\n  _nextItemIndex: number = 0;\n  _subdivisions: null | Subdivisions<T> = null;\n  _getPosition: (item: T) => Vector2;\n\n  constructor(boundary: AABB, getPosition: (item: T) => Vector2) {\n    this.boundary = boundary;\n    this._getPosition = getPosition;\n  }\n\n  // debugDraw(color: string) {\n  //   this.boundary.debugDraw(color);\n  //   if (this._subdivisions) {\n  //     this._subdivisions.forEach(subdivision => subdivision.debugDraw(color));\n  //   }\n  // }\n\n  insert(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    if (this._nextItemIndex < QuadTree.NODE_CAPACITY) {\n      this._items[this._nextItemIndex] = item;\n      this._nextItemIndex++;\n      return true;\n    }\n\n    const subdivisions = this._getSubdivisions();\n\n    if (subdivisions[0].insert(item)) return true;\n    if (subdivisions[1].insert(item)) return true;\n    if (subdivisions[2].insert(item)) return true;\n    if (subdivisions[3].insert(item)) return true;\n\n    throw new Error('Couldnt insert item');\n  }\n\n  remove(item: T): boolean {\n    const point = this._getPosition(item);\n    if (!this.boundary.contains(point)) return false;\n\n    const index = this._items.indexOf(item);\n    if (index !== -1) {\n      this._items.splice(index, 1);\n      this._nextItemIndex--;\n      return true;\n    }\n\n    const subdivisions = this._subdivisions;\n    if (subdivisions) {\n      if (subdivisions[0].remove(item)) return true;\n      if (subdivisions[1].remove(item)) return true;\n      if (subdivisions[2].remove(item)) return true;\n      if (subdivisions[3].remove(item)) return true;\n    }\n\n    return false;\n  }\n\n  clear() {\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      this._items[i] = undefined;\n      this._nextItemIndex = 0;\n    }\n\n    if (this._subdivisions) {\n      this._subdivisions.forEach(subdivision => subdivision.clear());\n    }\n  }\n\n  findItemsInRect(rect: AABB): T[] {\n    const foundItems = [] as Array<T>;\n\n    if (!this.boundary.intersects(rect)) return foundItems;\n\n    for (let i = 0; i < this._nextItemIndex; i++) {\n      const item = this._items[i];\n      if (item == null) continue;\n      const point = this._getPosition(item);\n      if (rect.contains(point)) foundItems.push(item);\n    }\n\n    const subdivisions = this._subdivisions;\n    if (!subdivisions) return foundItems;\n\n    if (subdivisions[0].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[0].findItemsInRect(rect));\n    }\n    if (subdivisions[1].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[1].findItemsInRect(rect));\n    }\n    if (subdivisions[2].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[2].findItemsInRect(rect));\n    }\n    if (subdivisions[3].boundary.intersects(rect)) {\n      foundItems.push(...subdivisions[3].findItemsInRect(rect));\n    }\n\n    return foundItems;\n  }\n\n  findItemsInCircle(circle: Circle): T[] {\n    return this.findItemsInRect(circle.getBoundingBox()).filter(item =>\n      circle.containsPoint(this._getPosition(item)),\n    );\n  }\n\n  _getSubdivisions(): Subdivisions<T> {\n    if (this._subdivisions) return this._subdivisions;\n\n    const center = this.boundary.getCenter();\n    const subdivisions: Subdivisions<T> = [\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          this.boundary.top,\n          center.x,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          this.boundary.top,\n          this.boundary.right,\n          center.y,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          this.boundary.left,\n          center.y,\n          center.x,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n      new QuadTree(\n        AABB.fromLeftTopRightBottom(\n          center.x,\n          center.y,\n          this.boundary.right,\n          this.boundary.bottom,\n        ),\n        this._getPosition,\n      ),\n    ];\n\n    this._subdivisions = subdivisions;\n    return subdivisions;\n  }\n}\n","// @flow\nimport Scene from '../lib/scene/Scene';\nimport SceneSystem from '../lib/scene/SceneSystem';\nimport QuadTree from '../lib/QuadTree';\nimport Circle from '../lib/geom/Circle';\nimport AABB from '../lib/geom/AABB';\nimport Traveller from './Traveller';\n\nexport default class TravellerFinder extends SceneSystem {\n  static systemName = 'TravellerFinder';\n\n  _quadTree!: QuadTree<Traveller>;\n\n  removeTraveller(traveller: Traveller) {\n    this._quadTree.remove(traveller);\n  }\n\n  afterAddToScene(scene: Scene) {\n    super.afterAddToScene(scene);\n    this._quadTree = new QuadTree(\n      AABB.fromLeftTopRightBottom(0, 0, scene.width, scene.height),\n      traveller => traveller.position,\n    );\n  }\n\n  beforeUpdate() {\n    const scene = this.getScene();\n    this._quadTree.clear();\n    scene.children.forEach(child => {\n      if (child instanceof Traveller) {\n        this._quadTree.insert(child);\n      }\n    });\n    // this._quadTree.debugDraw('red');\n  }\n\n  findTravellersInCircle(circle: Circle) {\n    return this._quadTree.findItemsInCircle(circle);\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Road from './Road';\nimport { NetworkNode } from './networkNodes/NetworkNode';\n\nconst PathFinder = {\n  getNextRoad(initialNode: NetworkNode, destinationNode: NetworkNode): Road {\n    const remainingNodes = new Set(initialNode.getAllReachableNodes());\n    remainingNodes.add(initialNode);\n    assert(\n      remainingNodes.has(destinationNode),\n      'destination must be reachable',\n    );\n    const bestCosts = new Map();\n    const prevRoads = new Map();\n\n    bestCosts.set(initialNode, 0);\n\n    while (remainingNodes.size) {\n      const { node, cost } = PathFinder._nodeWithShortestDistance(\n        remainingNodes,\n        bestCosts,\n      );\n      remainingNodes.delete(node);\n\n      if (node === destinationNode) {\n        return PathFinder._nextRoadFromRoute(\n          prevRoads,\n          initialNode,\n          destinationNode,\n        );\n      }\n\n      PathFinder._updateNeighbours(node, bestCosts, cost, prevRoads);\n    }\n\n    throw new Error('unreachable i hope');\n  },\n\n  _nodeWithShortestDistance(\n    nodes: Set<NetworkNode>,\n    costs: Map<NetworkNode, number>,\n  ): { node: NetworkNode; cost: number } {\n    let bestCost = Infinity;\n    let bestNode = null;\n\n    nodes.forEach(node => {\n      const cost = costs.get(node);\n      if (cost != null && cost <= bestCost) {\n        bestCost = cost;\n        bestNode = node;\n      }\n    });\n\n    assert(bestNode, 'node must be found');\n    return { node: bestNode, cost: bestCost };\n  },\n  _updateNeighbours(\n    node: NetworkNode,\n    bestCosts: Map<NetworkNode, number>,\n    cost: number,\n    prevRoads: Map<NetworkNode, Road>,\n  ) {\n    node.outgoingConnections.forEach(road => {\n      const nextNode = road.to;\n      const nextNodeCost = bestCosts.get(nextNode);\n      const altNextNodeCost = cost + road.expectedTimeFromStartToEnd;\n      if (nextNodeCost == null || altNextNodeCost <= nextNodeCost) {\n        bestCosts.set(nextNode, altNextNodeCost);\n        prevRoads.set(nextNode, road);\n      }\n    });\n  },\n  _nextRoadFromRoute(\n    prevRoads: Map<NetworkNode, Road>,\n    start: NetworkNode,\n    finish: NetworkNode,\n  ): Road {\n    let node = finish;\n    while (prevRoads.has(node)) {\n      const road = prevRoads.get(node);\n      assert(road, 'road must exist');\n      node = road.from;\n      if (node === start) return road;\n    }\n\n    throw new Error('prev road must be found');\n  },\n};\n\nexport default PathFinder;\n","// @flow\nimport { assert } from '../../lib/assert';\nimport Vector2 from '../../lib/geom/Vector2';\nimport { uniq, flatten } from '../../lib/utils';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport PathFinder from '../PathFinder';\nimport Road from '../Road';\nimport Traveller from '../Traveller';\nimport { NetworkNode } from './NetworkNode';\n\nexport default class Intersection implements NetworkNode {\n  isDestination = false;\n  position: Vector2;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number) {\n    this.position = new Vector2(x, y);\n  }\n\n  get incomingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): ReadonlyArray<Road> {\n    return this._connectionSet.outgoing;\n  }\n\n  get canConsumeTraveller(): boolean {\n    return true;\n  }\n\n  consumeTraveller(traveller: Traveller) {\n    const destination = traveller.destination;\n    assert(destination, 'traveller must have destination');\n\n    const nextRoad = PathFinder.getNextRoad(this, destination);\n    assert(\n      this.outgoingConnections.includes(nextRoad),\n      'nextRoad must be from this intersection',\n    );\n\n    traveller.removeFromCurrentRoad();\n    nextRoad.addTravellerAtStart(traveller);\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map(road =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(): Vector2 {\n    return this.position;\n  }\n\n  getClosestOutgoingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.outgoingConnections.forEach(road => {\n      const traveller = road.getTravellerAfterPosition(-1);\n      if (traveller && traveller.positionOnCurrentRoad < shortestDistance) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.positionOnCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getClosestIncomingTraveller(): Traveller | null {\n    let bestTraveller = null;\n    let shortestDistance = Infinity;\n    this.incomingConnections.forEach(road => {\n      const traveller = road.getTravellerBeforePosition(road.length);\n      if (\n        traveller &&\n        traveller.distanceToEndOfCurrentRoad < shortestDistance\n      ) {\n        bestTraveller = traveller;\n        shortestDistance = traveller.distanceToEndOfCurrentRoad;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n}\n","import Component from './Component';\nimport Entity from './Entity';\n\nexport default class SortOrderProvider extends Component {\n  constructor(\n    entity: Entity,\n    private getSortOrderFn: (entity: Entity) => number,\n  ) {\n    super(entity);\n  }\n\n  getSortOrder(): number {\n    return this.getSortOrderFn(this.entity);\n  }\n}\n","import SceneObject from './SceneObject';\nimport Component from './Component';\nimport { assert } from '../assert';\nimport SortOrderProvider from './SortOrderProvider';\nimport Scene from './Scene';\n\ntype ComponentClass<T extends Component, Args extends unknown[]> = {\n  name: string;\n  new (entity: Entity, ...args: Args): T;\n};\n\nexport default class Entity extends SceneObject {\n  private componentInstances = new Map<\n    ComponentClass<Component, any>,\n    Component\n  >();\n\n  addComponent<T extends Component, Args extends unknown[]>(\n    component: ComponentClass<T, Args>,\n    ...args: Args\n  ): T {\n    assert(\n      !this.componentInstances.has(component),\n      `component instance ${component.name} already exists`,\n    );\n    const instance = new component(this, ...args);\n    this.componentInstances.set(component, instance);\n    return instance;\n  }\n\n  hasComponent<T extends Component>(\n    component: ComponentClass<T, any[]>,\n  ): boolean {\n    return this.componentInstances.has(component);\n  }\n\n  getComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.componentInstances.get(component);\n    assert(instance, `no instance for ${component.name} exists`);\n    assert(instance instanceof component, 'wrong instance type');\n    return instance;\n  }\n\n  removeComponent<T extends Component>(component: ComponentClass<T, any[]>): T {\n    const instance = this.getComponent(component);\n    this.componentInstances.delete(component);\n    instance.onRemove();\n    return instance;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeDraw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.draw(ctx, elapsedTime);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterDraw(ctx, elapsedTime);\n    }\n  }\n  update(delta: number): void {\n    for (const component of this.componentInstances.values()) {\n      component.beforeUpdate(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.update(delta);\n    }\n    for (const component of this.componentInstances.values()) {\n      component.afterUpdate(delta);\n    }\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    for (const component of this.componentInstances.values()) {\n      component.onAddedToScene(scene);\n    }\n  }\n\n  onRemovedFromScene() {\n    const scene = this.getScene();\n    super.onRemovedFromScene();\n    for (const component of this.componentInstances.values()) {\n      component.onRemovedFromScene(scene);\n    }\n  }\n\n  getSortOrder() {\n    if (this.hasComponent(SortOrderProvider)) {\n      return this.getComponent(SortOrderProvider).getSortOrder();\n    } else {\n      return super.getSortOrder();\n    }\n  }\n}\n","import { assert } from '../lib/assert';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Circle from '../lib/geom/Circle';\nimport Vector2 from '../lib/geom/Vector2';\nimport { outBack, inBack } from '../lib/easings';\nimport { sample, constrain, mapRange, random } from '../lib/utils';\nimport TravellerFinder from './TravellerFinder';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Intersection from './networkNodes/Intersection';\nimport Road from './Road';\nimport Entity from '../lib/scene/Entity';\nimport { makeAbsolutePal } from '../pals/makePal';\nimport { PalAbsoluteController } from '../pals/PalController';\n\n// const TRAVELLER_COLOR = BLUE.fade(0.4);\n// const TRAVELLER_RADIUS = 14;\nconst MIN_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MAX_TRAVELLER_COMFORTABLE_RADIUS = 60;\nconst MIN_TRAVELLER_SAFE_RADIUS = 30;\nconst MAX_TRAVELLER_SAFE_RADIUS = 30;\nconst NEARBY_RADIUS = 200;\n\nconst INITIAL_SPEED = 5;\nconst MAX_SPEED = 80;\nconst ACCELERATION = 200;\nconst DECELERATION = -200;\nconst ROAD_END_OVERSHOOT = 0;\n\nconst PATIENCE = 1500;\nconst FORCE_ACCELERATE_DURATION = 100;\n\nconst ENTER_DURATION = 400;\nconst EXIT_DURATION = 400;\n\nconst enterEase = outBack(3);\nconst exitEase = inBack(3);\n\nenum StopReason {\n  STOPPED_FOR_DESTINATION = 'STOPPED_FOR_DESTINATION',\n  STOPPED_FOR_TRAFFIC_IN_FRONT = 'STOPPED_FOR_TRAFFIC_IN_FRONT',\n  STOPPED_FOR_TRAFFIC_NEARBY = 'STOPPED_FOR_TRAFFIC_NEARBY',\n}\n\nexport default class Traveller extends SceneObject {\n  static MAX_SPEED = MAX_SPEED;\n  static StopReason = StopReason;\n\n  comfortableRadius = random(\n    MIN_TRAVELLER_COMFORTABLE_RADIUS,\n    MAX_TRAVELLER_COMFORTABLE_RADIUS,\n  );\n  safeRadius = random(MIN_TRAVELLER_SAFE_RADIUS, MAX_TRAVELLER_SAFE_RADIUS);\n  _currentRoad: Road | null = null;\n  _destination: NetworkNode | null = null;\n  _positionOnCurrentRoad: number = 0;\n  _speed: number = INITIAL_SPEED;\n  _age: number = 0;\n  _exitStartedAt: number | null = null;\n  _stoppedTime: number = 0;\n  _forceAccelerateTimer: number = 0;\n  _stopReason: StopReason | null = null;\n  _stoppedFor: Traveller[] = [];\n  _pal: Entity | null = null;\n\n  get currentRoad(): Road | null {\n    return this._currentRoad;\n  }\n\n  get position(): Vector2 {\n    assert(this._currentRoad, 'currentRoad must be defined');\n    return this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad);\n  }\n\n  // get predictedPositionInDirectionOfTravel(): Vector2 {\n  //   assert(this._currentRoad, 'currentRoad must be defined');\n  //   return this._getPredictedPointForPosition(\n  //     this._currentRoad,\n  //     this._positionOnCurrentRoad + 1,\n  //   );\n  // }\n\n  get predictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition);\n  }\n\n  get predictedStopArea(): Circle {\n    const center = this.predictedStopPoint;\n    return Circle.create(center.x, center.y, this.safeRadius);\n  }\n\n  get potentialNextPredictedStopPoint(): Vector2 {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'currentRoad must be defined');\n    const stopPosition = this._getPredictedStopPositionIfDecelerating();\n    return this._getPredictedPointForPosition(currentRoad, stopPosition + 1);\n  }\n\n  get positionOnCurrentRoad(): number {\n    return this._positionOnCurrentRoad;\n  }\n\n  get distanceToEndOfCurrentRoad(): number {\n    assert(this._currentRoad, 'traveller is not on a road');\n    return this._currentRoad.length - this._positionOnCurrentRoad;\n  }\n\n  get destination(): NetworkNode | null {\n    return this._destination;\n  }\n\n  get speed(): number {\n    return this._speed;\n  }\n\n  get isStopped(): boolean {\n    return this.speed === 0;\n  }\n\n  get stoppedTime(): number {\n    return this._stoppedTime;\n  }\n\n  get stopReason(): StopReason | null {\n    return this._stopReason;\n  }\n\n  isStoppedFor(other: Traveller): boolean {\n    return this._stoppedFor.includes(other);\n  }\n\n  onAddedToRoad(road: Road) {\n    this._currentRoad = road;\n    this._positionOnCurrentRoad = 0;\n    if (!this._destination) {\n      this._pickDestination();\n    }\n  }\n\n  onRemovedFromRoad() {\n    this.getScene().getSystem(TravellerFinder).removeTraveller(this);\n    this._currentRoad = null;\n  }\n\n  onRemovedFromScene() {\n    this.removeFromCurrentRoad();\n  }\n\n  removeFromCurrentRoad() {\n    if (this._currentRoad) this._currentRoad.removeTraveller(this);\n  }\n\n  update(dtMilliseconds: number) {\n    this._age += dtMilliseconds;\n    this._stopReason = null;\n    this._stoppedFor = [];\n\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._move(dtMilliseconds, currentRoad);\n\n    const pal = this._getPal();\n    pal\n      .getComponent(PalAbsoluteController)\n      .setPosition(\n        this.position,\n        currentRoad.getAngleAtPosition(this._positionOnCurrentRoad),\n        dtMilliseconds / 1000,\n      );\n    pal.update(dtMilliseconds);\n\n    this._getEnterTransitionScale();\n    // if (window.debugDraw) this._debugDraw();\n\n    this._checkAtEndOfRoad(currentRoad);\n    this._checkExit();\n  }\n\n  draw(ctx: CanvasRenderingContext2D, elapsedTime: number) {\n    const currentRoad = this._currentRoad;\n    assert(currentRoad, 'current road must be defined');\n\n    this._getPal().draw(ctx, elapsedTime);\n\n    // const position = this.position;\n    // const scale =\n    //   this._getEnterTransitionScale() * this._getExitTransitionScale();\n\n    // ctx.beginPath();\n    // ctx.fillStyle = TRAVELLER_COLOR.toString();\n    // ShapeHelpers.circle(ctx, position.x, position.y, TRAVELLER_RADIUS * scale);\n    // ctx.fill();\n  }\n\n  getSortOrder(): number {\n    return this.position.y;\n  }\n\n  get _isExiting(): boolean {\n    return this._exitStartedAt !== null;\n  }\n\n  _getPal(): Entity {\n    if (!this._pal) {\n      this._pal = makeAbsolutePal(this.position);\n    }\n\n    return this._pal;\n  }\n\n  // _debugDraw() {\n  //   const currentRoad = this._currentRoad;\n  //   if (!currentRoad) return;\n\n  //   const predictedStopPoint = this.predictedStopPoint;\n  //   Circle.create(\n  //     this.position.x,\n  //     this.position.y,\n  //     this.comfortableRadius\n  //   ).debugDraw(\"rgba(0, 255, 0, 0.4)\");\n  //   Circle.create(this.position.x, this.position.y, this.safeRadius).debugDraw(\n  //     this._forceAccelerateTimer ? \"cyan\" : \"red\"\n  //   );\n  //   predictedStopPoint.debugDraw(\"lime\");\n  //   this.predictedStopArea.debugDraw(\"rgba(255, 0, 255, 0.5)\");\n\n  //   const ctx: CanvasRenderingContext2D = window.debugContext;\n  //   ctx.fillText(\n  //     `${this.id} ${Math.round(this._stoppedTime)}`,\n  //     this.position.x,\n  //     this.position.y\n  //   );\n  // }\n\n  _getEnterTransitionScale() {\n    return enterEase(\n      constrain(0, 1, mapRange(0, ENTER_DURATION, 0, 1, this._age)),\n    );\n  }\n\n  _getExitTransitionScale() {\n    if (this._exitStartedAt === null) return 1;\n    return (\n      1 -\n      exitEase(\n        constrain(\n          0,\n          1,\n          mapRange(\n            this._exitStartedAt,\n            this._exitStartedAt + EXIT_DURATION,\n            0,\n            1,\n            this._age,\n          ),\n        ),\n      )\n    );\n  }\n\n  _getPredictedStopPositionIfDecelerating(): number {\n    const timeToStop = -this._speed / DECELERATION;\n    return (\n      this._positionOnCurrentRoad +\n      this._speed * timeToStop +\n      0.5 * DECELERATION * timeToStop * timeToStop\n    );\n  }\n\n  _getPredictedPointForPosition(currentRoad: Road, position: number): Vector2 {\n    if (position <= currentRoad.length) {\n      return currentRoad.getPointAtPosition(position);\n    }\n\n    const overshoot = position - currentRoad.length;\n    const overshootAngle = currentRoad.getAngleAtPosition(currentRoad.length);\n    return Vector2.fromPolar(overshootAngle, overshoot).add(currentRoad.end);\n  }\n\n  _pickDestination() {\n    if (!this._currentRoad) return;\n    const potentialDestinations = this._currentRoad\n      .getAllReachableNodes()\n      .filter((node) => node.isDestination);\n    const destination = sample(potentialDestinations);\n    this._destination = destination;\n  }\n\n  _move(dtMilliseconds: number, currentRoad: Road) {\n    const dtSeconds = dtMilliseconds / 1000;\n\n    this._forceAccelerateTimer = constrain(\n      0,\n      FORCE_ACCELERATE_DURATION,\n      this._forceAccelerateTimer - dtMilliseconds,\n    );\n\n    if (\n      this._forceAccelerateTimer <= 0 &&\n      this._shouldDecelerate(currentRoad)\n    ) {\n      this._accelerate(DECELERATION, dtSeconds, currentRoad);\n    } else {\n      this._accelerate(ACCELERATION, dtSeconds, currentRoad);\n    }\n\n    if (this._speed === 0) {\n      this._stoppedTime += dtMilliseconds;\n    } else {\n      this._stoppedTime = 0;\n    }\n  }\n\n  _shouldDecelerate(currentRoad: Road): boolean {\n    const predictedStopPosition =\n      this._getPredictedStopPositionIfDecelerating();\n    if (\n      currentRoad.to === this._destination &&\n      currentRoad.length + ROAD_END_OVERSHOOT < predictedStopPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_DESTINATION;\n      return true;\n    }\n\n    const nextTravellerOnRoad = currentRoad.getTravellerAfterPosition(\n      this._positionOnCurrentRoad,\n    );\n\n    const safeStopAheadPosition =\n      predictedStopPosition + this.comfortableRadius;\n\n    if (\n      nextTravellerOnRoad &&\n      nextTravellerOnRoad.positionOnCurrentRoad < safeStopAheadPosition\n    ) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n      this._stoppedFor.push(nextTravellerOnRoad);\n      return true;\n    }\n\n    if (currentRoad.to instanceof Intersection) {\n      const intersection = currentRoad.to;\n      const outgoingTraveller = intersection.getClosestOutgoingTraveller();\n      if (outgoingTraveller) {\n        const outgoingTravellerPosition =\n          currentRoad.length + outgoingTraveller.positionOnCurrentRoad;\n\n        if (outgoingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(outgoingTraveller);\n          return true;\n        }\n      }\n\n      const incomingTraveller = intersection.getClosestIncomingTraveller();\n      if (incomingTraveller && incomingTraveller !== this) {\n        const incomingTravellerPosition =\n          currentRoad.length - incomingTraveller.distanceToEndOfCurrentRoad;\n        if (incomingTravellerPosition < safeStopAheadPosition) {\n          this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_IN_FRONT;\n          this._stoppedFor.push(incomingTraveller);\n          return true;\n        }\n      }\n    }\n\n    if (this._shouldDecelerateForNearbyTravellers(currentRoad)) {\n      this._stopReason = StopReason.STOPPED_FOR_TRAFFIC_NEARBY;\n      return true;\n    }\n\n    // const currentPoint = this.position;\n    // const currentSafeCircle = Circle.create(\n    //   currentPoint.x,\n    //   currentPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     currentSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    // const predictedStopPoint = this._getPredictedStopPointIfDecelerating(\n    //   currentRoad,\n    // );\n    // const predictedSafeCircle = Circle.create(\n    //   predictedStopPoint.x,\n    //   predictedStopPoint.y,\n    //   this.safeRadius,\n    // );\n    // if (\n    //   this._shouldDecelerateForTravellersInCircle(\n    //     currentRoad,\n    //     predictedSafeCircle,\n    //   )\n    // ) {\n    //   return true;\n    // }\n\n    return false;\n  }\n\n  _shouldDecelerateForNearbyTravellers(currentRoad: Road): boolean {\n    const travellerFinder = this.getScene().getSystem(TravellerFinder);\n    const stopArea = this.predictedStopArea;\n    const stopPoint = stopArea.center;\n    const nextStopPoint = this.potentialNextPredictedStopPoint;\n    const searchArea = stopArea.withRadius(NEARBY_RADIUS);\n    const nearbyTravellers = travellerFinder.findTravellersInCircle(searchArea);\n\n    for (const other of nearbyTravellers) {\n      // cannot crash into self\n      if (other === this) continue;\n\n      // if we both started breaking now, we would be a safe distance so we're fine\n      const otherStopArea = other.predictedStopArea;\n      const otherStopPoint = otherStopArea.center;\n      if (!stopArea.intersectsCircle(otherStopArea)) continue;\n\n      // currently we think other will stop at the center of otherStopArea.\n      // otherNextStopPoint is one pixel further forward based other's current\n      // heading\n      const otherNextStopPoint = other.potentialNextPredictedStopPoint;\n\n      // if we're moving away from each other, everything is fine:\n      const currentStopDistance = stopPoint.distanceTo(otherStopArea.center);\n      const nextStopDistance = nextStopPoint.distanceTo(otherNextStopPoint);\n      if (nextStopDistance > currentStopDistance) continue;\n\n      // who is moving in a direction that's headed more towards the other's\n      // stop position? if they're moving towards me but i'm moving more\n      // orthagonally relative to them, they should slow down\n      const approachAmount = stopPoint.distanceTo(otherNextStopPoint);\n      const otherApproachAmount = otherStopPoint.distanceTo(nextStopPoint);\n      if (approachAmount < otherApproachAmount) {\n        continue;\n      }\n\n      // so we know we're moving towards them faster than they're moving\n      // towards us, but how much? If it's barely any and we're not already too\n      // close to them, we could just keep going\n      if (\n        approachAmount - otherApproachAmount <\n        0.15\n        // approachAmount > this.safeRadius * 0.8\n      ) {\n        continue;\n      }\n\n      // if there's a clash... just randomly tie-break\n      if (approachAmount === otherApproachAmount) {\n        return Math.random() < 0.5;\n      }\n\n      // if we've been waiting around for fuckin ever just slam that fuckin\n      // pedal to the floor like ugh (in reality just nudge forward a little)\n      // (unless the other one is stopped to cus otherwise we'll just crash)\n      if (this._stoppedTime > PATIENCE && !other.isStopped) {\n        this._forceAcceleration();\n        return false;\n      }\n\n      // attempt to break deadlocks. i guess this is the equivalent of 'other'\n      // waving at the current traveller to continue\n      if (other.isStoppedFor(this)) continue;\n\n      this._stoppedFor.push(other);\n    }\n\n    if (this._stoppedFor.length) return true;\n\n    return false;\n  }\n\n  // _shouldDecelerateForTravellersInCircle(currentRoad: Road, circle: Circle) {\n  //   const travellerFinder = this.getScene().getSystem(TravellerFinder);\n  //   const overlappingTravellers = travellerFinder.findTravellersInCircle(\n  //     circle,\n  //   );\n\n  //   const currentPosition = this.position;\n  //   const nextPosition = this.predictedPositionInDirectionOfTravel;\n\n  //   const clashingTravellers = overlappingTravellers.filter(other => {\n  //     if (other === this) return false;\n  //     if (other.currentRoad === currentRoad) return false;\n\n  // const currentDistance = currentPosition.distanceTo(other.position);\n  // const nextDistance = nextPosition.distanceTo(other.position);\n\n  // const isGettingCloser = nextDistance < currentDistance;\n  // if (!isGettingCloser) return false;\n\n  // const otherNextPosition = other.predictedPositionInDirectionOfTravel;\n  // const otherNextDistance = currentPosition.distanceTo(otherNextPosition);\n  // const thisMoveDelta = nextDistance - currentDistance;\n  // const otherMoveDelta = otherNextDistance - currentDistance;\n  // if (thisMoveDelta < otherMoveDelta) return true;\n\n  // if (this.isStopped && !other.isStopped) return true;\n\n  // if (this.isStopped && other.isStopped) {\n  //   if (this.stoppedTime === other.stoppedTime && this.id < other.id)\n  //     return false;\n  //   if (this.stoppedTime < other.stoppedTime) return false;\n  // }\n\n  //     return true;\n  //   });\n\n  //   return clashingTravellers.length > 0;\n  // }\n\n  _forceAcceleration() {\n    this._forceAccelerateTimer = FORCE_ACCELERATE_DURATION;\n  }\n\n  _accelerate(acceleration: number, dtSeconds: number, currentRoad: Road) {\n    const lastSpeed = this._speed;\n    this._speed = constrain(\n      0,\n      MAX_SPEED,\n      this._speed + acceleration * dtSeconds,\n    );\n    const avgSpeed = (lastSpeed + this._speed) / 2;\n    this._positionOnCurrentRoad = constrain(\n      0,\n      currentRoad.length,\n      this._positionOnCurrentRoad + avgSpeed * dtSeconds,\n    );\n  }\n\n  _checkAtEndOfRoad(currentRoad: Road) {\n    if (this._positionOnCurrentRoad === currentRoad.length) {\n      if (this._isExiting) return;\n      this._onReachEndOfCurrentRoad(currentRoad);\n    }\n  }\n\n  _checkExit() {\n    if (this._isExiting) {\n      assert(this._exitStartedAt);\n      if (this._age >= this._exitStartedAt + EXIT_DURATION) {\n        this._onExit();\n      }\n    }\n  }\n\n  _onReachEndOfCurrentRoad(currentRoad: Road) {\n    const nextNode = currentRoad.to;\n    const destination = this._destination;\n    if (nextNode.canConsumeTraveller) {\n      nextNode.consumeTraveller(this);\n      if (nextNode === destination) {\n        this._onReachDestination();\n      }\n    }\n  }\n\n  _onReachDestination() {\n    this._exit();\n  }\n\n  _onExit() {\n    this.getScene().removeChild(this);\n  }\n\n  _exit() {\n    this._exitStartedAt = this._age;\n  }\n}\n","import Entity from '../lib/scene/Entity';\nimport { PalTargetController, PalAbsoluteController } from './PalController';\nimport Vector2 from '../lib/geom/Vector2';\nimport { generateRandomPalConfig } from './PalConfig';\nimport PalGeom from './PalGeom';\nimport PalWalkAnimationController from './PalWalkAnimationController';\nimport PalRenderer from './PalRenderer';\n\nexport function makeTargetPal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalTargetController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n\nexport function makeAbsolutePal(position: Vector2): Entity {\n  const pal = new Entity();\n  pal.addComponent(PalAbsoluteController, position);\n  const config = generateRandomPalConfig();\n  const geom = pal.addComponent(PalGeom, config);\n  geom.setAnimationController(new PalWalkAnimationController(config));\n  pal.addComponent(PalRenderer, config);\n  return pal;\n}\n","// @flow\nimport { assert } from '../assert';\nimport { constrain, compact } from '../utils';\nimport Circle from './Circle';\nimport Vector2 from './Vector2';\nimport StraightPathSegment from './StraightPathSegment';\nimport CirclePathSegment from './CirclePathSegment';\nimport Line2 from './Line2';\n\nexport interface PathSegment {\n  getStart(): Vector2;\n  getEnd(): Vector2;\n  getLength(): number;\n  getPointAtPosition(position: number): Vector2;\n  getAngleAtPosition(position: number): number;\n}\n\nexport default class Path implements PathSegment {\n  static straightThroughPoints(...points: ReadonlyArray<Vector2>): Path {\n    let [lastPoint, ...remainingPoints] = points;\n    const path = new Path();\n\n    for (const point of remainingPoints) {\n      path.addSegment(new StraightPathSegment(lastPoint, point));\n      lastPoint = point;\n    }\n\n    return path;\n  }\n\n  static segmentAcrossCircle(\n    containingCircle: Circle,\n    entryAngle: number,\n    exitAngle: number,\n  ): CirclePathSegment | StraightPathSegment {\n    entryAngle = entryAngle + Math.PI;\n    const entryPoint = containingCircle.pointOnCircumference(entryAngle);\n    const exitPoint = containingCircle.pointOnCircumference(exitAngle);\n\n    const entryLineNormal = new Line2(\n      containingCircle.center,\n      entryPoint,\n    ).perpendicularLineThroughPoint(entryPoint);\n    const exitLineNormal = new Line2(\n      containingCircle.center,\n      exitPoint,\n    ).perpendicularLineThroughPoint(exitPoint);\n\n    if (entryLineNormal.isParallelTo(exitLineNormal)) {\n      return new StraightPathSegment(entryPoint, exitPoint);\n    }\n\n    const roadCircleCenter =\n      entryLineNormal.pointAtIntersectionWith(exitLineNormal);\n    const roadCircleRadius = entryPoint.distanceTo(roadCircleCenter);\n\n    // containingCircle.center.debugDraw('lime');\n    // roadCircleCenter.debugDraw('blue');\n    // entryPoint.debugDraw('magenta');\n    // exitPoint.debugDraw('red');\n\n    return new CirclePathSegment(\n      roadCircleCenter,\n      roadCircleRadius,\n      entryPoint.sub(roadCircleCenter).angle,\n      exitPoint.sub(roadCircleCenter).angle,\n    );\n  }\n\n  segments: PathSegment[] = [];\n\n  constructor(...segments: PathSegment[]) {\n    this.addSegments(...segments);\n  }\n\n  getStart(): Vector2 {\n    return this.segments[0].getStart();\n  }\n\n  getEnd(): Vector2 {\n    return this.segments[this.segments.length - 1].getEnd();\n  }\n\n  getLength(): number {\n    return this.segments.reduce(\n      (length, segment) => length + segment.getLength(),\n      0,\n    );\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getPointAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  getAngleAtPosition(position: number): number {\n    const constrained = constrain(0, this.getLength(), position);\n    let soFar = 0;\n    for (const segment of this.segments) {\n      if (constrained <= soFar + segment.getLength()) {\n        return segment.getAngleAtPosition(constrained - soFar);\n      }\n      soFar += segment.getLength();\n    }\n    throw new Error('this is supposed to be unreachable oops');\n  }\n\n  addSegment(segment: PathSegment): this {\n    const lastSegment = this.segments[this.segments.length - 1];\n    if (lastSegment) {\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        `segments must neatly join together - ${lastSegment\n          .getEnd()\n          .toString()} !== ${segment.getStart().toString()}`,\n      );\n    }\n    this.segments.push(segment);\n    return this;\n  }\n\n  addSegments(...segments: PathSegment[]): this {\n    segments.forEach((segment) => this.addSegment(segment));\n    return this;\n  }\n\n  autoRound(radius: number): this {\n    const newSegments = this.segments.map((segment, i): PathSegment | null => {\n      const lastSegment = i === 0 ? null : this.segments[i - 1];\n      if (!lastSegment) {\n        if (segment instanceof StraightPathSegment) return null;\n        return segment;\n      }\n\n      if (!(segment instanceof StraightPathSegment)) return segment;\n      if (!(lastSegment instanceof StraightPathSegment)) return null;\n\n      assert(\n        lastSegment.getEnd().equals(segment.getStart()),\n        'segments must join',\n      );\n\n      const entryAngle = lastSegment.angle;\n      const exitAngle = segment.angle;\n      const usableRadius = Math.min(\n        radius,\n        lastSegment.getLength() / 2,\n        segment.getLength() / 2,\n      );\n\n      const containingCircle = Circle.create(\n        segment.getStart().x,\n        segment.getStart().y,\n        usableRadius,\n      );\n\n      return Path.segmentAcrossCircle(containingCircle, entryAngle, exitAngle);\n    });\n\n    const compacted = compact(newSegments);\n\n    const start = this.getStart();\n    const end = this.getEnd();\n    let lastPoint = start;\n    this.segments = [];\n\n    compacted.forEach((segment) => {\n      if (segment.getStart().equals(lastPoint)) {\n        this.addSegment(segment);\n      } else {\n        this.addSegment(new StraightPathSegment(lastPoint, segment.getStart()));\n        this.addSegment(segment);\n      }\n\n      lastPoint = segment.getEnd();\n    });\n\n    if (!lastPoint.equals(end)) {\n      this.addSegment(new StraightPathSegment(lastPoint, end));\n    }\n\n    return this;\n  }\n}\n","// @flow\nimport { compact } from '../lib/utils';\nimport SceneObject from '../lib/scene/SceneObject';\nimport Scene from '../lib/scene/Scene';\nimport Vector2 from '../lib/geom/Vector2';\nimport Circle from '../lib/geom/Circle';\nimport Path from '../lib/geom/Path';\nimport Road from './Road';\nimport Intersection from './networkNodes/Intersection';\nimport ConnectionDirection from './ConnectionDirection';\n\nexport default class Junction extends SceneObject {\n  _circle: Circle;\n  _intersectionsByAngle: { [angleString: string]: Intersection } = {};\n  _incomingIntersections: Set<Intersection> = new Set();\n  _outgoingIntersections: Set<Intersection> = new Set();\n  _roads: Road[] = [];\n\n  constructor(x: number, y: number, radius: number) {\n    super();\n    this._circle = Circle.create(x, y, radius);\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  onAddedToScene(scene: Scene) {\n    super.onAddedToScene(scene);\n    this._roads.forEach((road) => scene.addChild(road));\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._circle.pointOnCircumference(radians);\n  }\n\n  connectToRoadAtAngle(\n    road: Road,\n    angle: number,\n    direction: ConnectionDirection,\n  ): Intersection {\n    const intersection = this._intersectionAtAngle(angle);\n    intersection.connectTo(road, direction);\n\n    const isIncoming =\n      direction === ConnectionDirection.IN ||\n      this._incomingIntersections.has(intersection);\n\n    const isOutgoing =\n      direction === ConnectionDirection.OUT ||\n      this._outgoingIntersections.has(intersection);\n\n    if (isIncoming) this._incomingIntersections.add(intersection);\n    if (isOutgoing) this._outgoingIntersections.add(intersection);\n\n    this._intersections.forEach((other) => {\n      if (other === intersection) return;\n\n      if (isIncoming && this._outgoingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(intersection.position).angle,\n            other.position.sub(this._circle.center).angle,\n          ),\n        );\n\n        this._addRoad(new Road(intersection, other, { path }));\n      }\n\n      if (isOutgoing && this._incomingIntersections.has(other)) {\n        const path = new Path(\n          Path.segmentAcrossCircle(\n            this._circle,\n            this._circle.center.sub(other.position).angle,\n            intersection.position.sub(this._circle.center).angle,\n          ),\n        );\n        this._addRoad(new Road(other, intersection, { path }));\n      }\n    });\n\n    return intersection;\n  }\n\n  _intersectionAtAngle(angle: number): Intersection {\n    const angleStr = angle.toString();\n    if (this._intersectionsByAngle[angleStr]) {\n      return this._intersectionsByAngle[angleStr];\n    }\n\n    const intersection = this._createIntersectionAtAngle(angle);\n    this._intersectionsByAngle[angleStr] = intersection;\n    return intersection;\n  }\n\n  _createIntersectionAtAngle(angle: number): Intersection {\n    const position = this.getVisualConnectionPointAtAngle(angle);\n    return new Intersection(position.x, position.y);\n  }\n\n  get _intersections(): Intersection[] {\n    return compact(\n      Object.keys(this._intersectionsByAngle).map(\n        (angle) => this._intersectionsByAngle[angle],\n      ),\n    );\n  }\n\n  _addRoad(road: Road) {\n    this._roads.push(road);\n    if (this.hasScene()) {\n      this.getScene().addChild(road);\n    }\n  }\n}\n","// @flow\nimport SceneObject from '../lib/scene/SceneObject';\nimport Path from '../lib/geom/Path';\nimport StraightPathSegment from '../lib/geom/StraightPathSegment';\nimport Vector2 from '../lib/geom/Vector2';\nimport * as ShapeHelpers from '../lib/canvasShapeHelpers';\nimport { YELLOW } from './colors';\nimport ConnectionDirection from './ConnectionDirection';\nimport { NetworkNode } from './networkNodes/NetworkNode';\nimport Junction from './Junction';\nimport Traveller from './Traveller';\n\n// const ROAD_OUTER_COLOR = BLUE;\n// const ROAD_INNER_COLOR = LIGHT_BG;\nconst ROAD_DASH_COLOR = YELLOW.darken(0.2);\n// const ROAD_OUTER_WIDTH = 12;\n// const ROAD_INNER_WIDTH = 13;\nconst ROAD_DASH_WIDTH = 3;\nconst ROAD_IDEAL_DASH = [5, 10];\nconst ROAD_IDEAL_DASH_LENGTH = ROAD_IDEAL_DASH.reduce((a, b) => a + b, 0);\nconst ROAD_DASH_SPEED = 0.05;\n\nexport type RoadOptions = {\n  autoRound?: number;\n  points?: Array<Vector2>;\n  path?: Path;\n};\n\nexport default class Road extends SceneObject {\n  isNode = false;\n  from: NetworkNode;\n  to: NetworkNode;\n  _path: Path;\n  _currentTravellers: Traveller[] = [];\n\n  constructor(\n    from: NetworkNode | Junction,\n    to: NetworkNode | Junction,\n    { points, autoRound, path }: RoadOptions = {},\n  ) {\n    super();\n\n    const angleFrom = points\n      ? from.position.angleTo(points[0])\n      : from.position.angleTo(to.position);\n\n    const angleTo = points\n      ? to.position.angleTo(points[points.length - 1])\n      : to.position.angleTo(from.position);\n\n    if (path) {\n      this._path = path;\n    } else if (points) {\n      this._path = Path.straightThroughPoints(\n        from.getVisualConnectionPointAtAngle(angleFrom),\n        ...points,\n        to.getVisualConnectionPointAtAngle(angleTo),\n      );\n    } else {\n      this._path = new Path().addSegment(\n        new StraightPathSegment(\n          from.getVisualConnectionPointAtAngle(angleFrom),\n          to.getVisualConnectionPointAtAngle(angleTo),\n        ),\n      );\n    }\n\n    if (autoRound != null) {\n      this._path.autoRound(autoRound);\n    }\n\n    if (from instanceof Junction) {\n      this.from = from.connectToRoadAtAngle(\n        this,\n        angleFrom,\n        ConnectionDirection.OUT,\n      );\n    } else {\n      this.from = from;\n      from.connectTo(this, ConnectionDirection.OUT);\n    }\n\n    if (to instanceof Junction) {\n      this.to = to.connectToRoadAtAngle(this, angleTo, ConnectionDirection.IN);\n    } else {\n      this.to = to;\n      to.connectTo(this, ConnectionDirection.IN);\n    }\n  }\n\n  get length(): number {\n    return this._path.getLength();\n  }\n\n  get start(): Vector2 {\n    return this._path.getStart();\n  }\n\n  get end(): Vector2 {\n    return this._path.getEnd();\n  }\n\n  get expectedTimeFromStartToEnd(): number {\n    if (this._currentTravellers.length) {\n      const avgSpeed =\n        this._currentTravellers.reduce(\n          (sum, traveller) => sum + traveller.speed,\n          0,\n        ) / this._currentTravellers.length;\n      return this.length / avgSpeed;\n    }\n\n    return this.length / (Traveller.MAX_SPEED * 0.7);\n  }\n\n  canAddTravellerAtStart(): boolean {\n    const nextTraveller = this.getTravellerAfterPosition(0);\n    if (!nextTraveller) return true;\n    return (\n      nextTraveller.positionOnCurrentRoad > nextTraveller.comfortableRadius\n    );\n  }\n\n  addTravellerAtStart(traveller: Traveller) {\n    this._currentTravellers.push(traveller);\n    traveller.onAddedToRoad(this);\n  }\n\n  removeTraveller(traveller: Traveller): boolean {\n    const index = this._currentTravellers.indexOf(traveller);\n    if (index === -1) return false;\n    this.removeTravellerAtIndex(index);\n    return true;\n  }\n\n  removeTravellerAtIndex(index: number): Traveller {\n    const traveller = this._currentTravellers[index];\n    this._currentTravellers.splice(index, 1);\n    traveller.onRemovedFromRoad();\n    return traveller;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()): NetworkNode[] {\n    const nodes = [] as Array<NetworkNode>;\n    if (visited.has(this.to)) return nodes;\n    return [...this.to.getAllReachableNodes(visited), this.to];\n  }\n\n  getPointAtPosition(position: number): Vector2 {\n    return this._path.getPointAtPosition(position);\n  }\n\n  getAngleAtPosition(position: number): number {\n    return this._path.getAngleAtPosition(position);\n  }\n\n  getTravellerAfterPosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = traveller.positionOnCurrentRoad - position;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  getTravellerBeforePosition(position: number): Traveller | null {\n    let bestTraveller = null;\n    let bestDistance = Infinity;\n\n    this._currentTravellers.forEach(traveller => {\n      const distance = position - traveller.positionOnCurrentRoad;\n      if (distance <= 0) return;\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestTraveller = traveller;\n      }\n    });\n\n    return bestTraveller;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, time: number) {\n    ctx.beginPath();\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ShapeHelpers.path(ctx, this._path);\n\n    // ctx.strokeStyle = ROAD_OUTER_COLOR.toString();\n    // ctx.lineWidth = ROAD_OUTER_WIDTH;\n    // ctx.stroke();\n\n    // ctx.strokeStyle = ROAD_INNER_COLOR.toString();\n    // ctx.lineWidth = ROAD_INNER_WIDTH;\n    // ctx.stroke();\n\n    const dashScale = this._getLineDashScale();\n    const dashLength = ROAD_IDEAL_DASH_LENGTH * dashScale;\n    ctx.setLineDash(ROAD_IDEAL_DASH.map(length => length * dashScale));\n    ctx.strokeStyle = ROAD_DASH_COLOR.toString();\n    ctx.lineDashOffset = (-time * ROAD_DASH_SPEED * dashScale) % dashLength;\n    ctx.lineWidth = ROAD_DASH_WIDTH;\n    // ctx.strokeStyle = 'black';\n    // ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  _getLineDashScale(): number {\n    const wholeDashCount = Math.floor(this.length / ROAD_IDEAL_DASH_LENGTH);\n    const wholeDashLength = wholeDashCount * ROAD_IDEAL_DASH_LENGTH;\n\n    const roundDownLength = this.length - wholeDashLength;\n    const roundUpLength =\n      wholeDashLength + ROAD_IDEAL_DASH_LENGTH - this.length;\n\n    const dashScale =\n      roundDownLength < roundUpLength\n        ? this.length / wholeDashLength\n        : this.length / (wholeDashLength + ROAD_IDEAL_DASH_LENGTH);\n\n    return dashScale;\n  }\n}\n","// @flow\nimport SceneObject from '../../lib/scene/SceneObject';\nimport Circle from '../../lib/geom/Circle';\nimport Vector2 from '../../lib/geom/Vector2';\nimport * as ShapeHelpers from '../../lib/canvasShapeHelpers';\nimport { outSine } from '../../lib/easings';\nimport { mapRange, constrain, flatten, uniq } from '../../lib/utils';\nimport Pulse from '../effects/Pulse';\nimport { TEAL } from '../colors';\nimport ConnectionSet from '../ConnectionSet';\nimport ConnectionDirection from '../ConnectionDirection';\nimport Traveller from '../Traveller';\nimport Road from '../Road';\nimport { NetworkNode } from './NetworkNode';\n\nconst DEFAULT_COOLDOWN = 500;\n\nconst RADIUS = 20;\nconst VISUAL_CONNECTION_RADIUS = 30;\nconst CLOCK_RADIUS = RADIUS * 0.7;\nconst PULSE_RADIUS = 35;\n\nconst PULSE_DURATION = 500;\nconst CLOCK_FADE_DURATION = 150;\n\nconst MAIN_COLOR = TEAL.lighten(0.1);\nconst CLOCK_COLOR = TEAL.darken(0.1);\nconst PULSE_COLOR = TEAL.lighten(0.2).fade(0.1);\n\nexport default class Producer extends SceneObject implements NetworkNode {\n  isDestination = false;\n  canConsumeTraveller = false;\n  _circle: Circle;\n  _visualConnectionCircle: Circle;\n  _cooldown: number;\n  _timer: number;\n  _connectionSet: ConnectionSet = new ConnectionSet();\n\n  constructor(x: number, y: number, cooldown: number = DEFAULT_COOLDOWN) {\n    super();\n    this._circle = Circle.create(x, y, RADIUS);\n    this._visualConnectionCircle = Circle.create(\n      x,\n      y,\n      VISUAL_CONNECTION_RADIUS,\n    );\n    this._cooldown = cooldown;\n    this._timer = cooldown;\n  }\n\n  get position(): Vector2 {\n    return this._circle.center;\n  }\n\n  get incomingConnections(): Road[] {\n    return this._connectionSet.incoming;\n  }\n\n  get outgoingConnections(): Road[] {\n    return this._connectionSet.outgoing;\n  }\n\n  getAllReachableNodes(visited: Set<NetworkNode> = new Set()) {\n    visited.add(this);\n    return uniq(\n      flatten(\n        this._connectionSet.outgoing.map((road) =>\n          road.getAllReachableNodes(visited),\n        ),\n      ),\n    );\n  }\n\n  getVisualConnectionPointAtAngle(radians: number): Vector2 {\n    return this._visualConnectionCircle.pointOnCircumference(radians);\n  }\n\n  consumeTraveller() {\n    throw new Error('producer cannot consume traveller');\n  }\n\n  connectTo(node: Road, direction: ConnectionDirection) {\n    this._connectionSet.add(node, direction);\n  }\n\n  update(delta: number) {\n    this._timer = constrain(0, this._cooldown, this._timer + delta);\n    if (this._timer >= this._cooldown) {\n      this._onTimerEnd();\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const progress = this._timer / this._cooldown;\n\n    const colorMixAmount = constrain(\n      0,\n      1,\n      mapRange(0, CLOCK_FADE_DURATION, 1, 0, this._timer),\n    );\n    const bgColor = MAIN_COLOR.mix(CLOCK_COLOR, colorMixAmount);\n\n    ctx.beginPath();\n    ctx.fillStyle = bgColor.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = CLOCK_COLOR.toString();\n    ctx.moveTo(this._circle.center.x, this._circle.center.y);\n    ctx.arc(\n      this._circle.center.x,\n      this._circle.center.y,\n      this._circle.radius,\n      -Math.PI / 2,\n      progress * 2 * Math.PI - Math.PI / 2,\n      false,\n    );\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.fillStyle = MAIN_COLOR.toString();\n    ShapeHelpers.circle(\n      ctx,\n      this._circle.center.x,\n      this._circle.center.y,\n      CLOCK_RADIUS,\n    );\n    ctx.fill();\n  }\n\n  _resetTimer() {\n    this._timer = 0;\n  }\n\n  _onTimerEnd() {\n    const didEmitTraveller = this._attemptEmitTraveller();\n    if (didEmitTraveller) {\n      this._pulse();\n      this._resetTimer();\n    }\n  }\n\n  _pulse() {\n    this.getScene().addChildBefore(\n      this,\n      new Pulse({\n        x: this._circle.center.x,\n        y: this._circle.center.y,\n        startRadius: RADIUS,\n        endRadius: PULSE_RADIUS,\n        duration: PULSE_DURATION,\n        color: PULSE_COLOR,\n        easeRadius: outSine,\n        removeOnComplete: true,\n      }),\n    );\n  }\n\n  _attemptEmitTraveller(): boolean {\n    const road = this._connectionSet.sampleOutgoing();\n    if (!(road instanceof Road)) return false;\n\n    if (road.canAddTravellerAtStart()) {\n      const traveller = new Traveller();\n      road.addTravellerAtStart(traveller);\n      this.getScene().addChild(traveller);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","// @flow\nimport { assert } from '../lib/assert';\nimport Scene from '../lib/scene/Scene';\nimport Consumer from './networkNodes/Consumer';\nimport Producer from './networkNodes/Producer';\nimport Road from './Road';\nimport Junction from './Junction';\n// import DebugOverlay from \"./systems/DebugOverlay\";\nimport TravellerFinder from './TravellerFinder';\nimport Vector2 from '../lib/geom/Vector2';\n\nconst ROUND = 50;\n\nconst scene = new Scene(800, 600, window.devicePixelRatio);\nconst root = document.getElementById('root');\nassert(root, '#root must be present');\nscene.appendTo(root);\n\n// scene.addSystem(new DebugOverlay());\nscene.addSystem(new TravellerFinder());\n\nscenario3();\n\nscene.start();\n\nfunction scenario1() {\n  const producer1 = new Producer(100, 100, 500);\n  // const producer2 = new Consumer(100, 300, 2500);\n  const consumer1 = new Consumer(400, 200, 1500);\n  const consumer2 = new Consumer(250, 200, 1500);\n  scene.addChild(producer1);\n  // scene.addChild(producer2);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n\n  const junction1 = new Junction(250, 100, ROUND);\n  scene.addChild(junction1);\n  scene.addChild(new Road(producer1, junction1));\n  scene.addChild(\n    new Road(junction1, consumer1, {\n      points: [new Vector2(400, 100)],\n      autoRound: ROUND,\n    }),\n  );\n  scene.addChild(new Road(junction1, consumer2));\n\n  // const path2 = new Path();\n  // path2.addSegments(\n  //   new StraightPathSegment(new Vector2(130, 300), new Vector2(380, 300)),\n  //   new CirclePathSegment(new Vector2(380, 280), 20, Math.PI * 0.5, 0),\n  //   new StraightPathSegment(new Vector2(400, 280), new Vector2(400, 230)),\n  // );\n  // const road2 = new Road(producer2, consumer1, path2);\n  // scene.addChild(road2);\n}\n\nfunction scenario2() {\n  const producer = new Producer(100, 300, 500);\n  const junction = new Junction(300, 300, ROUND);\n  const consumer1 = new Consumer(300, 100, 5000);\n  const consumer2 = new Consumer(500, 300, 5000);\n  const consumer3 = new Consumer(300, 500, 5000);\n\n  scene.addChild(new Road(producer, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  scene.addChild(producer);\n  scene.addChild(junction);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n}\n\nfunction scenario3() {\n  const northConsumer = new Consumer(300, 550, 1500);\n  const middleConsumer = new Consumer(100, 450, 1500);\n  const southConsumer = new Consumer(100, 250, 1500);\n  const eastProducer = new Producer(600, 150, 500);\n  const westProducer = new Producer(100, 100, 500);\n  // const westProducer = new Producer(250, 250, 100);\n\n  scene.addChild(northConsumer);\n  scene.addChild(middleConsumer);\n  scene.addChild(southConsumer);\n  scene.addChild(eastProducer);\n  scene.addChild(westProducer);\n\n  const mainJunction = new Junction(300, 150, ROUND);\n  const eastProducerSplit = new Junction(500, 370, ROUND);\n  const southConsumerJoin = new Junction(330, 400, ROUND);\n  scene.addChild(mainJunction);\n  scene.addChild(eastProducerSplit);\n  scene.addChild(southConsumerJoin);\n  scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(eastProducer, eastProducerSplit));\n  scene.addChild(new Road(eastProducerSplit, southConsumerJoin));\n  // scene.addChild(\n  //   new Road(eastProducerSplit, mainJunction, {\n  //     points: [[600, 280], [700, 50], [450, 180], [450, 100], [300, 20]],\n  //     // points: [[400, 100]],\n  //     autoRound: 50,\n  //   }),\n  // );\n  scene.addChild(\n    new Road(eastProducerSplit, mainJunction, {\n      points: [new Vector2(400, 300), new Vector2(500, 50)],\n      autoRound: ROUND,\n    }),\n  );\n\n  // scene.addChild(new Road(westProducer, mainJunction));\n  scene.addChild(new Road(mainJunction, southConsumerJoin));\n  scene.addChild(new Road(southConsumerJoin, northConsumer));\n  scene.addChild(new Road(mainJunction, middleConsumer));\n  scene.addChild(new Road(mainJunction, southConsumer));\n}\n\nfunction scenario4() {\n  const producer1 = new Producer(100, 100, 1000);\n  const producer2 = new Producer(300, 200, 1000);\n  const producer3 = new Producer(100, 300, 1000);\n  // const producer4 = new Producer(400, 100, 1000);\n  const consumer1 = new Consumer(300, 100, 1000);\n  const consumer2 = new Consumer(100, 200, 1000);\n  const consumer3 = new Consumer(300, 300, 1000);\n  // const consumer4 = new Consumer(430, 300, 1000);\n  scene.addChild(producer1);\n  scene.addChild(producer2);\n  scene.addChild(producer3);\n  // scene.addChild(producer4);\n  scene.addChild(consumer1);\n  scene.addChild(consumer2);\n  scene.addChild(consumer3);\n  // scene.addChild(consumer4);\n\n  const junction = new Junction(200, 200, 30);\n  scene.addChild(junction);\n\n  scene.addChild(new Road(producer1, junction));\n  scene.addChild(new Road(producer2, junction));\n  scene.addChild(new Road(producer3, junction));\n  scene.addChild(new Road(junction, consumer1));\n  scene.addChild(new Road(junction, consumer2));\n  scene.addChild(new Road(junction, consumer3));\n\n  // scene.addChild(\n  //   new Road(producer4, consumer4, {\n  //     points: [[400, 250], [415, 250], [415, 150], [430, 150]],\n  //     autoRound: 30,\n  //   }),\n  // );\n}\n\nfunction scenario6() {\n  const producer = new Producer(300, 50, 1500).addTo(scene);\n  const consumer = new Consumer(500, 50, 100).addTo(scene);\n  new Road(producer, consumer, {\n    points: [\n      new Vector2(350, 150),\n      new Vector2(150, 350),\n      new Vector2(400, 500),\n      new Vector2(650, 350),\n      new Vector2(450, 150),\n    ],\n    autoRound: 400,\n  }).addTo(scene);\n}\n","import { assert } from '../assert';\nimport SceneObject from './SceneObject';\nimport SceneSystem from './SceneSystem';\n\nconst speed = 1;\nconst scale = 1;\nconst repeatUpdate = 1;\n\ntype SystemClass<T extends SceneSystem = SceneSystem> = {\n  systemName: string;\n  new (): T;\n};\n\nexport default class Scene {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  private _scaleFactor: number;\n  private _children: SceneObject[] = [];\n  private _isPlaying: boolean = false;\n  private frameHandle: number | null = null;\n  private lastElapsedTime: number | null = null;\n  private systemsByClass = new Map<SystemClass<SceneSystem>, SceneSystem>();\n\n  constructor(width: number, height: number, scaleFactor: number = 1) {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = width * scaleFactor;\n    this.canvas.height = height * scaleFactor;\n    this.canvas.style.width = `${width}px`;\n    this.canvas.style.height = `${height}px`;\n    const ctx = this.canvas.getContext('2d');\n    assert(ctx, 'ctx');\n    this.ctx = ctx;\n    this._scaleFactor = scaleFactor * scale;\n\n    this._setupVisiblityChange();\n  }\n\n  get width(): number {\n    return this.canvas.width / this._scaleFactor;\n  }\n\n  get height(): number {\n    return this.canvas.height / this._scaleFactor;\n  }\n\n  get scaleFactor(): number {\n    return this._scaleFactor;\n  }\n\n  get isPlaying(): boolean {\n    return this.frameHandle !== null && this._isPlaying;\n  }\n\n  set isPlaying(newValue: boolean) {\n    assert(\n      this.frameHandle !== null,\n      'cannot set isPlaying without calling start',\n    );\n    this._isPlaying = newValue;\n  }\n\n  get children(): SceneObject[] {\n    return this._children;\n  }\n\n  appendTo(element: HTMLElement) {\n    element.appendChild(this.canvas);\n  }\n\n  hasSystem(systemType: SystemClass): boolean {\n    return this.systemsByClass.has(systemType);\n  }\n\n  getSystem<T extends SceneSystem>(systemType: SystemClass<T>): T {\n    const system = this.systemsByClass.get(systemType);\n    assert(system, `system, ${systemType.systemName} not found`);\n    assert(system instanceof systemType, 'system is wrong instance type');\n    return system;\n  }\n\n  addSystem(system: SceneSystem) {\n    assert(\n      !this.hasSystem(system.constructor as any),\n      'only one system of each type allowed',\n    );\n    this.systemsByClass.set(system.constructor as any, system);\n    system.afterAddToScene(this);\n  }\n\n  removeSystem(systemType: SystemClass) {\n    const system = this.getSystem(systemType);\n    system.beforeRemoveFromScene(this);\n    this.systemsByClass.delete(systemType);\n  }\n\n  addChild(child: SceneObject) {\n    this._children.push(child);\n    child.onAddedToScene(this);\n  }\n\n  addChildBefore(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index, newChild);\n  }\n\n  addChildAfter(targetChild: SceneObject, newChild: SceneObject) {\n    const index = this._children.indexOf(targetChild);\n    assert(index !== -1, 'target child must be present');\n\n    this.addChildAtIndex(index + 1, newChild);\n  }\n\n  addChildAtIndex(index: number, child: SceneObject) {\n    this._children.splice(index, 0, child);\n    child.onAddedToScene(this);\n  }\n\n  removeChild(child: SceneObject): boolean {\n    const index = this._children.indexOf(child);\n    if (index === -1) return false;\n\n    this.removeChildAtIndex(index);\n    return true;\n  }\n\n  removeChildAtIndex(index: number): SceneObject {\n    const child = this._children[index];\n    this._children.splice(index, 1);\n    child.onRemovedFromScene();\n    return child;\n  }\n\n  update(delta: number) {\n    for (let i = 0; i < repeatUpdate; i++) {\n      for (const system of this.systemsByClass.values()) {\n        system.beforeUpdate(delta);\n      }\n      this._children.forEach((child) => child.update(delta));\n      for (const system of this.systemsByClass.values()) {\n        system.afterUpdate(delta);\n      }\n    }\n  }\n\n  draw(elapsedTime: number) {\n    this.ctx.save();\n    this.ctx.scale(this._scaleFactor, this._scaleFactor);\n    this.ctx.clearRect(0, 0, this.width, this.height);\n\n    for (const system of this.systemsByClass.values()) {\n      system.beforeDraw(this.ctx, elapsedTime);\n    }\n    this._children\n      .sort((a, b) => a.getSortOrder() - b.getSortOrder())\n      .forEach((child) => child.draw(this.ctx, elapsedTime));\n    for (const system of this.systemsByClass.values()) {\n      system.afterDraw(this.ctx, elapsedTime);\n    }\n\n    this.ctx.restore();\n  }\n\n  start() {\n    this._isPlaying = true;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  }\n\n  stop() {\n    if (this.frameHandle !== null) {\n      window.cancelAnimationFrame(this.frameHandle);\n      this.frameHandle = null;\n    }\n    this._isPlaying = false;\n    this.lastElapsedTime = null;\n  }\n\n  _tick = (elapsedTime: number) => {\n    elapsedTime = elapsedTime * speed;\n    const lastElapsedTime = this.lastElapsedTime;\n    if (lastElapsedTime !== null) {\n      const deltaTime = elapsedTime - lastElapsedTime;\n      if (this.isPlaying) {\n        this.update(deltaTime);\n        this.draw(elapsedTime);\n      }\n    }\n\n    this.lastElapsedTime = elapsedTime;\n    this.frameHandle = window.requestAnimationFrame(this._tick);\n  };\n\n  _setupVisiblityChange() {\n    let playOnVisible = false;\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden && this.isPlaying) {\n        playOnVisible = true;\n        this.stop();\n      }\n      if (playOnVisible && !document.hidden) {\n        playOnVisible = false;\n        this.start();\n      }\n    });\n  }\n}\n"],"names":["$0590d9fc1b9817be$var$constructorIdCounts","$0590d9fc1b9817be$export$2e2bcd8739ae039","hasScene","this","scene","getScene","$87DYR","assert","draw","ctx","elapsedTime","update","delta","addTo","addChild","onAddedToScene","scene1","onRemovedFromScene","getSortOrder","name","id","constructor","$b2475cb40559fc2b$var$UnitBezier","sampleCurveX","t3","ax","bx","cx","sampleCurveY","t1","ay","by","cy","sampleCurveDerivativeX","t2","solveCurveX","x3","epsilon","t","i","NEWTON_METHOD_ITERATIONS","x2","$96RKe","approxEq","dx","lo","hi","solve","x1","epsilon1","DEFAULT_EPSILON","x11","y11","x21","y21","$b2475cb40559fc2b$export$45db2fc2f15997e7","n","$b2475cb40559fc2b$export$cef097a6f35c9b6a","Math","sin","PI","$b2475cb40559fc2b$export$e38aa6d936f277b2","s","$4a39eef099898156$export$2e2bcd8739ae039","deltaTime","deltaProgress","_duration","_progress","min","_circle","withRadius","lerp","_startRadius","_endRadius","_easeRadius","_removeOnComplete","removeChild","beginPath","opacity","_easeOpacity","fillStyle","_color","fade","toString","$yW6N3","circle","center","x","y","radius","fill","startRadius","endRadius","duration","color","easeRadius","easeOpacity","removeOnComplete","super","$4TER2","default","create","$parcel$interopDefault","$0FWmF","$c479791925765205$export$d0446fe88325854e","$c479791925765205$export$aa201224bb439d47","$c479791925765205$export$aab610c505c06a8f","ConnectionDirection","$e7b25626ebe2fa17$var$ConnectionDirection","$e7b25626ebe2fa17$export$2e2bcd8739ae039","$e36fcec16fe90272$export$2e2bcd8739ae039","add","target","direction","IN","addIncoming","OUT","addOutgoing","Error","target1","incoming","push","target2","outgoing","sampleIncoming","sample","sampleOutgoing","$f8fe5e061301c004$var$MAIN_COLOR","lighten","desaturate","$f8fe5e061301c004$var$CLOCK_COLOR","darken","$f8fe5e061301c004$var$PULSE_COLOR","$f8fe5e061301c004$export$2e2bcd8739ae039","position","canConsumeTraveller","_timer","_cooldown","incomingConnections","_connectionSet","outgoingConnections","getVisualConnectionPointAtAngle","radians","_visualConnectionCircle","pointOnCircumference","getAllReachableNodes","visited","Set","connectTo","node","consumeTraveller","_resetTimer","_pulse","constrain","progress","colorMixAmount","mapRange","bgColor","mix","moveTo","easing","addChildBefore","cooldown","isDestination","$da8e7203d6eea939$export$2e2bcd8739ae039","afterAddToScene","beforeRemoveFromScene","beforeUpdate","afterUpdate","delta1","beforeDraw","time","afterDraw","ctx1","time1","systemName","$20c335d199682e1f$export$2e2bcd8739ae039","insert","item2","point","_getPosition","boundary","contains","_nextItemIndex","NODE_CAPACITY","_items","subdivisions","_getSubdivisions","remove","item1","index","indexOf","splice","_subdivisions","clear","undefined","forEach","subdivision","findItemsInRect","rect","foundItems","intersects","item","findItemsInCircle","getBoundingBox","filter","containsPoint","getCenter","$9x7hn","fromLeftTopRightBottom","left","top","right","bottom","getPosition","$e48083a1610aebeb$export$2e2bcd8739ae039","removeTraveller","traveller1","_quadTree","width","height","traveller","children","child","$fc0940676888ae78$export$2e2bcd8739ae039","findTravellersInCircle","$4481f2d3a26f3bcf$var$PathFinder","getNextRoad","initialNode","destinationNode","remainingNodes","has","bestCosts","Map","prevRoads","set","size","cost","_nodeWithShortestDistance","delete","_nextRoadFromRoute","_updateNeighbours","nodes","costs","bestCost","Infinity","bestNode","get","road","nextNode","to","nextNodeCost","altNextNodeCost","expectedTimeFromStartToEnd","start","finish","from","$4481f2d3a26f3bcf$export$2e2bcd8739ae039","$e68ae2c24c7d7188$export$2e2bcd8739ae039","destination","nextRoad","includes","removeFromCurrentRoad","addTravellerAtStart","uniq","flatten","map","getClosestOutgoingTraveller","bestTraveller","shortestDistance","getTravellerAfterPosition","positionOnCurrentRoad","getClosestIncomingTraveller","getTravellerBeforePosition","length","distanceToEndOfCurrentRoad","$6i1fg","$28c70117a47ab52b$export$2e2bcd8739ae039","$7ic2V","getSortOrderFn","entity","$400ab8c2e6376767$export$2e2bcd8739ae039","addComponent","component","args","componentInstances","instance","hasComponent","component1","getComponent","component2","removeComponent","component3","onRemove","values","component4","component5","component6","component7","$fc0940676888ae78$var$enterEase","$b2475cb40559fc2b$export$bcede31c95c9ee9","$fc0940676888ae78$var$exitEase","StopReason","$fc0940676888ae78$var$StopReason","currentRoad","_currentRoad","getPointAtPosition","_positionOnCurrentRoad","predictedStopPoint","stopPosition","_getPredictedStopPositionIfDecelerating","_getPredictedPointForPosition","predictedStopArea","safeRadius","potentialNextPredictedStopPoint","_destination","speed","_speed","isStopped","stoppedTime","_stoppedTime","stopReason","_stopReason","isStoppedFor","other","_stoppedFor","onAddedToRoad","_pickDestination","onRemovedFromRoad","getSystem","dtMilliseconds","_age","_move","pal","_getPal","$19ECN","PalAbsoluteController","setPosition","getAngleAtPosition","_getEnterTransitionScale","_checkAtEndOfRoad","_checkExit","_isExiting","_exitStartedAt","_pal","config","$h8N2y","generateRandomPalConfig","$2dNNZ","setAnimationController","$k9rmw","$exw1r","$e9b3d2f51f5f1fed$export$b7cfb0b946e2f4d5","_getExitTransitionScale","timeToStop","overshoot","overshootAngle","fromPolar","end","potentialDestinations","dtMilliseconds1","currentRoad1","dtSeconds","_forceAccelerateTimer","_shouldDecelerate","_accelerate","currentRoad2","predictedStopPosition","STOPPED_FOR_DESTINATION","nextTravellerOnRoad","safeStopAheadPosition","comfortableRadius","STOPPED_FOR_TRAFFIC_IN_FRONT","intersection","outgoingTraveller","incomingTraveller","_shouldDecelerateForNearbyTravellers","STOPPED_FOR_TRAFFIC_NEARBY","currentRoad3","travellerFinder","stopArea","stopPoint","nextStopPoint","searchArea","nearbyTravellers","otherStopArea","otherStopPoint","intersectsCircle","otherNextStopPoint","currentStopDistance","distanceTo","approachAmount","otherApproachAmount","random","_forceAcceleration","acceleration","currentRoad4","lastSpeed","avgSpeed","currentRoad5","_onReachEndOfCurrentRoad","_onExit","currentRoad6","_onReachDestination","_exit","MAX_SPEED","$bf57ed7391903046$export$2e2bcd8739ae039","points","lastPoint","remainingPoints","path","addSegment","$b2Aev","containingCircle1","entryAngle1","exitAngle1","entryPoint","exitPoint","entryLineNormal","$6Cnop","perpendicularLineThroughPoint","exitLineNormal","isParallelTo","roadCircleCenter","pointAtIntersectionWith","roadCircleRadius","$hKbPz","sub","angle","getStart","segments","getEnd","getLength","reduce","segment","constrained","soFar","position1","segment1","lastSegment","equals","addSegments","autoRound","newSegments","entryAngle","exitAngle","usableRadius","containingCircle","segmentAcrossCircle","compacted","compact","segments1","$044aa2905e2633d4$export$2e2bcd8739ae039","_roads","connectToRoadAtAngle","_intersectionAtAngle","isIncoming","_incomingIntersections","isOutgoing","_outgoingIntersections","_intersections","_addRoad","$555e57406fd3b1be$export$2e2bcd8739ae039","angle1","angleStr","_intersectionsByAngle","_createIntersectionAtAngle","angle2","Object","keys","road1","$555e57406fd3b1be$var$ROAD_DASH_COLOR","$555e57406fd3b1be$var$ROAD_IDEAL_DASH","$555e57406fd3b1be$var$ROAD_IDEAL_DASH_LENGTH","a","b","_path","_currentTravellers","sum","canAddTravellerAtStart","nextTraveller","traveller2","removeTravellerAtIndex","position2","bestDistance","distance","position3","lineCap","lineJoin","dashScale","_getLineDashScale","dashLength","setLineDash","strokeStyle","lineDashOffset","lineWidth","stroke","wholeDashLength","floor","isNode","angleFrom","angleTo","straightThroughPoints","$095811fd17bac22d$var$MAIN_COLOR","$095811fd17bac22d$var$CLOCK_COLOR","$095811fd17bac22d$var$PULSE_COLOR","$095811fd17bac22d$export$2e2bcd8739ae039","_onTimerEnd","arc","$095811fd17bac22d$var$RADIUS","_attemptEmitTraveller","$c92f324627ca05f7$var$scene","canvas","_scaleFactor","scaleFactor","isPlaying","frameHandle","_isPlaying","newValue","_children","appendTo","element","appendChild","hasSystem","systemType","systemsByClass","systemType1","system","addSystem","removeSystem","systemType2","child3","targetChild","newChild","addChildAtIndex","addChildAfter","targetChild1","newChild1","child1","child2","removeChildAtIndex","index1","system1","elapsedTime1","save","scale","clearRect","sort","system2","restore","window","requestAnimationFrame","_tick","stop","cancelAnimationFrame","lastElapsedTime","_setupVisiblityChange","playOnVisible","document","addEventListener","hidden","createElement","style","getContext","devicePixelRatio","$c92f324627ca05f7$var$root","getElementById","northConsumer","middleConsumer","southConsumer","eastProducer","westProducer","mainJunction","eastProducerSplit","southConsumerJoin","$c92f324627ca05f7$var$scenario3"],"version":3,"file":"index.e927aa94.js.map"}