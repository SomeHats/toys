import{l as ct,s as x,a as l,z as u,m as v,A as j,B as z,r as $,C as ht}from"./chunk_assert.6e3d4d7d.js";import{S as f,E as lt,a as dt}from"./chunk_Entity.540220d2.js";import{C as g}from"./chunk_Circle.c946af55.js";import{c as S,P as G,g as ut,a as _t,b as gt,d as pt,p as mt}from"./chunk_PalRenderer.4b90b2d7.js";import{l as L,a as Q,r as ft,o as At,b as Tt}from"./chunk_easings.697b9297.js";import{C as P}from"./chunk_index.dc2a5aeb.js";import{V as D}from"./chunk_Vector2.cb3dfab2.js";import{S as Rt}from"./chunk_SceneSystem.dae0ac76.js";import{A as R}from"./chunk_AABB.f77a6698.js";import{P as m}from"./chunk_Path.e27f89bd.js";import{S as Ct}from"./chunk_CirclePathSegment.9a8e7a13.js";class Z extends f{constructor({x:t,y:e,startRadius:n,endRadius:s,duration:o,color:a,easeRadius:r=L,easeOpacity:h=L,removeOnComplete:A=!1}){super(),this._circle=g.create(t,e,n),this._startRadius=n,this._endRadius=s,this._duration=o,this._color=a,this._progress=0,this._easeRadius=r,this._easeOpacity=h,this._removeOnComplete=A}update(t){const e=t/this._duration;this._progress=Math.min(1,this._progress+e),this._circle=this._circle.withRadius(ct(this._startRadius,this._endRadius,this._easeRadius(this._progress))),this._progress===1&&this._removeOnComplete&&this.getScene().removeChild(this)}draw(t){t.beginPath();const e=this._easeOpacity(this._progress);t.fillStyle=this._color.fade(e).toString(),S(t,this._circle.center.x,this._circle.center.y,this._circle.radius),t.fill()}}new P("#F8FFE5");const B=new P("#06D6A0");new P("#1B9AAA");const k=new P("#EF476F"),St=new P("#FFC43D");var _=(i=>(i.IN="in",i.OUT="out",i))(_||{});class V{constructor(){this.incoming=[],this.outgoing=[]}add(t,e){switch(e){case _.IN:this.addIncoming(t);break;case _.OUT:this.addOutgoing(t);break;default:throw new Error(`unknow connection direction ${e}`)}}addIncoming(t){this.incoming.push(t)}addOutgoing(t){this.outgoing.push(t)}sampleIncoming(){return x(this.incoming)}sampleOutgoing(){return x(this.outgoing)}}const Pt=1e3,H=20,Ot=30,It=25,Et=150,vt=500,Dt=k.lighten(.2).desaturate(.5),W=k.darken(.2),bt=k.lighten(.2).fade(.4);class N extends f{constructor(t,e,n=Pt){super(),this.isDestination=!0,this._timer=0,this._connectionSet=new V,this._circle=g.create(t,e,H),this._visualConnectionCircle=g.create(t,e,Ot),this._cooldown=n}get position(){return this._circle.center}get canConsumeTraveller(){return this._timer>=this._cooldown}get incomingConnections(){return this._connectionSet.incoming}get outgoingConnections(){return this._connectionSet.outgoing}getVisualConnectionPointAtAngle(t){return this._visualConnectionCircle.pointOnCircumference(t)}getAllReachableNodes(t=new Set){return t.add(this),[this]}connectTo(t,e){this._connectionSet.add(t,e)}consumeTraveller(){l(this.canConsumeTraveller,"must be ready to consumer traveller"),this._resetTimer(),this._pulse()}update(t){this._timer=u(0,this._cooldown,this._timer+t)}draw(t){const e=this._timer/this._cooldown,n=u(0,1,v(0,Et,1,0,this._timer)),s=Dt.mix(W,n);t.beginPath(),t.fillStyle=s.toString(),S(t,this._circle.center.x,this._circle.center.y,this._circle.radius),t.fill(),t.beginPath(),t.fillStyle=W.toString(),t.moveTo(this._circle.center.x,this._circle.center.y),S(t,this._circle.center.x,this._circle.center.y,this._circle.radius*e),t.fill()}_resetTimer(){this._timer=0}_pulse(){this.getScene().addChildBefore(this,new Z({x:this._circle.center.x,y:this._circle.center.y,endRadius:H,startRadius:It,duration:vt,color:bt,easeRadius:Q(4),easeOpacity:ft(L),removeOnComplete:!0}))}}const p=class{constructor(i,t){this._items=[],this._nextItemIndex=0,this._subdivisions=null,this.boundary=i,this._getPosition=t}insert(i){const t=this._getPosition(i);if(!this.boundary.contains(t))return!1;if(this._nextItemIndex<p.NODE_CAPACITY)return this._items[this._nextItemIndex]=i,this._nextItemIndex++,!0;const e=this._getSubdivisions();if(e[0].insert(i)||e[1].insert(i)||e[2].insert(i)||e[3].insert(i))return!0;throw new Error("Couldnt insert item")}remove(i){const t=this._getPosition(i);if(!this.boundary.contains(t))return!1;const e=this._items.indexOf(i);if(e!==-1)return this._items.splice(e,1),this._nextItemIndex--,!0;const n=this._subdivisions;return!!(n&&(n[0].remove(i)||n[1].remove(i)||n[2].remove(i)||n[3].remove(i)))}clear(){for(let i=0;i<this._nextItemIndex;i++)this._items[i]=void 0,this._nextItemIndex=0;this._subdivisions&&this._subdivisions.forEach(i=>i.clear())}findItemsInRect(i){const t=[];if(!this.boundary.intersects(i))return t;for(let n=0;n<this._nextItemIndex;n++){const s=this._items[n];if(s==null)continue;const o=this._getPosition(s);i.contains(o)&&t.push(s)}const e=this._subdivisions;return e&&(e[0].boundary.intersects(i)&&t.push(...e[0].findItemsInRect(i)),e[1].boundary.intersects(i)&&t.push(...e[1].findItemsInRect(i)),e[2].boundary.intersects(i)&&t.push(...e[2].findItemsInRect(i)),e[3].boundary.intersects(i)&&t.push(...e[3].findItemsInRect(i))),t}findItemsInCircle(i){return this.findItemsInRect(i.getBoundingBox()).filter(t=>i.containsPoint(this._getPosition(t)))}_getSubdivisions(){if(this._subdivisions)return this._subdivisions;const i=this.boundary.getCenter(),t=[new p(R.fromLeftTopRightBottom(this.boundary.left,this.boundary.top,i.x,i.y),this._getPosition),new p(R.fromLeftTopRightBottom(i.x,this.boundary.top,this.boundary.right,i.y),this._getPosition),new p(R.fromLeftTopRightBottom(this.boundary.left,i.y,i.x,this.boundary.bottom),this._getPosition),new p(R.fromLeftTopRightBottom(i.x,i.y,this.boundary.right,this.boundary.bottom),this._getPosition)];return this._subdivisions=t,t}};let tt=p;tt.NODE_CAPACITY=4;class b extends Rt{removeTraveller(t){this._quadTree.remove(t)}afterAddToScene(t){super.afterAddToScene(t),this._quadTree=new tt(R.fromLeftTopRightBottom(0,0,t.width,t.height),e=>e.position)}beforeUpdate(){const t=this.getScene();this._quadTree.clear(),t.children.forEach(e=>{e instanceof O&&this._quadTree.insert(e)})}findTravellersInCircle(t){return this._quadTree.findItemsInCircle(t)}}b.systemName="TravellerFinder";const E={getNextRoad(i,t){const e=new Set(i.getAllReachableNodes());e.add(i),l(e.has(t),"destination must be reachable");const n=new Map,s=new Map;for(n.set(i,0);e.size;){const{node:o,cost:a}=E._nodeWithShortestDistance(e,n);if(e.delete(o),o===t)return E._nextRoadFromRoute(s,i,t);E._updateNeighbours(o,n,a,s)}throw new Error("unreachable i hope")},_nodeWithShortestDistance(i,t){let e=1/0,n=null;return i.forEach(s=>{const o=t.get(s);o!=null&&o<=e&&(e=o,n=s)}),l(n,"node must be found"),{node:n,cost:e}},_updateNeighbours(i,t,e,n){i.outgoingConnections.forEach(s=>{const o=s.to,a=t.get(o),r=e+s.expectedTimeFromStartToEnd;(a==null||r<=a)&&(t.set(o,r),n.set(o,s))})},_nextRoadFromRoute(i,t,e){let n=e;for(;i.has(n);){const s=i.get(n);if(l(s,"road must exist"),n=s.from,n===t)return s}throw new Error("prev road must be found")}};class et{constructor(t,e){this.isDestination=!1,this._connectionSet=new V,this.position=new D(t,e)}get incomingConnections(){return this._connectionSet.incoming}get outgoingConnections(){return this._connectionSet.outgoing}get canConsumeTraveller(){return!0}consumeTraveller(t){const e=t.destination;l(e,"traveller must have destination");const n=E.getNextRoad(this,e);l(this.outgoingConnections.includes(n),"nextRoad must be from this intersection"),t.removeFromCurrentRoad(),n.addTravellerAtStart(t)}getAllReachableNodes(t=new Set){return t.add(this),j(z(this._connectionSet.outgoing.map(e=>e.getAllReachableNodes(t))))}getVisualConnectionPointAtAngle(){return this.position}getClosestOutgoingTraveller(){let t=null,e=1/0;return this.outgoingConnections.forEach(n=>{const s=n.getTravellerAfterPosition(-1);s&&s.positionOnCurrentRoad<e&&(t=s,e=s.positionOnCurrentRoad)}),t}getClosestIncomingTraveller(){let t=null,e=1/0;return this.incomingConnections.forEach(n=>{const s=n.getTravellerBeforePosition(n.length);s&&s.distanceToEndOfCurrentRoad<e&&(t=s,e=s.distanceToEndOfCurrentRoad)}),t}connectTo(t,e){this._connectionSet.add(t,e)}}function wt(i){const t=new lt;t.addComponent(G,i);const e=ut();return t.addComponent(_t,e).setAnimationController(new gt(e)),t.addComponent(pt,e),t}const Ft=60,Nt=60,yt=30,xt=30,Lt=200,Ut=5,nt=80,Bt=200,y=-200,kt=0,Vt=1500,Y=100,Mt=400,q=400,$t=At(3),Ht=Q(3);var it=(i=>(i.STOPPED_FOR_DESTINATION="STOPPED_FOR_DESTINATION",i.STOPPED_FOR_TRAFFIC_IN_FRONT="STOPPED_FOR_TRAFFIC_IN_FRONT",i.STOPPED_FOR_TRAFFIC_NEARBY="STOPPED_FOR_TRAFFIC_NEARBY",i))(it||{});class O extends f{constructor(){super(...arguments),this.comfortableRadius=$(Ft,Nt),this.safeRadius=$(yt,xt),this._currentRoad=null,this._destination=null,this._positionOnCurrentRoad=0,this._speed=Ut,this._age=0,this._exitStartedAt=null,this._stoppedTime=0,this._forceAccelerateTimer=0,this._stopReason=null,this._stoppedFor=[],this._pal=null}get currentRoad(){return this._currentRoad}get position(){return l(this._currentRoad,"currentRoad must be defined"),this._currentRoad.getPointAtPosition(this._positionOnCurrentRoad)}get predictedStopPoint(){const t=this._currentRoad;l(t,"currentRoad must be defined");const e=this._getPredictedStopPositionIfDecelerating();return this._getPredictedPointForPosition(t,e)}get predictedStopArea(){const t=this.predictedStopPoint;return g.create(t.x,t.y,this.safeRadius)}get potentialNextPredictedStopPoint(){const t=this._currentRoad;l(t,"currentRoad must be defined");const e=this._getPredictedStopPositionIfDecelerating();return this._getPredictedPointForPosition(t,e+1)}get positionOnCurrentRoad(){return this._positionOnCurrentRoad}get distanceToEndOfCurrentRoad(){return l(this._currentRoad,"traveller is not on a road"),this._currentRoad.length-this._positionOnCurrentRoad}get destination(){return this._destination}get speed(){return this._speed}get isStopped(){return this.speed===0}get stoppedTime(){return this._stoppedTime}get stopReason(){return this._stopReason}isStoppedFor(t){return this._stoppedFor.includes(t)}onAddedToRoad(t){this._currentRoad=t,this._positionOnCurrentRoad=0,this._destination||this._pickDestination()}onRemovedFromRoad(){this.getScene().getSystem(b).removeTraveller(this),this._currentRoad=null}onRemovedFromScene(){this.removeFromCurrentRoad()}removeFromCurrentRoad(){this._currentRoad&&this._currentRoad.removeTraveller(this)}update(t){this._age+=t,this._stopReason=null,this._stoppedFor=[];const e=this._currentRoad;l(e,"current road must be defined"),this._move(t,e);const n=this._getPal();n.getComponent(G).setPosition(this.position,e.getAngleAtPosition(this._positionOnCurrentRoad),t/1e3),n.update(t),this._getEnterTransitionScale(),this._checkAtEndOfRoad(e),this._checkExit()}draw(t,e){const n=this._currentRoad;l(n,"current road must be defined"),this._getPal().draw(t,e)}getSortOrder(){return this.position.y}get _isExiting(){return this._exitStartedAt!==null}_getPal(){return this._pal||(this._pal=wt(this.position)),this._pal}_getEnterTransitionScale(){return $t(u(0,1,v(0,Mt,0,1,this._age)))}_getExitTransitionScale(){return this._exitStartedAt===null?1:1-Ht(u(0,1,v(this._exitStartedAt,this._exitStartedAt+q,0,1,this._age)))}_getPredictedStopPositionIfDecelerating(){const t=-this._speed/y;return this._positionOnCurrentRoad+this._speed*t+.5*y*t*t}_getPredictedPointForPosition(t,e){if(e<=t.length)return t.getPointAtPosition(e);const n=e-t.length,s=t.getAngleAtPosition(t.length);return D.fromPolar(s,n).add(t.end)}_pickDestination(){if(!this._currentRoad)return;const t=this._currentRoad.getAllReachableNodes().filter(n=>n.isDestination),e=x(t);this._destination=e}_move(t,e){const n=t/1e3;this._forceAccelerateTimer=u(0,Y,this._forceAccelerateTimer-t),this._forceAccelerateTimer<=0&&this._shouldDecelerate(e)?this._accelerate(y,n,e):this._accelerate(Bt,n,e),this._speed===0?this._stoppedTime+=t:this._stoppedTime=0}_shouldDecelerate(t){const e=this._getPredictedStopPositionIfDecelerating();if(t.to===this._destination&&t.length+kt<e)return this._stopReason="STOPPED_FOR_DESTINATION",!0;const n=t.getTravellerAfterPosition(this._positionOnCurrentRoad),s=e+this.comfortableRadius;if(n&&n.positionOnCurrentRoad<s)return this._stopReason="STOPPED_FOR_TRAFFIC_IN_FRONT",this._stoppedFor.push(n),!0;if(t.to instanceof et){const o=t.to,a=o.getClosestOutgoingTraveller();if(a&&t.length+a.positionOnCurrentRoad<s)return this._stopReason="STOPPED_FOR_TRAFFIC_IN_FRONT",this._stoppedFor.push(a),!0;const r=o.getClosestIncomingTraveller();if(r&&r!==this&&t.length-r.distanceToEndOfCurrentRoad<s)return this._stopReason="STOPPED_FOR_TRAFFIC_IN_FRONT",this._stoppedFor.push(r),!0}return this._shouldDecelerateForNearbyTravellers(t)?(this._stopReason="STOPPED_FOR_TRAFFIC_NEARBY",!0):!1}_shouldDecelerateForNearbyTravellers(t){const e=this.getScene().getSystem(b),n=this.predictedStopArea,s=n.center,o=this.potentialNextPredictedStopPoint,a=n.withRadius(Lt),r=e.findTravellersInCircle(a);for(const h of r){if(h===this)continue;const A=h.predictedStopArea,rt=A.center;if(!n.intersectsCircle(A))continue;const M=h.potentialNextPredictedStopPoint,at=s.distanceTo(A.center);if(o.distanceTo(M)>at)continue;const w=s.distanceTo(M),F=rt.distanceTo(o);if(!(w<F)&&!(w-F<.15)){if(w===F)return Math.random()<.5;if(this._stoppedTime>Vt&&!h.isStopped)return this._forceAcceleration(),!1;h.isStoppedFor(this)||this._stoppedFor.push(h)}}return!!this._stoppedFor.length}_forceAcceleration(){this._forceAccelerateTimer=Y}_accelerate(t,e,n){const s=this._speed;this._speed=u(0,nt,this._speed+t*e);const o=(s+this._speed)/2;this._positionOnCurrentRoad=u(0,n.length,this._positionOnCurrentRoad+o*e)}_checkAtEndOfRoad(t){if(this._positionOnCurrentRoad===t.length){if(this._isExiting)return;this._onReachEndOfCurrentRoad(t)}}_checkExit(){this._isExiting&&(l(this._exitStartedAt,"Assertion Error: this._exitStartedAt"),this._age>=this._exitStartedAt+q&&this._onExit())}_onReachEndOfCurrentRoad(t){const e=t.to,n=this._destination;e.canConsumeTraveller&&(e.consumeTraveller(this),e===n&&this._onReachDestination())}_onReachDestination(){this._exit()}_onExit(){this.getScene().removeChild(this)}_exit(){this._exitStartedAt=this._age}}O.MAX_SPEED=nt;O.StopReason=it;class C extends f{constructor(t,e,n){super(),this._intersectionsByAngle={},this._incomingIntersections=new Set,this._outgoingIntersections=new Set,this._roads=[],this._circle=g.create(t,e,n)}get position(){return this._circle.center}onAddedToScene(t){super.onAddedToScene(t),this._roads.forEach(e=>t.addChild(e))}getVisualConnectionPointAtAngle(t){return this._circle.pointOnCircumference(t)}connectToRoadAtAngle(t,e,n){const s=this._intersectionAtAngle(e);s.connectTo(t,n);const o=n===_.IN||this._incomingIntersections.has(s),a=n===_.OUT||this._outgoingIntersections.has(s);return o&&this._incomingIntersections.add(s),a&&this._outgoingIntersections.add(s),this._intersections.forEach(r=>{if(r!==s){if(o&&this._outgoingIntersections.has(r)){const h=new m(m.segmentAcrossCircle(this._circle,this._circle.center.sub(s.position).angle(),r.position.sub(this._circle.center).angle()));this._addRoad(new d(s,r,{path:h}))}if(a&&this._incomingIntersections.has(r)){const h=new m(m.segmentAcrossCircle(this._circle,this._circle.center.sub(r.position).angle(),s.position.sub(this._circle.center).angle()));this._addRoad(new d(r,s,{path:h}))}}}),s}_intersectionAtAngle(t){const e=t.toString();if(this._intersectionsByAngle[e])return this._intersectionsByAngle[e];const n=this._createIntersectionAtAngle(t);return this._intersectionsByAngle[e]=n,n}_createIntersectionAtAngle(t){const e=this.getVisualConnectionPointAtAngle(t);return new et(e.x,e.y)}get _intersections(){return ht(Object.keys(this._intersectionsByAngle).map(t=>this._intersectionsByAngle[t]))}_addRoad(t){this._roads.push(t),this.hasScene()&&this.getScene().addChild(t)}}const Wt=St.darken(.2),Yt=3,st=[5,10],T=st.reduce((i,t)=>i+t,0),qt=.05;class d extends f{constructor(t,e,{points:n,autoRound:s,path:o}={}){super(),this.isNode=!1,this._currentTravellers=[];const a=n?t.position.angleTo(n[0]):t.position.angleTo(e.position),r=n?e.position.angleTo(n[n.length-1]):e.position.angleTo(t.position);o?this._path=o:n?this._path=m.straightThroughPoints(t.getVisualConnectionPointAtAngle(a),...n,e.getVisualConnectionPointAtAngle(r)):this._path=new m().addSegment(new Ct(t.getVisualConnectionPointAtAngle(a),e.getVisualConnectionPointAtAngle(r))),s!=null&&this._path.autoRound(s),t instanceof C?this.from=t.connectToRoadAtAngle(this,a,_.OUT):(this.from=t,t.connectTo(this,_.OUT)),e instanceof C?this.to=e.connectToRoadAtAngle(this,r,_.IN):(this.to=e,e.connectTo(this,_.IN))}get length(){return this._path.getLength()}get start(){return this._path.getStart()}get end(){return this._path.getEnd()}get expectedTimeFromStartToEnd(){if(this._currentTravellers.length){const t=this._currentTravellers.reduce((e,n)=>e+n.speed,0)/this._currentTravellers.length;return this.length/t}return this.length/(O.MAX_SPEED*.7)}canAddTravellerAtStart(){const t=this.getTravellerAfterPosition(0);return t?t.positionOnCurrentRoad>t.comfortableRadius:!0}addTravellerAtStart(t){this._currentTravellers.push(t),t.onAddedToRoad(this)}removeTraveller(t){const e=this._currentTravellers.indexOf(t);return e===-1?!1:(this.removeTravellerAtIndex(e),!0)}removeTravellerAtIndex(t){const e=this._currentTravellers[t];return this._currentTravellers.splice(t,1),e.onRemovedFromRoad(),e}getAllReachableNodes(t=new Set){const e=[];return t.has(this.to)?e:[...this.to.getAllReachableNodes(t),this.to]}getPointAtPosition(t){return this._path.getPointAtPosition(t)}getAngleAtPosition(t){return this._path.getAngleAtPosition(t)}getTravellerAfterPosition(t){let e=null,n=1/0;return this._currentTravellers.forEach(s=>{const o=s.positionOnCurrentRoad-t;o<=0||o<n&&(n=o,e=s)}),e}getTravellerBeforePosition(t){let e=null,n=1/0;return this._currentTravellers.forEach(s=>{const o=t-s.positionOnCurrentRoad;o<=0||o<n&&(n=o,e=s)}),e}draw(t,e){t.beginPath(),t.lineCap="round",t.lineJoin="round",mt(t,this._path);const n=this._getLineDashScale(),s=T*n;t.setLineDash(st.map(o=>o*n)),t.strokeStyle=Wt.toString(),t.lineDashOffset=-e*qt*n%s,t.lineWidth=Yt,t.stroke()}_getLineDashScale(){const e=Math.floor(this.length/T)*T,n=this.length-e,s=e+T-this.length;return n<s?this.length/e:this.length/(e+T)}}const Xt=500,U=20,Kt=30,Jt=U*.7,jt=35,zt=500,Gt=150,X=B.lighten(.1),K=B.darken(.1),Qt=B.lighten(.2).fade(.1);class J extends f{constructor(t,e,n=Xt){super(),this.isDestination=!1,this.canConsumeTraveller=!1,this._connectionSet=new V,this._circle=g.create(t,e,U),this._visualConnectionCircle=g.create(t,e,Kt),this._cooldown=n,this._timer=n}get position(){return this._circle.center}get incomingConnections(){return this._connectionSet.incoming}get outgoingConnections(){return this._connectionSet.outgoing}getAllReachableNodes(t=new Set){return t.add(this),j(z(this._connectionSet.outgoing.map(e=>e.getAllReachableNodes(t))))}getVisualConnectionPointAtAngle(t){return this._visualConnectionCircle.pointOnCircumference(t)}consumeTraveller(){throw new Error("producer cannot consume traveller")}connectTo(t,e){this._connectionSet.add(t,e)}update(t){this._timer=u(0,this._cooldown,this._timer+t),this._timer>=this._cooldown&&this._onTimerEnd()}draw(t){const e=this._timer/this._cooldown,n=u(0,1,v(0,Gt,1,0,this._timer)),s=X.mix(K,n);t.beginPath(),t.fillStyle=s.toString(),S(t,this._circle.center.x,this._circle.center.y,this._circle.radius),t.fill(),t.beginPath(),t.fillStyle=K.toString(),t.moveTo(this._circle.center.x,this._circle.center.y),t.arc(this._circle.center.x,this._circle.center.y,this._circle.radius,-Math.PI/2,e*2*Math.PI-Math.PI/2,!1),t.fill(),t.beginPath(),t.fillStyle=X.toString(),S(t,this._circle.center.x,this._circle.center.y,Jt),t.fill()}_resetTimer(){this._timer=0}_onTimerEnd(){this._attemptEmitTraveller()&&(this._pulse(),this._resetTimer())}_pulse(){this.getScene().addChildBefore(this,new Z({x:this._circle.center.x,y:this._circle.center.y,startRadius:U,endRadius:jt,duration:zt,color:Qt,easeRadius:Tt,removeOnComplete:!0}))}_attemptEmitTraveller(){const t=this._connectionSet.sampleOutgoing();if(!(t instanceof d))return!1;if(t.canAddTravellerAtStart()){const e=new O;return t.addTravellerAtStart(e),this.getScene().addChild(e),!0}else return!1}}const I=50,c=new dt(800,600,window.devicePixelRatio),ot=document.getElementById("root");l(ot,"#root must be present");c.appendTo(ot);c.addSystem(new b);Zt();c.start();function Zt(){const i=new N(300,550,1500),t=new N(100,450,1500),e=new N(100,250,1500),n=new J(600,150,500),s=new J(100,100,500);c.addChild(i),c.addChild(t),c.addChild(e),c.addChild(n),c.addChild(s);const o=new C(300,150,I),a=new C(500,370,I),r=new C(330,400,I);c.addChild(o),c.addChild(a),c.addChild(r),c.addChild(new d(s,o)),c.addChild(new d(n,a)),c.addChild(new d(a,r)),c.addChild(new d(a,o,{points:[new D(400,300),new D(500,50)],autoRound:I})),c.addChild(new d(o,r)),c.addChild(new d(r,i)),c.addChild(new d(o,t)),c.addChild(new d(o,e))}
